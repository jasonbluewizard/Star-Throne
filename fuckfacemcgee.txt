FLEET SYSTEM DEBUG PACKAGE FOR ADVANCED AI ANALYSIS
===================================================

CRITICAL PROBLEM SUMMARY:
Fleet system renders correctly but click events never reach Fleet.handleClick().
Mouse events appear to be completely blocked at the canvas level.

DEBUG STATUS:
- Fleet.render() works: "Fleet: Rendering 0 animations" appears in console
- Fleet initialization works: "Fleet control system initialized" appears
- NO mousedown events detected: "*** MOUSEDOWN EVENT ***" never appears
- NO InputHandler messages: "InputHandler: Setting up event listeners" never appears
- NO click events: "*** DIRECT CANVAS CLICK DETECTED ***" never appears
- Unhandled rejection error in console suggests JavaScript error blocking events

KEY FILES AND CURRENT CODE:
==========================

1. CLIENT/SRC/GAME/FLEET.JS (Main Fleet System)
```javascript
export class Fleet {
    constructor(game) {
        this.game = game;
        this.selectedTerritory = null;
        this.transferAnimations = [];
        this.transferPercentage = 0.50;
        console.log('Fleet control system initialized');
    }
    
    handleClick(mousePos, isRightClick = false) {
        console.log(`Fleet: *** FLEET.HANDLECLICK CALLED ***`);
        console.log(`Fleet: isRightClick: ${isRightClick}, mousePos:`, mousePos);
        console.log(`Fleet: Time: ${Date.now()}`);
        const worldPos = this.game.camera.screenToWorld(mousePos.x, mousePos.y);
        const clickedTerritory = this.findTerritoryAtPosition(worldPos);
        
        if (clickedTerritory) {
            const result = this.handleTerritoryClick(clickedTerritory, isRightClick);
            return result;
        } else {
            const result = this.handleBlankSpaceClick();
            return result;
        }
    }
    
    handleTerritoryClick(territory, isRightClick) {
        const humanPlayer = this.game.players.find(p => p.type === 'human');
        if (!humanPlayer) return false;
        
        const isPlayerTerritory = territory.ownerId === humanPlayer.id;
        
        if (isRightClick && this.selectedTerritory && isPlayerTerritory) {
            // RMB on friendly system - attempt fleet transfer
            const result = this.attemptFleetTransfer(this.selectedTerritory, territory);
            return result;
        } else if (isRightClick && this.selectedTerritory && !isPlayerTerritory) {
            // RMB on enemy/colonizable - attack or probe
            if (territory.isColonizable) {
                return this.launchProbeAttack(this.selectedTerritory, territory);
            } else if (territory.ownerId !== null) {
                if (this.areConnectedByWarpLane(this.selectedTerritory, territory)) {
                    return this.launchAttack(this.selectedTerritory, territory);
                } else {
                    return true; // Consume click to prevent FSM fallback
                }
            }
        } else if (!isRightClick) {
            // LMB on any system - handle selection
            return this.handleSelection(territory, isPlayerTerritory);
        }
        
        // Fleet system consumes all territory clicks to prevent FSM fallback
        return true;
    }
    
    attemptFleetTransfer(fromTerritory, toTerritory) {
        // Check if territories are directly connected
        if (this.areConnectedByWarpLane(fromTerritory, toTerritory)) {
            // Direct transfer for adjacent territories
            return this.directFleetTransfer(fromTerritory, toTerritory);
        } else {
            // Use pathfinding for multi-hop transfers
            const result = this.transferWithPathfinding(fromTerritory, toTerritory);
            return result;
        }
    }
    
    transferWithPathfinding(fromTerritory, toTerritory) {
        const humanPlayer = this.game.players.find(p => p.type === 'human');
        if (!humanPlayer) {
            return true; // Consume click
        }

        // Find shortest path between territories
        const path = this.findShortestPath(fromTerritory.id, toTerritory.id);
        
        if (!path || path.length < 2) {
            console.log('Fleet: No valid path found between territories');
            return true; // Return true to prevent FSM fallback and camera interference
        }

        const armyCount = fromTerritory.armySize || fromTerritory.armies || 0;
        
        if (armyCount < 2) {
            console.log(`Fleet: Not enough ships for transfer (${armyCount} < 2)`);
            return true; // Return true to prevent camera issues
        }

        const shipsToSend = Math.floor(armyCount * 0.5);
        
        // Create multi-hop animation
        this.createMultiHopAnimation(path, shipsToSend);
        
        // Deduct ships from source
        if (fromTerritory.armySize !== undefined) {
            fromTerritory.armySize -= shipsToSend;
        } else if (fromTerritory.armies !== undefined) {
            fromTerritory.armies -= shipsToSend;
        }
        
        // Schedule final delivery
        const totalTime = (path.length - 1) * 800;
        setTimeout(() => {
            const finalArmyCount = toTerritory.armySize || toTerritory.armies || 0;
            
            if (toTerritory.armySize !== undefined) {
                toTerritory.armySize += shipsToSend;
            } else if (toTerritory.armies !== undefined) {
                toTerritory.armies += shipsToSend;
            }
        }, totalTime);
        
        return true; // Always return true to prevent camera interference
    }
    
    findShortestPath(fromId, toId) {
        const humanPlayer = this.game.players.find(p => p.type === 'human');
        if (!humanPlayer) return null;

        // BFS to find shortest path through player-owned territories
        const queue = [[fromId]];
        const visited = new Set([fromId]);

        while (queue.length > 0) {
            const path = queue.shift();
            const currentId = path[path.length - 1];

            // Found destination
            if (currentId === toId) {
                return path;
            }

            // Get current territory
            const currentTerritory = this.game.territories.find(t => t.id === currentId);
            if (!currentTerritory) continue;

            // Explore connected territories - check both neighbors and connections arrays
            const connections = currentTerritory.neighbors || currentTerritory.connections || [];
            
            for (let connectedId of connections) {
                if (visited.has(connectedId)) continue;

                const connectedTerritory = this.game.territories.find(t => t.id === connectedId);
                if (!connectedTerritory) continue;

                // Only traverse through player-owned territories (except destination)
                if (connectedId !== toId && connectedTerritory.ownerId !== humanPlayer.id) {
                    continue;
                }

                visited.add(connectedId);
                queue.push([...path, connectedId]);
            }
        }

        return null; // No path found
    }
}
```

2. CLIENT/SRC/GAME/INPUTHANDLER.JS (Event Routing System)
```javascript
export class InputHandler {
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        
        // Input state
        this.mousePos = { x: 0, y: 0 };
        this.modifierKeys = {
            shift: false,
            ctrl: false,
            alt: false
        };
        
        // Initialize FSM
        this.inputFSM = new InputStateMachine(game);
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        console.log('InputHandler: Setting up event listeners on canvas:', !!this.canvas);
        
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        console.log('InputHandler: Mouse event listeners attached');
        
        // Touch and keyboard events...
    }
    
    handleMouseDown(e) {
        console.log(`InputHandler: *** MOUSEDOWN EVENT *** Button: ${e.button}`);
        e.preventDefault();
        this.isDragging = false;
        
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        
        this.dragStartPos = { ...this.mousePos };
        this.dragStartTime = Date.now();
        
        const worldPos = this.game.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.game.gameMap.findTerritoryAt(worldPos.x, worldPos.y);
    }
    
    handleMouseUp(e) {
        const wasQuickClick = Date.now() - this.dragStartTime < 200;
        
        if (e.button === 0 && wasQuickClick) {
            // LEFT CLICK ROUTING TO FLEET SYSTEM
            console.log(`InputHandler: Checking Fleet system - exists: ${!!this.game.fleet}`);
            if (this.game.fleet && this.game.fleet.handleClick) {
                console.log(`InputHandler: Calling Fleet.handleClick for left click`);
                if (this.game.fleet.handleClick(this.mousePos, false)) {
                    // Fleet system handled the click
                    console.log(`InputHandler: Fleet handled left click`);
                    this.resetDragState();
                    return;
                } else {
                    console.log(`InputHandler: Fleet did not handle left click, falling back to FSM`);
                }
            } else {
                console.log(`InputHandler: No Fleet system available, using FSM`);
            }
            
            // Fallback to FSM...
        }
        else if (e.button === 2 && wasQuickClick) {
            // RIGHT CLICK ROUTING TO FLEET SYSTEM
            console.log(`InputHandler: Checking Fleet system for right click - exists: ${!!this.game.fleet}`);
            if (this.game.fleet && this.game.fleet.handleClick) {
                console.log(`InputHandler: Calling Fleet.handleClick for right click`);
                if (this.game.fleet.handleClick(this.mousePos, true)) {
                    // Fleet system handled the click - stop processing
                    console.log(`InputHandler: Fleet handled right click - stopping propagation`);
                    this.resetDragState();
                    return; // Exit immediately, no fallback
                } else {
                    console.log(`InputHandler: Fleet did not handle right click, falling back to FSM`);
                }
            } else {
                console.log(`InputHandler: No Fleet system available for right click, using FSM`);
            }
            
            // Fallback to FSM...
        }
    }
}
```

3. CLIENT/SRC/GAME/STARTHRONE.JS (Initialization)
```javascript
init() {
    this.setupCanvas();
    this.setupEventListeners();
    this.gameMap = new GameMap(2000, 1500, this.config);
    this.camera = new Camera(this.canvas.width, this.canvas.height);
    this.ui = new GameUI(this.canvas, this.camera);
    
    // Initialize modular systems
    try {
        this.inputHandler = new InputHandler(this);
        console.log('InputHandler initialized successfully');
    } catch (error) {
        console.error('Failed to initialize InputHandler:', error);
    }
    
    // Other systems...
    this.fleet = new Fleet(this);
    console.log('Fleet control system initialized');
    console.log('InputHandler Fleet reference check:', !!this.inputHandler.game.fleet);
    
    // Test canvas click events with a simple listener
    this.canvas.addEventListener('click', (e) => {
        console.log('*** DIRECT CANVAS CLICK DETECTED ***');
        console.log('Click coordinates:', e.clientX, e.clientY);
    });
}

setupEventListeners() {
    if (!this.canvas) {
        console.error('Canvas not available for event listeners');
        return;
    }
    
    // Mouse events now handled by InputHandler.js - removed to prevent conflicts
    // Only touch events remain in StarThrone.js
}
```

PROBLEM ANALYSIS:
===============

The Fleet system architecture is correct according to advanced AI diagnosis:
- Fleet.handleClick() properly consumes territory clicks (returns true)
- InputHandler routes clicks to Fleet system first, then falls back to FSM
- BFS pathfinding algorithm correctly finds multi-hop paths
- Fleet system prevents FSM fallback that was causing camera lock

ACTUAL ISSUE:
The event handling chain is completely broken at the canvas level:
- NO "InputHandler: Setting up event listeners" message
- NO "*** MOUSEDOWN EVENT ***" messages  
- NO "*** DIRECT CANVAS CLICK DETECTED ***" messages
- Unhandled rejection error suggests JavaScript error blocking initialization

ROOT CAUSE HYPOTHESES:
1. JavaScript error during InputHandler initialization prevents event listeners
2. Canvas element not properly receiving mouse events
3. Event listeners being overridden or removed by another system
4. Race condition where InputHandler initializes before canvas is ready

VERIFICATION NEEDED:
1. Check if "InputHandler initialized successfully" appears in console
2. Check if "InputHandler: Setting up event listeners" appears
3. Check if direct canvas click test fires when clicking game
4. Identify the unhandled rejection error source

The Fleet system fixes are correct - the issue is that click events never reach the InputHandler in the first place.