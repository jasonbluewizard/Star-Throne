# STAR THRONE - COMPLETE SOURCE CODE
# Generated: January 2, 2025
# Total Lines: 12,062 across all files
#
# This file contains the complete source code for Star Throne,
# a browser-based real-time strategy game supporting up to 100 players.

================================================================================
FILE: client/src/game/StarThrone.js (3,405 lines)
================================================================================import { GameMap } from './GameMap.js';
import { Player } from './Player.js';
import { GameUI } from './GameUI.js';
import { Camera } from './Camera.js';
import { Probe } from './Probe.js';
import { InputHandler } from './InputHandler.js';
import { Renderer } from './Renderer.js';
import { CombatSystem } from './CombatSystem.js';
import { SupplySystem } from './SupplySystem.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants.ts';

export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        
        // Legacy properties for backward compatibility
        this.hoveredTerritory = null;
        
        // Performance
        this.lastFrameTime = 0;
        this.fps = 0;
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        
        // Performance optimizations
        this.visibleTerritories = [];
        this.lastVisibilityUpdate = 0;
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        this.showPerformancePanel = false; // Toggle with P key
        
        // Ship movement animations
        this.shipAnimations = [];
        this.shipAnimationPool = []; // Reuse objects to reduce garbage collection
        
        // Pre-populate animation pool with multi-hop support
        for (let i = 0; i < 20; i++) {
            this.shipAnimationPool.push({
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            });
        }
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Default minimap to off
        
        // Probe system
        this.probes = [];
        this.nextProbeId = 0;
        
        // Discovery announcements
        this.floatingDiscoveryTexts = [];
        this.discoveryLog = []; // Recent discovery announcements for panel display
        
        // Ship funneling system
        this.supplyRoutes = new Map(); // territoryId -> { targetId, path, delay }
        this.dragStart = null;
        this.dragEnd = null;
        this.isDraggingForSupplyRoute = false;
        
        // Background image system
        this.backgroundImage = null;
        this.backgroundLoaded = false;
        this.backgroundScale = 1.0;
        
        // Parallax starfield system
        this.starfield = {
            farStars: [],      // Slowest moving, smallest stars
            midStars: [],      // Medium speed, medium stars  
            nearStars: [],     // Fastest moving, larger stars
            initialized: false
        };
        
        // Static background optimization
        this.staticBg = document.createElement('canvas');
        this.staticBgCtx = this.staticBg.getContext('2d');
        
        // Discovery system for planet colonization - per player tracking
        this.playerDiscoveries = new Map(); // Map of playerId -> discoveries
        
        // Global discovery log for all players
        this.discoveryLog = [];
        
        // Recent probe results for UI announcements
        this.recentProbeResults = [];
        
        // Notification system
        this.notifications = [];
        
        // Bonus panel state
        this.showBonusPanel = true;
        
        // Message display system
        this.messageText = '';
        this.messageTimer = 0;
        
        this.init();
        this.loadBackgroundImage();
    }
    
    loadBackgroundImage() {
        // Load the background galaxy image
        this.backgroundImage = new Image();
        this.backgroundImage.onload = () => {
            this.backgroundLoaded = true;
            console.log('Background galaxy image loaded');
        };
        this.backgroundImage.onerror = () => {
            console.log('Background image failed to load, using default starfield');
            this.backgroundLoaded = false;
        };
        // Set the image path
        this.backgroundImage.src = '/galaxy-background.jpg';
    }
    
    renderBackgroundImage() {
        if (!this.backgroundImage || !this.backgroundLoaded) return;
        
        this.ctx.save();
        
        // Calculate parallax offset (background moves slower than camera)
        const parallaxFactor = 0.2; // Background moves at 20% of camera speed
        const offsetX = -this.camera.x * parallaxFactor;
        const offsetY = -this.camera.y * parallaxFactor;
        
        // Calculate scale to ensure image covers the entire viewport
        const imageAspect = this.backgroundImage.width / this.backgroundImage.height;
        const canvasAspect = this.canvas.width / this.canvas.height;
        
        let drawWidth, drawHeight;
        if (imageAspect > canvasAspect) {
            // Image is wider - fit to height
            drawHeight = this.canvas.height * 1.5; // Scale up for parallax coverage
            drawWidth = drawHeight * imageAspect;
        } else {
            // Image is taller - fit to width
            drawWidth = this.canvas.width * 1.5; // Scale up for parallax coverage
            drawHeight = drawWidth / imageAspect;
        }
        
        // Center the image with parallax offset
        const drawX = (this.canvas.width - drawWidth) / 2 + offsetX;
        const drawY = (this.canvas.height - drawHeight) / 2 + offsetY;
        
        // Draw the background image with very low opacity
        this.ctx.globalAlpha = 0.15; // Even more transparent for very subtle background effect
        this.ctx.drawImage(this.backgroundImage, drawX, drawY, drawWidth, drawHeight);
        
        // Add dark overlay to further dim the background
        this.ctx.globalAlpha = 0.6;
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.globalAlpha = 1.0;
        
        this.ctx.restore();
    }
    
    // Add notification to display queue
    addNotification(text, color = '#44ff44', duration = 4000) {
        this.notifications.push({
            text: text,
            color: color,
            createdAt: Date.now(),
            duration: duration,
            opacity: 1.0
        });
    }
    
    // Update and clean up notifications
    updateNotifications() {
        const now = Date.now();
        this.notifications = this.notifications.filter(notification => {
            const age = now - notification.createdAt;
            if (age > notification.duration) {
                return false; // Remove expired notifications
            }
            
            // Fade out in the last 500ms
            if (age > notification.duration - 500) {
                notification.opacity = (notification.duration - age) / 500;
            }
            
            return true;
        });
    }
    
    // Message display system for FSM feedback
    showMessage(text, duration = 3000) {
        this.messageText = text;
        this.messageTimer = duration;
        console.log(`Message: ${text}`);
    }
    
    hideMessage() {
        this.messageText = '';
        this.messageTimer = 0;
    }
    
    showError(text) {
        this.showMessage(`❌ ${text}`, 2000);
    }
    
    updateMessage(deltaTime) {
        if (this.messageTimer > 0) {
            this.messageTimer -= deltaTime;
            if (this.messageTimer <= 0) {
                this.hideMessage();
            }
        }
    }
    
    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.gameMap = new GameMap(2000, 1500, this.config); // Large map with advanced configuration
        this.gameMap.game = this; // Reference for AI animations
        this.camera = new Camera(this.canvas.width, this.canvas.height);
        
        // Update camera map boundaries to match actual expanded map size
        this.camera.mapWidth = this.gameMap.width;
        this.camera.mapHeight = this.gameMap.height;
        
        // Center camera on map and set appropriate zoom
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2); // Center of expanded map
        this.camera.targetZoom = 0.25; // Zoom out further to see more territories
        this.camera.zoom = 0.25;
        
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Initialize modular systems
        this.inputHandler = new InputHandler(this);
        this.renderer = new Renderer(this.canvas, this.camera);
        this.combatSystem = new CombatSystem(this);
        this.supplySystem = new SupplySystem(this);
        
        this.gameStartTime = Date.now(); // Track when game actually starts
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            {
                id: 'hostile_aliens',
                name: 'Hostile Aliens',
                description: 'Hostile alien life destroys your probe!',
                probability: 0.15,
                type: 'negative',
                effect: 'probe_lost'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.12,
                type: 'positive',
                effect: 'extra_fleet',
                bonus: 50
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons Cache',
                description: 'Ancient weapon technology discovered!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'attack_bonus',
                bonus: 10 // +10% attack
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'speed_bonus',
                bonus: 20 // +20% speed
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology enhances your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'defense_bonus',
                bonus: 10 // +10% defense
            },
            {
                id: 'precursor_factory',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facility still operational!',
                probability: 0.06,
                type: 'planet_bonus',
                effect: 'factory_planet',
                bonus: 100 // +100% generation (200% total)
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating technology spreads across your empire!',
                probability: 0.05,
                type: 'empire_bonus',
                effect: 'generation_bonus',
                bonus: 10 // +10% empire-wide generation
            },
            {
                id: 'mineral_deposits',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.10,
                type: 'planet_bonus',
                effect: 'mineral_planet',
                bonus: 50 // +50% generation
            },
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                description: 'Mysterious structures provide no immediate benefit.',
                probability: 0.08,
                type: 'neutral',
                effect: 'cosmetic'
            },
            {
                id: 'void_storm',
                name: 'Void Storm Remnants',
                description: 'Dangerous energy storms reduce planet effectiveness.',
                probability: 0.06,
                type: 'negative',
                effect: 'reduced_generation',
                bonus: -25 // -25% generation
            },
            {
                id: 'no_discovery',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.14,
                type: 'neutral',
                effect: 'none'
            }
        ];
    }
    
    // Initialize parallax starfield layers
    initializeStarfield() {
        if (this.starfield.initialized) return;
        
        // Expand starfield area beyond visible map for smooth parallax
        const starfieldWidth = this.gameMap.width * 2;
        const starfieldHeight = this.gameMap.height * 2;
        const offsetX = -this.gameMap.width * 0.5;
        const offsetY = -this.gameMap.height * 0.5;
        
        // Far layer: Many small, dim stars that barely move
        for (let i = 0; i < 300; i++) {
            this.starfield.farStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1 + 0.5,
                brightness: Math.random() * 0.3 + 0.1,
                twinkle: Math.random() * 0.2 + 0.8
            });
        }
        
        // Mid layer: Medium stars with moderate movement
        for (let i = 0; i < 150; i++) {
            this.starfield.midStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1.5 + 1,
                brightness: Math.random() * 0.4 + 0.2,
                twinkle: Math.random() * 0.3 + 0.7
            });
        }
        
        // Near layer: Fewer large stars with most movement
        for (let i = 0; i < 80; i++) {
            this.starfield.nearStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 2 + 1.5,
                brightness: Math.random() * 0.5 + 0.3,
                twinkle: Math.random() * 0.4 + 0.6
            });
        }
        
        this.starfield.initialized = true;
        console.log('Parallax starfield initialized with 530 stars across 3 layers');
    }
    
    // Pre-render static background elements once for performance optimization
    preRenderStaticBackground() {
        // Set static canvas to game map size
        this.staticBg.width = this.gameMap.width;
        this.staticBg.height = this.gameMap.height;
        
        // Clear the static background
        this.staticBgCtx.fillStyle = '#0a0a1a';
        this.staticBgCtx.fillRect(0, 0, this.staticBg.width, this.staticBg.height);
        
        // Render starfield to static background (once only)
        this.renderStarfieldStatic(this.staticBgCtx);
        
        // Render nebulas to static background (once only)
        this.renderNebulasStatic(this.staticBgCtx);
        
        console.log('Static background pre-rendered for performance optimization');
    }
    
    // Render starfield without parallax for static background
    renderStarfieldStatic(ctx) {
        if (!this.starfield.initialized) return;
        
        ctx.save();
        
        // Render all star layers at base positions (no parallax)
        const renderLayer = (stars, baseOpacity) => {
            stars.forEach(star => {
                // Simple twinkling effect for static background
                const twinkle = 0.8; // Static brightness
                const opacity = star.brightness * baseOpacity * twinkle;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        };
        
        // Render all layers
        renderLayer(this.starfield.farStars, 0.7);
        renderLayer(this.starfield.midStars, 0.8);
        renderLayer(this.starfield.nearStars, 1.0);
        
        ctx.restore();
    }
    
    // Render nebulas for static background
    renderNebulasStatic(ctx) {
        if (!this.gameMap.nebulas) return;
        
        this.gameMap.nebulas.forEach(nebula => {
            const gradient = ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Log discovery for UI display (called for both successful and failed probes)
    logDiscoveryForUI(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log for UI display
        this.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`🔍 Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Add floating discovery text above the planet
        this.addFloatingDiscoveryText(territory, discovery, playerId);
        
        // Track probe result for UI announcements
        this.recentProbeResults.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discoveryName: discovery.name,
            success: discovery.effect !== 'probe_lost',
            discovery: discovery
        });
        
        // Keep only recent results (last 10)
        if (this.recentProbeResults.length > 10) {
            this.recentProbeResults.shift();
        }
    }
    
    // Process discovery when a planet is successfully colonized
    processDiscovery(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return false;
        
        // Get player's discoveries
        const playerDiscoveries = this.playerDiscoveries.get(playerId);
        if (!playerDiscoveries) return false;
        
        // Apply discovery effects
        switch (discovery.effect) {
            case 'probe_lost':
                // Probe is destroyed, planet remains unexplored
                territory.isColonizable = true;
                territory.ownerId = null;
                territory.armySize = territory.hiddenArmySize || Math.floor(Math.random() * 50) + 1;
                
                // Add explosion animation for the territory
                territory.explosionTime = Date.now();
                territory.explosionDuration = 1500; // 1.5 second explosion
                
                console.log(`💀 Probe lost to hostile aliens! Planet ${territory.id} remains unexplored.`);
                return false; // Colonization failed
                
            case 'extra_fleet':
                // Friendly aliens boost fleet strength
                territory.armySize += discovery.bonus;
                const friendlyMessage = `👽 Friendly aliens provide ${discovery.bonus} fleet strength!`;
                console.log(friendlyMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(friendlyMessage, '#44ff44');
                }
                break;
                
            case 'attack_bonus':
                // Empire-wide attack bonus
                playerDiscoveries.precursorWeapons++;
                const weaponMessage = `⚔️ Precursor Weapons Level ${playerDiscoveries.precursorWeapons}! Empire attack increased by 10%`;
                console.log(weaponMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(weaponMessage, '#ff6600');
                }
                break;
                
            case 'speed_bonus':
                // Empire-wide speed bonus
                playerDiscoveries.precursorDrive++;
                const driveMessage = `🚀 Precursor Drive Level ${playerDiscoveries.precursorDrive}! Empire speed increased by 20%`;
                console.log(driveMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(driveMessage, '#00ddff');
                }
                break;
                
            case 'defense_bonus':
                // Empire-wide defense bonus
                playerDiscoveries.precursorShield++;
                const shieldMessage = `🛡️ Precursor Shield Level ${playerDiscoveries.precursorShield}! Empire defense increased by 10%`;
                console.log(shieldMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(shieldMessage, '#0088ff');
                }
                break;
                
            case 'factory_planet':
                // Planet gets double generation rate
                playerDiscoveries.factoryPlanets.add(territory.id);
                territory.discoveryBonus = 'factory';
                territory.hasFactory = true; // Add factory icon
                const factoryMessage = `🏭 Precursor Factory discovered! Planet ${territory.id} has 200% generation rate`;
                console.log(factoryMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(factoryMessage, '#ff8800');
                }
                break;
                
            case 'generation_bonus':
                // Planet gets improved generation rate
                playerDiscoveries.precursorNanotech++;
                const nanotechMessage = `🔬 Precursor Nanotech Level ${playerDiscoveries.precursorNanotech}! Empire generation increased by 10%`;
                console.log(nanotechMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(nanotechMessage, '#00ff88');
                }
                break;
                
            default:
                // Standard planet colonization
                break;
        }
        
        return true; // Colonization successful
    }
    
    addFloatingDiscoveryText(territory, discovery, playerId) {
        // Create floating text object
        const floatingText = {
            x: territory.x,
            y: territory.y - 40, // Start above the planet
            text: discovery.name,
            icon: this.getDiscoveryIcon(discovery.effect),
            color: this.getDiscoveryColor(discovery.effect),
            startTime: Date.now(),
            duration: 4000, // 4 seconds
            fadeOutDuration: 1000, // Last 1 second fades out
            playerId: playerId
        };
        
        this.floatingDiscoveryTexts.push(floatingText);
        
        // Limit to 10 floating texts to prevent clutter
        if (this.floatingDiscoveryTexts.length > 10) {
            this.floatingDiscoveryTexts.shift();
        }
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': '💀',
            'extra_fleet': '👽',
            'precursor_weapons': '⚔️',
            'precursor_drive': '🚀',
            'precursor_shield': '🛡️',
            'precursor_nanotech': '🔬',
            'factory_complex': '🏭',
            'mineral_deposits': '💎',
            'void_storm': '⚡',
            'ancient_ruins': '🏛️'
        };
        return icons[effect] || '🔍';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    updateFloatingDiscoveryTexts(deltaTime) {
        const now = Date.now();
        
        // Update and remove expired floating texts
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            
            if (age > text.duration) {
                return false; // Remove expired text
            }
            
            // Animate the text (float upward)
            text.y -= 20 * (deltaTime / 1000); // Move up 20 pixels per second
            
            return true;
        });
    }
    
    processDiscovery(territory, playerId, discovery) {
        // Get player's discoveries
        const playerDiscoveries = this.playerDiscoveries.get(playerId);
        if (!playerDiscoveries) return false;
        
        // Apply discovery effects
        switch (discovery.effect) {
            case 'probe_lost':
                // Probe is destroyed, planet remains unexplored
                territory.isColonizable = true;
                territory.ownerId = null;
                territory.armySize = territory.hiddenArmySize || Math.floor(Math.random() * 50) + 1;
                
                // Add explosion animation for the territory
                territory.explosionTime = Date.now();
                territory.explosionDuration = 1500; // 1.5 second explosion
                
                console.log(`💀 Probe lost to hostile aliens! Planet ${territory.id} remains unexplored.`);
                return false; // Colonization failed
                
            case 'extra_fleet':
                // Friendly aliens boost fleet strength
                territory.armySize += discovery.bonus;
                const friendlyMessage = `👽 Friendly aliens provide ${discovery.bonus} fleet strength!`;
                console.log(friendlyMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'attack_bonus':
                // Empire-wide attack bonus
                playerDiscoveries.precursorWeapons++;
                const weaponMessage = `⚔️ Precursor Weapons Level ${playerDiscoveries.precursorWeapons}! Empire attack increased by 10%`;
                console.log(weaponMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'speed_bonus':
                // Empire-wide speed bonus
                playerDiscoveries.precursorDrive++;
                const driveMessage = `🚀 Precursor Drive Level ${playerDiscoveries.precursorDrive}! Empire speed increased by 20%`;
                console.log(driveMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'defense_bonus':
                // Empire-wide defense bonus
                playerDiscoveries.precursorShield++;
                const shieldMessage = `🛡️ Precursor Shield Level ${playerDiscoveries.precursorShield}! Empire defense increased by 10%`;
                console.log(shieldMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'factory_planet':
                // Planet gets double generation rate
                playerDiscoveries.factoryPlanets.add(territory.id);
                territory.discoveryBonus = 'factory';
                territory.hasFactory = true; // Add factory icon
                const factoryMessage = `🏭 Precursor Factory discovered! Planet ${territory.id} has 200% generation rate`;
                console.log(factoryMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'generation_bonus':
                // Empire-wide generation bonus
                playerDiscoveries.precursorNanotech++;
                const nanotechMessage = `🔬 Precursor Nanotech Level ${playerDiscoveries.precursorNanotech}! Empire generation increased by 10%`;
                console.log(nanotechMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'mineral_planet':
                // Planet gets +50% generation
                territory.discoveryBonus = 'minerals';
                const mineralMessage = `💎 Rich minerals found! Planet ${territory.id} has 150% generation rate`;
                console.log(mineralMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'reduced_generation':
                // Planet gets reduced generation
                territory.discoveryBonus = 'void_storm';
                const stormMessage = `⚡ Void storm remnants! Planet ${territory.id} has 75% generation rate`;
                console.log(stormMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            case 'cosmetic':
                // Ancient ruins - cosmetic only
                territory.discoveryBonus = 'ruins';
                const ruinsMessage = `🏛️ Ancient ruins discovered on planet ${territory.id}`;
                console.log(ruinsMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
                
            default:
                // No special effect
                const standardMessage = `🌍 Standard planet colonized: ${territory.id}`;
                console.log(standardMessage);
                // Notification disabled - using top-center UI notifications instead
                break;
        }
        
        return true; // Colonization successful
    }
    
    // Create ship movement animation
    createShipAnimation(fromTerritory, toTerritory, isAttack = false) {
        // Use object pooling to reduce garbage collection
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            };
        }
        
        const player = this.players[fromTerritory.ownerId];
        const playerColor = player ? player.color : '#ffffff';
        
        // Reset animation properties
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 1000 / this.config.gameSpeed;
        animation.startTime = Date.now();
        animation.isAttack = isAttack;
        animation.playerColor = playerColor;
        animation.id = Math.random();
        animation.path = null;
        animation.currentSegment = 0;
        animation.isMultiHop = false;
        
        this.shipAnimations.push(animation);
    }

    // Create multi-hop ship animation following supply route path
    createSupplyRouteAnimation(path, playerColor) {
        if (!path || path.length < 2) return;
        
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            };
        }
        
        // Set up multi-hop animation
        animation.path = path;
        animation.currentSegment = 0;
        animation.isMultiHop = true;
        animation.playerColor = playerColor;
        animation.isAttack = false;
        animation.id = Math.random();
        
        // Start with first segment
        this.initializeAnimationSegment(animation);
        
        this.shipAnimations.push(animation);
    }

    // Initialize animation segment for multi-hop
    initializeAnimationSegment(animation) {
        if (!animation.path || animation.currentSegment >= animation.path.length - 1) {
            return false;
        }
        
        const fromTerritory = animation.path[animation.currentSegment];
        const toTerritory = animation.path[animation.currentSegment + 1];
        
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 800 / this.config.gameSpeed; // Faster per-segment animation
        animation.startTime = Date.now();
        
        return true;
    }
    
    // Update ship animations
    updateShipAnimations(deltaTime) {
        const currentTime = Date.now();
        
        // Optimize with object pooling and manual iteration
        for (let i = this.shipAnimations.length - 1; i >= 0; i--) {
            const animation = this.shipAnimations[i];
            animation.progress = (currentTime - animation.startTime) / animation.duration;
            
            if (animation.progress >= 1) {
                if (animation.isMultiHop && animation.path) {
                    // Move to next segment in multi-hop animation
                    animation.currentSegment++;
                    
                    if (this.initializeAnimationSegment(animation)) {
                        // Continue to next segment
                        continue;
                    }
                }
                
                // Return completed animation to pool for reuse
                this.shipAnimationPool.push(animation);
                this.shipAnimations.splice(i, 1);
            }
        }
    }
    
    // Update probes
    updateProbes(deltaTime) {
        for (let i = this.probes.length - 1; i >= 0; i--) {
            const probe = this.probes[i];
            const reachedDestination = probe.update(deltaTime);
            
            if (reachedDestination) {
                // Probe reached destination - colonize the planet
                this.colonizePlanet(probe);
                this.probes.splice(i, 1);
            }
        }
    }
    
    // Colonize planet when probe arrives
    colonizePlanet(probe) {
        const planet = probe.toTerritory;
        const player = this.players.find(p => p.id === probe.playerId);
        
        if (!planet || !player) return;
        
        console.log(`Probe colonizing planet ${planet.id} for player ${player.name}`);
        
        // Trigger discovery event before colonization
        const discovery = this.selectRandomDiscovery();
        const colonizationSuccessful = this.processDiscovery(planet, player.id, discovery);
        
        // Always log the discovery for UI display (both success and failure)
        this.logDiscoveryForUI(planet, player.id, discovery);
        
        // If probe was lost to hostile aliens, colonization fails
        if (!colonizationSuccessful) {
            console.log(`Colonization of planet ${planet.id} failed due to hostile encounter!`);
            return;
        }
        
        // Set ownership - discovery might have already set army size
        planet.ownerId = player.id;
        if (planet.armySize === 0 || planet.armySize === planet.hiddenArmySize) {
            planet.armySize = 1; // Default if not set by discovery
        }
        
        // Mark as no longer colonizable
        planet.isColonizable = false;
        
        // Add to player's territories
        player.territories.push(planet.id);
        
        // Reveal hidden connections
        planet.revealConnections();
        
        // Update neighboring territories' connections
        Object.values(this.gameMap.territories).forEach(territory => {
            if (territory.hiddenNeighbors.includes(planet.id)) {
                territory.hiddenNeighbors = territory.hiddenNeighbors.filter(id => id !== planet.id);
                territory.neighbors.push(planet.id);
            }
        });
        
        // Update player stats
        player.updateStats();
        
        console.log(`Planet ${planet.id} colonized successfully! Discovery: ${discovery.name}`);
    }
    
    // Render ship animations
    renderShipAnimations() {
        this.shipAnimations.forEach(animation => {
            const progress = Math.min(1, animation.progress);
            const eased = this.easeInOutQuad(progress);
            
            const x = animation.fromX + (animation.toX - animation.fromX) * eased;
            const y = animation.fromY + (animation.toY - animation.fromY) * eased;
            
            // Draw ship using player's color
            this.ctx.save();
            this.ctx.fillStyle = animation.playerColor;
            this.ctx.shadowColor = animation.playerColor;
            this.ctx.shadowBlur = 8;
            
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Add trail effect
            const trailLength = 5;
            for (let i = 1; i <= trailLength; i++) {
                const trailProgress = Math.max(0, eased - (i * 0.1));
                const trailX = animation.fromX + (animation.toX - animation.fromX) * trailProgress;
                const trailY = animation.fromY + (animation.toY - animation.fromY) * trailProgress;
                
                this.ctx.globalAlpha = (trailLength - i) / trailLength * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(trailX, trailY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
        });
    }
    
    // Render probes
    renderProbes() {
        this.probes.forEach(probe => {
            probe.render(this.ctx);
        });
    }
    
    renderFloatingDiscoveryTexts() {
        if (this.floatingDiscoveryTexts.length === 0) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        this.floatingDiscoveryTexts.forEach(text => {
            const now = Date.now();
            const age = now - text.startTime;
            const progress = age / text.duration;
            
            // Calculate opacity (fade out in the last 25% of duration)
            let opacity = 1;
            if (progress > 0.75) {
                opacity = 1 - ((progress - 0.75) / 0.25);
            }
            
            // Only render if text is within camera view
            const screenPos = this.camera.worldToScreen(text.x, text.y);
            if (screenPos.x >= -100 && screenPos.x <= this.canvas.width + 100 &&
                screenPos.y >= -100 && screenPos.y <= this.canvas.height + 100) {
                
                // Draw background
                this.ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.8})`;
                const textWidth = this.ctx.measureText(text.text).width;
                this.ctx.fillRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw border
                this.ctx.strokeStyle = text.color;
                this.ctx.globalAlpha = opacity;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw icon
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.icon, screenPos.x - textWidth/2 - 5, screenPos.y - 2);
                
                // Draw text
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.text, screenPos.x + 10, screenPos.y - 2);
            }
        });
        
        this.ctx.restore();
    }
    
    // Easing function for smooth animation
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    setupCanvas() {
        // Create canvas element
        const canvasElement = document.createElement('canvas');
        canvasElement.id = 'gameCanvas';
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        canvasElement.style.display = 'block';
        canvasElement.style.background = '#1a1a2e';
        
        console.log('Creating canvas:', canvasElement.width, 'x', canvasElement.height);
        
        // Replace the root div content
        const root = document.getElementById('root');
        if (root) {
            root.innerHTML = '';
            root.appendChild(canvasElement);
            console.log('Canvas appended to root');
        } else {
            console.error('Root element not found!');
            return;
        }
        
        this.canvas = canvasElement;
        this.ctx = canvasElement.getContext('2d');
        
        if (!this.ctx) {
            console.error('Failed to get 2D context!');
            return;
        }
        
        console.log('Canvas setup complete');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera) {
                this.camera.updateViewport(this.canvas.width, this.canvas.height);
            }
        });
    }
    
    setupEventListeners() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        // Wheel events handled by InputHandler
        
        // Touch events for mobile - with better event handling
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: false });
        
        // Also add document-level listeners to catch events outside canvas
        document.addEventListener('touchmove', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Enhanced touch state tracking for better pinch-to-zoom
        this.touchStartTime = 0;
        this.touchStartDistance = null;
        this.lastPinchDistance = null;
        this.isMultiTouch = false;
        this.touchDebugInfo = '';
        this.showTouchDebug = true;
        this.leaderboardMinimized = false;
        this.lastZoomTime = 0;
        this.pinchCenter = null;
        this.initialZoom = 1.0;
        
        // Long press functionality
        this.longPressTimer = null;
        this.longPressThreshold = 800; // 800ms for long press
        this.longPressTarget = null;
        this.longPressStartPos = null;
        
        // Keyboard events now handled by InputHandler
        
        // Prevent context menu
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    startGame() {
        console.log('Starting Star Throne game with config:', this.config);
        
        // Generate territories using configured map size
        this.gameMap.generateTerritories(this.config.mapSize);
        
        // Create players: 1 human + configured AI count
        const totalPlayers = 1 + this.config.aiCount;
        this.createPlayers(Math.min(totalPlayers, this.maxPlayers));
        
        // Update human player name from config
        if (this.humanPlayer) {
            this.humanPlayer.name = this.config.playerName;
        }
        
        // Distribute initial territories
        this.distributeStartingTerritories();
        
        // Center camera on human player's starting territory
        if (this.humanPlayer && this.humanPlayer.territories.length > 0) {
            const startTerritory = this.gameMap.territories[this.humanPlayer.territories[0]];
            this.camera.centerOn(startTerritory.x, startTerritory.y);
        }
        
        this.gameState = 'playing';
        
        // Initialize parallax starfield after map is generated
        this.initializeStarfield();
        
        // Pre-render static background for performance optimization
        this.preRenderStaticBackground();
        
        // Start home system flashing for player identification
        this.homeSystemFlashStart = Date.now();
        
        console.log(`Game started with ${this.players.length} players (${this.config.playerName} + ${this.config.aiCount} AI) and ${Object.keys(this.gameMap.territories).length} territories`);
    }
    
    generateAIName(index) {
        const firstNames = [
            'Alex', 'Blake', 'Casey', 'Dana', 'Emma', 'Felix', 'Grace', 'Hunter', 'Iris', 'Jack',
            'Kai', 'Luna', 'Max', 'Nova', 'Owen', 'Piper', 'Quinn', 'Riley', 'Sage', 'Tyler',
            'Uma', 'Victor', 'Wade', 'Xara', 'Yuki', 'Zara', 'Ash', 'Beck', 'Cole', 'Drew',
            'Echo', 'Finn', 'Gale', 'Hope', 'Ivan', 'Jade', 'Kane', 'Lexi', 'Mika', 'Nora',
            'Orion', 'Phoenix', 'Raven', 'Storm', 'Tara', 'Vale', 'Wren', 'Zane', 'Aria', 'Brix',
            'Coda', 'Dex', 'Eden', 'Fox', 'Gray', 'Hawk', 'Juno', 'Kira', 'Lux', 'Moss',
            'Neo', 'Oslo', 'Pike', 'Rain', 'Sky', 'Tex', 'Vex', 'Wolf', 'Zed', 'Atlas',
            'Bear', 'Cruz', 'Dash', 'Enzo', 'Flint', 'Ghost', 'Haze', 'Jett', 'Knox', 'Link'
        ];
        
        const clanNames = [
            'StarForge', 'VoidHunters', 'NebulaRise', 'CosmicFury', 'SolarFlare', 'DarkMatter',
            'GalaxyCorp', 'NovaStrike', 'CelestialWar', 'SpaceRaiders', 'StellarWolves', 'OrbitClan',
            'AstroElite', 'CubClan', 'ZenithForce', 'PlasmaBorn', 'StarDust', 'VoidWalkers',
            'QuantumLeap', 'PhotonStorm', 'EtherGuard', 'CosmoKnights', 'StarVeins', 'NebulaCrest',
            'VortexClan', 'AstralFire', 'MeteoRiders', 'IonStorm', 'PulsarWave', 'GravityWell',
            'SolarWind', 'BlackHole', 'RedGiant', 'WhiteDwarf', 'SuperNova', 'Constellation',
            'MilkyWay', 'Andromeda', 'Centauri', 'Proxima', 'Kepler', 'Hubble', 'Armstrong',
            'Gagarin', 'Apollo', 'Artemis', 'Orion', 'Pegasus', 'Phoenix', 'Dragon', 'Falcon'
        ];
        
        const additionalNames = [
            'Admiral Voss', 'Captain Zara', 'Commander Rex', 'Colonel Stone', 'General Mars',
            'Chief Khan', 'Major Swift', 'Lieutenant Nova', 'Sergeant Blade', 'Marshal Iron',
            'Dr. Quantum', 'Professor Void', 'Scientist Echo', 'Engineer Prime', 'Architect Zero',
            'The Shadow', 'The Phoenix', 'The Storm', 'The Hunter', 'The Ghost',
            'Cyber Wolf', 'Steel Eagle', 'Iron Hawk', 'Gold Tiger', 'Silver Fox',
            'Red Baron', 'Blue Devil', 'Green Arrow', 'Black Knight', 'White Falcon',
            'Star Runner', 'Moon Walker', 'Sun Rider', 'Sky Dancer', 'Wind Chaser',
            'Fire Brand', 'Ice Queen', 'Thunder Lord', 'Lightning Strike', 'Storm Bringer'
        ];
        
        // Only 25% chance of clan name, 75% for varied names
        if (index % 4 === 0) {
            // Clan name format
            const firstName = firstNames[index % firstNames.length];
            const clanName = clanNames[Math.floor(index / firstNames.length) % clanNames.length];
            return `[${clanName}] ${firstName}`;
        } else {
            // Varied name format - mix of first names and additional names
            const namePool = [...firstNames, ...additionalNames];
            return namePool[index % namePool.length];
        }
    }

    createPlayers(numPlayers) {
        // Expanded unique color palette - no duplicates
        const baseColors = [
            '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', 
            '#ff8844', '#88ff44', '#4488ff', '#ff4488', '#88ff88', '#8844ff',
            '#ffaa44', '#aaff44', '#44aaff', '#ff44aa', '#aaff88', '#aa44ff',
            '#ff6644', '#66ff44', '#4466ff', '#ff4466', '#66ff88', '#6644ff',
            '#ff9944', '#99ff44', '#4499ff', '#ff4499', '#99ff88', '#9944ff',
            '#ffcc44', '#ccff44', '#44ccff', '#ff44cc', '#ccff88', '#cc44ff',
            '#ff7744', '#77ff44', '#4477ff', '#ff4477', '#77ff88', '#7744ff',
            '#ffdd44', '#ddff44', '#44ddff', '#ff44dd', '#ddff88', '#dd44ff'
        ];
        
        // Create human player with distinctive bright cyan color
        this.humanPlayer = new Player(0, 'You', '#00ffff', 'human');
        this.players.push(this.humanPlayer);
        this.initializePlayerDiscoveries(this.humanPlayer.id);
        
        // Create AI players with unique colors and human-like names
        const usedColors = new Set(['#00ffff']); // Reserve human color
        
        for (let i = 1; i < numPlayers && i < this.maxPlayers; i++) {
            let playerColor;
            let attempts = 0;
            
            // Find a unique color
            do {
                const colorIndex = (i - 1) % baseColors.length;
                playerColor = baseColors[colorIndex];
                
                // If we've used this color, generate a slight variation
                if (usedColors.has(playerColor)) {
                    const variation = Math.floor(attempts / baseColors.length) * 0.1 + 0.1;
                    playerColor = this.adjustColorBrightness(playerColor, variation);
                }
                attempts++;
            } while (usedColors.has(playerColor) && attempts < 100);
            
            usedColors.add(playerColor);
            
            // Generate human-like name with clan designation
            const aiName = this.generateAIName(i - 1);
            const aiPlayer = new Player(i, aiName, playerColor, 'ai');
            this.players.push(aiPlayer);
            this.initializePlayerDiscoveries(aiPlayer.id);
        }
        
        this.currentPlayers = this.players.length;
    }
    
    initializePlayerDiscoveries(playerId) {
        this.playerDiscoveries.set(playerId, {
            // Empire-wide bonuses (levels stack)
            precursorWeapons: 0,    // +10% attack per level
            precursorDrive: 0,      // +20% probe/ship speed per level
            precursorShield: 0,     // +10% defense per level
            precursorNanotech: 0,   // +10% empire-wide generation per level
            
            // Planet-specific bonuses
            factoryPlanets: new Set() // Planets with 200% generation
        });
    }
    
    adjustColorBrightness(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent * 100);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    distributeStartingTerritories() {
        // Since all territories are now colonizable, manually colonize starting territories
        const allTerritories = Object.values(this.gameMap.territories);
        const usedTerritories = [];
        const minDistance = 200; // Minimum distance between starting territories
        
        console.log(`Available territories for distribution: ${allTerritories.length} (all are colonizable planets)`);
        
        // Give each player exactly one starting territory with spacing
        for (let i = 0; i < this.players.length; i++) {
            const player = this.players[i];
            let bestTerritory = null;
            let bestMinDistance = 0;
            
            // Find territory with maximum distance from all previously assigned territories
            for (const territory of allTerritories) {
                if (usedTerritories.includes(territory.id)) continue;
                
                let minDistanceToUsed = Infinity;
                for (const usedId of usedTerritories) {
                    const usedTerritory = this.gameMap.territories[usedId];
                    const distance = Math.sqrt(
                        (territory.x - usedTerritory.x) ** 2 + 
                        (territory.y - usedTerritory.y) ** 2
                    );
                    minDistanceToUsed = Math.min(minDistanceToUsed, distance);
                }
                
                // If first player or this territory is far enough from others
                if (usedTerritories.length === 0 || minDistanceToUsed > bestMinDistance) {
                    bestTerritory = territory;
                    bestMinDistance = minDistanceToUsed;
                }
            }
            
            if (bestTerritory) {
                // Manually colonize this territory for the player
                bestTerritory.ownerId = player.id;
                bestTerritory.isColonizable = false; // Make it a normal territory
                bestTerritory.armySize = GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE;
                bestTerritory.isThronestar = true; // Mark as throne star
                
                console.log(`🏠 Starting territory ${bestTerritory.id} for ${player.name}: ${GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE} armies`);
                
                // Debug: Track army changes for human player
                if (player.id === 0) { // Human player ID
                    console.log(`👤 HUMAN PLAYER starting territory ${bestTerritory.id} initialized with ${bestTerritory.armySize} armies`);
                }
                
                // Reveal connections for starting territories
                bestTerritory.revealConnections();
                
                player.territories.push(bestTerritory.id);
                player.totalArmies += bestTerritory.armySize;
                player.throneStarId = bestTerritory.id; // Assign throne star ID
                
                usedTerritories.push(bestTerritory.id);
                
                console.log(`👑 Player ${player.name} assigned throne star: Territory ${bestTerritory.id} (distance from others: ${bestMinDistance.toFixed(1)})`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    gameLoop(currentTime = 0) {
        const frameStart = performance.now();
        const deltaTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        // Update FPS counter
        this.updateFPS(currentTime);
        
        if (this.gameState === 'playing') {
            this.update(deltaTime);
        }
        
        this.render();
        
        // Track overall frame performance
        this.performanceStats.frameTime = performance.now() - frameStart;
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    updateFPS(currentTime) {
        this.frameCount++;
        if (currentTime - this.lastFpsUpdate >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
            this.frameCount = 0;
            this.lastFpsUpdate = currentTime;
        }
    }
    
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update game timer
        this.gameTimer -= deltaTime;
        
        if (this.gameTimer <= 0) {
            this.endGame();
            return;
        }
        
        // Optimized AI updates with staggered processing
        const playersPerFrame = Math.max(1, Math.ceil(this.players.length / 4)); // Update 1/4 of players per frame
        const startIndex = (this.frameCount % 4) * playersPerFrame;
        const endIndex = Math.min(startIndex + playersPerFrame, this.players.length);
        
        for (let i = startIndex; i < endIndex; i++) {
            const player = this.players[i];
            if (player && !player.isEliminated) {
                player.update(deltaTime, this.gameMap, this.config.gameSpeed, this);
            }
        }
        
        // Update ship animations and probes with normal delta time (speed applied internally)
        this.updateShipAnimations(deltaTime);
        this.updateProbes(deltaTime);
        this.updateFloatingDiscoveryTexts(deltaTime);
        
        // Update notifications and messages
        this.updateNotifications();
        this.updateMessage(deltaTime);
        
        // Throttled heavy operations for better performance
        if (this.frameCount % 45 === 0) { // Every 45 frames (~0.75 seconds)
            this.validateSupplyRoutes();
        }
        if (this.frameCount % 90 === 0) { // Every 90 frames (~1.5 seconds)
            this.processSupplyRoutes(this.config.gameSpeed);
        }
        
        // Check for player elimination (throttled)
        if (this.frameCount % 20 === 0) {
            this.checkPlayerElimination();
        }
        
        // Check win conditions (throttled)
        if (this.frameCount % 30 === 0) {
            this.checkWinConditions();
        }
        
        // Update camera with edge panning
        this.camera.update(deltaTime);
        
        // Edge panning when mouse is near screen edges (desktop only)
        if (this.mousePos && !this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(this.mousePos.x, this.mousePos.y, deltaTime);
        }
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    checkPlayerElimination() {
        this.players.forEach(player => {
            if (!player.isEliminated && player.territories.length === 0) {
                player.isEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player === this.humanPlayer) {
                    console.log('You have been eliminated! Entering spectator mode.');
                    // TODO: Show elimination message and spectator UI
                }
            }
        });
    }
    
    checkWinConditions() {
        const alivePlayers = this.players.filter(p => !p.isEliminated);
        
        if (alivePlayers.length === 1) {
            this.endGame(alivePlayers[0]);
        } else if (alivePlayers.length === 0) {
            this.endGame(); // Draw
        }
    }
    
    endGame(winner = null) {
        this.gameState = 'ended';
        
        if (winner) {
            console.log(`Game Over! Winner: ${winner.name}`);
        } else {
            console.log('Game Over! It\'s a draw.');
        }
        
        // TODO: Show game over screen with final leaderboard
    }
    
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render parallax starfield behind everything
        this.renderParallaxStarfield();
        
        // Render game world with optimizations
        this.renderNebulas();
        this.renderTerritories();
        this.renderConnections();
        this.renderSupplyRoutes();
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        this.renderShipAnimations();
        this.renderProbes();
        this.renderFloatingDiscoveryTexts();
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    updateVisibleTerritories() {
        // Optimized visibility culling with cached bounds
        if (Date.now() - this.lastVisibilityUpdate < GAME_CONSTANTS.VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS) return;
        this.lastVisibilityUpdate = Date.now();
        
        const bounds = this.camera.getViewBounds();
        const margin = GAME_CONSTANTS.TERRITORY_VISIBILITY_PADDING;
        
        this.visibleTerritories = [];
        const territories = Object.values(this.gameMap.territories);
        
        for (let i = 0; i < territories.length; i++) {
            const territory = territories[i];
            if (territory.x + territory.radius >= bounds.left - margin &&
                territory.x - territory.radius <= bounds.right + margin &&
                territory.y + territory.radius >= bounds.top - margin &&
                territory.y - territory.radius <= bounds.bottom + margin) {
                this.visibleTerritories.push(territory);
            }
        }
        
        this.performanceStats.visibleTerritories = this.visibleTerritories.length;
    }
    
    // Render parallax starfield with multiple depth layers
    renderParallaxStarfield() {
        if (!this.starfield.initialized) return;
        
        const time = Date.now() * 0.001; // For subtle twinkling
        const cameraPosX = this.camera.x;
        const cameraPosY = this.camera.y;
        
        this.ctx.save();
        
        // Far stars (slowest parallax, barely moves)
        this.ctx.globalAlpha = 0.7; // Brighter for better visibility against background
        this.starfield.farStars.forEach(star => {
            // Very subtle parallax movement (5% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.05);
            const parallaxY = star.y - (cameraPosY * 0.05);
            
            // Skip stars outside visible area for performance
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            // Subtle twinkling effect
            const twinkle = star.twinkle + Math.sin(time * 0.5 + star.x * 0.01) * 0.1;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.7;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Mid stars (moderate parallax)
        this.ctx.globalAlpha = 0.8;
        this.starfield.midStars.forEach(star => {
            // Moderate parallax movement (15% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.15);
            const parallaxY = star.y - (cameraPosY * 0.15);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 0.8 + star.x * 0.02) * 0.15;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.8;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Near stars (most parallax movement)
        this.ctx.globalAlpha = 1.0;
        this.starfield.nearStars.forEach(star => {
            // Stronger parallax movement (30% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.3);
            const parallaxY = star.y - (cameraPosY * 0.3);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 1.2 + star.x * 0.03) * 0.2;
            this.ctx.globalAlpha = star.brightness * twinkle * 1.0;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderNebulas() {
        if (!this.gameMap.nebulas) return;
        
        this.ctx.save();
        
        // Render each nebula as a purple cloud
        this.gameMap.nebulas.forEach(nebula => {
            // Create radial gradient for cloud effect
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            
            gradient.addColorStop(0, `rgba(147, 51, 234, ${nebula.opacity})`);
            gradient.addColorStop(0.5, `rgba(147, 51, 234, ${nebula.opacity * 0.6})`);
            gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderTerritories() {
        this.updateVisibleTerritories();
        
        // Get current selected territory from input handler
        const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
        const selectedTerritory = inputState.selectedTerritory;
        
        // Render only visible territories
        this.visibleTerritories.forEach(territory => {
            territory.render(this.ctx, this.players, selectedTerritory, {
                humanPlayer: this.humanPlayer,
                homeSystemFlashStart: this.homeSystemFlashStart,
                homeSystemFlashDuration: this.homeSystemFlashDuration
            }, this.hoveredTerritory);
        });
    }
    
    renderConnections() {
        this.ctx.lineWidth = 4;
        this.ctx.globalAlpha = 0.7;
        
        // Cache connections to avoid duplicate rendering
        const drawnConnections = new Set();
        
        this.visibleTerritories.forEach(territory => {
            territory.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (!neighbor) return;
                
                // Create unique connection ID (smaller ID first)
                const connectionId = territory.id < neighborId 
                    ? `${territory.id}-${neighborId}` 
                    : `${neighborId}-${territory.id}`;
                
                if (drawnConnections.has(connectionId)) return;
                drawnConnections.add(connectionId);
                
                // Skip connections to/from colonizable planets
                if (territory.isColonizable || neighbor.isColonizable) {
                    return;
                }
                
                // Set color based on ownership
                if (territory.ownerId !== null && 
                    neighbor.ownerId !== null && 
                    territory.ownerId === neighbor.ownerId) {
                    const owner = this.players[territory.ownerId];
                    this.ctx.strokeStyle = owner ? owner.color : '#666677';
                } else {
                    this.ctx.strokeStyle = '#666677';
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            });
        });
        
        this.ctx.globalAlpha = 1;
    }
    
    renderSupplyRoutes() {
        // Render active supply routes with animated arrows
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && route.path && route.path.length > 1) {
                this.ctx.save();
                
                // Draw route path with animated dashes - color based on activity
                const routeActive = fromTerritory.armySize > 10; // Route is active if source has armies
                if (routeActive) {
                    this.ctx.strokeStyle = '#00ffff'; // Bright cyan for active routes
                    this.ctx.globalAlpha = 0.9;
                } else {
                    this.ctx.strokeStyle = '#006666'; // Dimmed cyan for inactive routes
                    this.ctx.globalAlpha = 0.5;
                }
                this.ctx.lineWidth = 3;
                
                // Calculate direction-based animation offset
                const fromPos = route.path[0];
                const toPos = route.path[route.path.length - 1];
                const direction = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
                
                // Animate dashes flowing in the direction of ship movement
                const animationOffset = (Date.now() * 0.02) % 20;
                this.ctx.setLineDash([8, 12]);
                this.ctx.lineDashOffset = -animationOffset;
                
                // Draw path segments
                for (let i = 0; i < route.path.length - 1; i++) {
                    const current = route.path[i];
                    const next = route.path[i + 1];
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(current.x, current.y);
                    this.ctx.lineTo(next.x, next.y);
                    this.ctx.stroke();
                }
                
                // Remove arrow graphics - just show the animated path
                
                this.ctx.restore();
            }
        });
    }
    
    getTransferPercentage(event) {
        // Default to 50% transfer
        if (!event) return 0.5;
        
        // Modifier key controls for different transfer amounts
        if (event.shiftKey) return 0.95; // Send almost all (leave 1)
        if (event.ctrlKey) return 0.25;  // Send quarter
        return 0.5; // Default 50%
    }
    
    renderDragPreview() {
        // Show drag preview when creating supply route
        if (this.isDraggingForSupplyRoute && this.dragStart) {
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            this.ctx.save();
            
            // Color-coded preview based on target validity
            if (targetTerritory && targetTerritory.ownerId === this.humanPlayer?.id && 
                targetTerritory.id !== this.dragStart.id) {
                this.ctx.strokeStyle = '#00ff00'; // Green for valid supply route target
                this.ctx.lineWidth = 3;
            } else {
                this.ctx.strokeStyle = '#ffff00'; // Yellow for neutral/unknown target
                this.ctx.lineWidth = 2;
            }
            
            this.ctx.globalAlpha = 0.8;
            this.ctx.setLineDash([5, 5]);
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.dragStart.x, this.dragStart.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }
    }
    
    renderProportionalDragUI() {
        if (!this.isProportionalDrag || !this.proportionalDragStart) return;
        
        this.ctx.save();
        
        const territory = this.proportionalDragStart.territory;
        const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Draw radial percentage indicator around source territory
        const radius = territory.radius + 15;
        const percentage = this.fleetPercentage;
        
        // Background circle
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 8;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Percentage arc
        const startAngle = -Math.PI / 2;
        const endAngle = startAngle + (percentage * Math.PI * 2);
        
        // Color based on percentage
        let color = '#44ff44'; // Green for low
        if (percentage > 0.7) color = '#ff4444'; // Red for high
        else if (percentage > 0.4) color = '#ffaa00'; // Orange for medium
        
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 6;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, startAngle, endAngle);
        this.ctx.stroke();
        
        // Calculate ships to send
        const availableShips = Math.max(0, territory.armySize - 1);
        const shipsToSend = Math.max(1, Math.floor(availableShips * percentage));
        const remaining = territory.armySize - shipsToSend;
        
        // Display text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 2;
        
        // Sending text
        const sendText = `Send: ${shipsToSend}`;
        this.ctx.strokeText(sendText, territory.x, territory.y - 8);
        this.ctx.fillText(sendText, territory.x, territory.y - 8);
        
        // Remaining text
        const remainText = `Keep: ${remaining}`;
        this.ctx.strokeText(remainText, territory.x, territory.y + 8);
        this.ctx.fillText(remainText, territory.x, territory.y + 8);
        
        // Draw drag line to target
        if (targetTerritory) {
            // Color based on action type
            let lineColor = '#666666';
            if (targetTerritory.ownerId === this.humanPlayer?.id) {
                lineColor = '#44ff44'; // Green for transfer
            } else if (targetTerritory.isColonizable) {
                lineColor = '#ffff00'; // Yellow for probe
            } else {
                lineColor = '#ff4444'; // Red for attack
            }
            
            this.ctx.strokeStyle = lineColor;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([8, 4]);
            this.ctx.beginPath();
            this.ctx.moveTo(territory.x, territory.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
        
        this.ctx.restore();
    }
    
    renderTransferPreview() {
        // Show fleet allocation preview when hovering over targets during selection
        if (!this.selectedTerritory || !this.hoveredTerritory || 
            this.selectedTerritory.id === this.hoveredTerritory.id ||
            this.selectedTerritory.ownerId !== this.humanPlayer?.id ||
            this.isProportionalDrag) { // Don't show during proportional drag
            return;
        }
        
        const from = this.selectedTerritory;
        const to = this.hoveredTerritory;
        
        // Only show preview for valid targets (neighbors or colonizable)
        const isValidTarget = from.neighbors.includes(to.id) || to.isColonizable;
        if (!isValidTarget) return;
        
        // Determine transfer percentage based on target type
        let transferPercentage = 0.5; // Default 50%
        if (to.ownerId === this.humanPlayer?.id) {
            transferPercentage = 0.5; // Transfer to own territory
        } else if (to.isColonizable) {
            transferPercentage = Math.min(1.0, 10 / from.armySize); // Probe cost (10 ships or all if less)
        } else {
            transferPercentage = 0.75; // Attack enemy territory
        }
        
        // Calculate amounts
        const availableShips = Math.max(0, from.armySize - 1);
        const shipsToSend = Math.min(availableShips, Math.max(1, Math.floor(from.armySize * transferPercentage)));
        const remaining = from.armySize - shipsToSend;
        
        // Convert to screen coordinates for UI display
        const screenPos = this.camera.worldToScreen(to.x, to.y);
        
        this.ctx.save();
        
        // Background for readability
        const padding = 8;
        const lineHeight = 16;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'left';
        
        const sendText = `Send: ${shipsToSend}`;
        const keepText = `Keep: ${remaining}`;
        const maxWidth = Math.max(this.ctx.measureText(sendText).width, this.ctx.measureText(keepText).width);
        
        const bgX = screenPos.x + 20;
        const bgY = screenPos.y - 25;
        const bgWidth = maxWidth + padding * 2;
        const bgHeight = lineHeight * 2 + padding;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
        
        // Border with action-specific color
        let borderColor = '#ffffff';
        if (to.ownerId === this.humanPlayer?.id) {
            borderColor = '#00ff00'; // Green for transfer
        } else if (to.isColonizable) {
            borderColor = '#ffff00'; // Yellow for probe
        } else {
            borderColor = '#ff4444'; // Red for attack
        }
        
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
        
        // Text
        this.ctx.fillStyle = '#00ff00'; // Green for send
        this.ctx.fillText(sendText, bgX + padding, bgY + lineHeight);
        
        this.ctx.fillStyle = '#ffffff'; // White for keep
        this.ctx.fillText(keepText, bgX + padding, bgY + lineHeight * 2);
        
        this.ctx.restore();
    }
    
    renderFloatingTexts() {
        if (!this.floatingTexts) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        // Update and render floating texts
        const now = Date.now();
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = now - text.startTime;
            if (elapsed >= text.duration) return false;
            
            // Calculate animation progress
            const progress = elapsed / text.duration;
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
            this.ctx.strokeText(text.text, text.x, text.y - yOffset);
            this.ctx.fillText(text.text, text.x, text.y - yOffset);
            
            return true;
        });
        
        this.ctx.restore();
    }
    
    renderArmies() {
        // Dynamic Level of Detail based on camera zoom level
        const zoomLevel = this.camera.getZoomLevel();
        const currentZoom = this.camera.zoom;
        
        this.ctx.save();
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const playersLookup = {}; // Cache player lookups
        
        // Strategic View (zoomed out) - Show simplified information
        if (zoomLevel === 'strategic') {
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner && territory.armySize >= 10) { // Only show significant fleets
                        const armyText = territory.armySize >= 100 ? `${Math.floor(territory.armySize / 10)}0+` : territory.armySize.toString();
                        
                        // Simplified text rendering for performance
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(armyText, territory.x, territory.y + 3);
                    }
                }
            }
        }
        // Operational View (mid zoom) - Show fleet counts as icons
        else if (zoomLevel === 'operational') {
            this.ctx.font = 'bold 13px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // White outline for readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 4);
                        
                        // Color-coded text based on owner
                        this.ctx.fillStyle = owner.id === this.humanPlayer?.id ? '#000000' : '#333333';
                        this.ctx.fillText(armyText, territory.x, territory.y + 4);
                    }
                }
            }
        }
        // Tactical View (zoomed in) - Show full detail
        else {
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // High-contrast text with thick outline
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 5);
                        
                        // Main black text
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(armyText, territory.x, territory.y + 5);
                    }
                }
            }
        }
        
        this.ctx.restore();
    }
    
    render() {
        const startTime = performance.now();
        
        // Clear canvas with dark space background
        this.ctx.fillStyle = '#0a0a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render background galaxy image with parallax
        this.renderBackgroundImage();
        
        // Apply camera transformations for background elements
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render parallax starfield with movement
        this.renderParallaxStarfield();
        
        // Render nebulas with proper depth
        this.renderNebulas();
        
        this.ctx.restore();
        
        // Apply camera transformations
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Update performance tracking
        this.updateVisibleTerritories();
        
        // Render connections between territories
        this.renderConnections();
        
        // Render supply routes
        this.renderSupplyRoutes();
        
        // Render territories with fleet counts
        this.renderTerritories();
        
        // Render probes
        this.renderProbes();
        
        // Render ship animations
        this.renderShipAnimations();
        
        // Proportional drag interface handled by InputHandler
        
        // Selection is handled by Territory render method itself
        
        this.ctx.restore();
        
        // Floating discovery texts disabled - using top-center UI notifications instead
        // this.renderFloatingDiscoveryTexts();
        
        // Render UI overlay
        this.renderUI();
        
        // Update performance stats
        this.performanceStats.renderTime = performance.now() - startTime;
    }
    
    renderFloatingDiscoveryTexts() {
        if (!this.floatingDiscoveryTexts || this.floatingDiscoveryTexts.length === 0) return;
        
        const now = Date.now();
        
        // Filter out expired texts and render remaining ones
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            if (age > text.duration) return false; // Remove expired texts
            
            // Only show human player discoveries
            if (text.playerId !== this.humanPlayer?.id) return false;
            
            // Calculate world position (not affected by camera)
            const worldX = text.x;
            const worldY = text.y - (age / text.duration) * 30; // Float upward over time
            
            // Convert to screen coordinates
            const screenX = (worldX - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
            const screenY = (worldY - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
            
            // Only render if on screen
            if (screenX < -100 || screenX > this.canvas.width + 100 || 
                screenY < -100 || screenY > this.canvas.height + 100) {
                return true; // Keep in array but don't render
            }
            
            // Calculate opacity (fade out in last 1 second)
            let opacity = 1;
            if (age > text.duration - text.fadeOutDuration) {
                const fadeAge = age - (text.duration - text.fadeOutDuration);
                opacity = 1 - (fadeAge / text.fadeOutDuration);
            }
            
            // Set up text rendering
            this.ctx.save();
            this.ctx.globalAlpha = opacity;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // Measure text with correct font
            this.ctx.font = 'bold 14px Arial';
            const textWidth = this.ctx.measureText(text.text).width;
            const padding = 8;
            
            // Draw text background for better visibility
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(screenX - textWidth/2 - padding, screenY - 12, textWidth + padding*2, 24);
            
            // Draw discovery icon
            this.ctx.font = '20px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.icon, screenX - textWidth/2 - 15, screenY);
            
            // Draw discovery text
            this.ctx.font = 'bold 14px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.text, screenX, screenY);
            
            this.ctx.restore();
            
            return true; // Keep in array
        });
    }
    
    renderUI() {
        if (this.ui) {
            const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
            
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: inputState.selectedTerritory,
                hoveredTerritory: this.hoveredTerritory,
                mousePos: this.inputHandler ? this.inputHandler.mousePos : { x: 0, y: 0 },
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                probeCount: this.probes.length,
                notifications: this.notifications,
                playerDiscoveries: this.playerDiscoveries,
                recentProbeResults: this.recentProbeResults,
                discoveryLog: this.discoveryLog,
                showBonusPanel: this.showBonusPanel,
                inputState: inputState,
                messageText: this.messageText,
                messageTimer: this.messageTimer
            });
        }
    }
    
    // Input handling methods
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        
        this.lastMousePos = { ...this.mousePos };
        this.dragStartPos = { ...this.mousePos };
        this.dragStartTime = Date.now();
        this.isDragging = false;
        this.isDraggingForSupplyRoute = false;
        this.isProportionalDrag = false;
        
        // Check if starting drag on an owned territory
        const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const startTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Handle double-click detection for supply routes
        const now = Date.now();
        if (this.lastClickTime && now - this.lastClickTime < 300 && e.button === 0) {
            // Double click detected - try to create supply route
            if (startTerritory) {
                this.handleDoubleClick(startTerritory);
                this.lastClickTime = null; // Reset double-click tracking
                return; // Don't process as regular click
            }
        }
        this.lastClickTime = now;
        
        // Territory selection for left clicks
        if (e.button === 0 && startTerritory) {
            this.selectedTerritory = startTerritory;
            console.log(`Selected territory ${startTerritory.id} (Owner: ${startTerritory.ownerId})`);
        }
        
        if (startTerritory && startTerritory.ownerId === this.humanPlayer?.id) {
            this.dragStart = startTerritory;
            
            // Only setup proportional drag on left click with armies (but don't activate until intentional drag)
            if (e.button === 0 && startTerritory.armySize > 1) {
                // Store potential for proportional drag, but don't activate until significant movement
                this.proportionalDragStart = {
                    territory: startTerritory,
                    screenPos: { ...this.mousePos },
                    worldPos: { x: startTerritory.x, y: startTerritory.y }
                };
            }
        } else {
            this.dragStart = null;
            this.proportionalDragStart = null; // Clear if not on owned territory
        }
        
        if (e.button === 2) { // Right click starts immediate action
            this.isDragging = true;
        }
    }
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const newMousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        
        // Check if we should start dragging (left click held and moved)
        if (this.dragStartPos && !this.isDragging && e.buttons === 1) {
            const dragDistance = Math.sqrt(
                (newMousePos.x - this.dragStartPos.x) ** 2 + 
                (newMousePos.y - this.dragStartPos.y) ** 2
            );
            
            if (dragDistance > 15) { // Increased threshold to prevent accidental activation
                // Only start proportional drag if dragging for more than 300ms (intentional drag)
                const dragTime = Date.now() - this.dragStartTime;
                if (this.proportionalDragStart && dragTime > 300) {
                    this.isProportionalDrag = true;
                    console.log('Started proportional fleet drag');
                } else {
                    // Regular camera drag
                    this.isDragging = true;
                }
            }
        }
        
        // Handle proportional drag for fleet commands
        if (this.isProportionalDrag && this.proportionalDragStart) {
            const dragDistance = Math.sqrt(
                (newMousePos.x - this.proportionalDragStart.screenPos.x) ** 2 + 
                (newMousePos.y - this.proportionalDragStart.screenPos.y) ** 2
            );
            
            // Calculate percentage based on drag distance (0-100 pixels = 0-100%)
            this.fleetPercentage = Math.min(1.0, Math.max(0.1, dragDistance / 100));
        }
        
        // Pan camera if dragging (but not if creating supply route)
        if (this.isDragging && this.mousePos && !this.isDraggingForSupplyRoute) {
            const deltaX = newMousePos.x - this.mousePos.x;
            const deltaY = newMousePos.y - this.mousePos.y;
            
            // Apply camera panning scaled by zoom level
            this.camera.pan(-deltaX / this.camera.zoom, -deltaY / this.camera.zoom);
        }
        
        // Update hover state and cursor mode
        if (!this.isDragging && !this.isDraggingForSupplyRoute) {
            this.updateHoverState(newMousePos);
        }
        
        this.mousePos = newMousePos;
    }
    
    handleMouseUp(e) {
        // Check if this was a quick click (not a drag)
        const clickDuration = Date.now() - (this.dragStartTime || 0);
        const wasQuickClick = clickDuration < 300 && !this.isDragging && !this.isDraggingForSupplyRoute;
        
        const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Handle proportional fleet command
        if (this.isProportionalDrag && this.proportionalDragStart && targetTerritory) {
            this.executeFleetCommand(this.proportionalDragStart.territory, targetTerritory, this.fleetPercentage);
        }
        // Handle supply route creation
        else if (this.isDraggingForSupplyRoute && this.dragStart) {
            if (targetTerritory && targetTerritory.ownerId === this.humanPlayer?.id && targetTerritory.id !== this.dragStart.id) {
                this.createSupplyRoute(this.dragStart, targetTerritory);
            }
        }
        else if (e.button === 0 && (wasQuickClick || !this.isDragging)) {
            // Check UI elements first
            if (this.handleUIClick(this.mousePos.x, this.mousePos.y)) {
                return; // UI handled the click
            }
            
            // Skip game logic if not in playing state
            if (this.gameState !== 'playing') return;
            
            // Left click - use FSM for input handling
            if (this.inputFSM) {
                this.inputFSM.handleInput('leftClick', {
                    territory: targetTerritory,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            }
        }
        else if (e.button === 2 && wasQuickClick) {
            // Right click - use FSM for input handling
            if (this.inputFSM) {
                this.inputFSM.handleInput('rightClick', {
                    territory: targetTerritory,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            }
        }
        
        // Reset drag state
        this.isDragging = false;
        this.isDraggingForSupplyRoute = false;
        this.isProportionalDrag = false;
        this.proportionalDragStart = null;
        this.fleetPercentage = 0.5; // Reset to default
        this.dragStartPos = null;
        this.dragStartTime = null;
        this.dragStart = null;
        this.dragEnd = null;
    }
    
    updateHoverState(mousePos) {
        const worldPos = this.camera.screenToWorld(mousePos.x, mousePos.y);
        const territory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        this.hoveredTerritory = territory;
        
        // Determine cursor mode based on selection and hover target
        if (this.selectedTerritory && this.selectedTerritory.ownerId === this.humanPlayer?.id && territory) {
            if (territory.ownerId === this.humanPlayer?.id && territory.id !== this.selectedTerritory.id) {
                this.cursorMode = 'transfer';
            } else if (territory.ownerId !== this.humanPlayer?.id && territory.ownerId !== null) {
                this.cursorMode = 'attack';
            } else if (territory.isColonizable) {
                this.cursorMode = 'probe';
            } else {
                this.cursorMode = 'default';
            }
        } else {
            this.cursorMode = 'default';
        }
        
        // Update canvas cursor
        this.updateCanvasCursor();
    }
    
    updateCanvasCursor() {
        if (!this.canvas) return;
        
        switch (this.cursorMode) {
            case 'attack':
                this.canvas.style.cursor = 'crosshair';
                break;
            case 'transfer':
                this.canvas.style.cursor = 'move';
                break;
            case 'probe':
                this.canvas.style.cursor = 'help';
                break;
            default:
                this.canvas.style.cursor = 'default';
                break;
        }
    }
    
    // Enhanced context action with modifier key support
    handleContextActionWithModifiers(targetTerritory) {
        if (!this.selectedTerritory || !targetTerritory) return;
        
        // Determine fleet percentage based on modifier keys
        let fleetPercentage = 0.5; // Default 50%
        
        if (this.modifierKeys.shift) {
            fleetPercentage = 1.0; // Send all available (leave 1)
        } else if (this.modifierKeys.ctrl) {
            fleetPercentage = 0.25; // Send 25% - conservative probe
        }
        
        this.executeFleetCommand(this.selectedTerritory, targetTerritory, fleetPercentage);
    }
    
    // Legacy context action for compatibility
    handleContextAction(targetTerritory) {
        if (!this.selectedTerritory || this.selectedTerritory.ownerId !== this.humanPlayer?.id || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        
        // Validate warp lane connectivity (except for colonizable planets)
        if (!targetTerritory.isColonizable && !fromTerritory.neighbors.includes(targetTerritory.id)) {
            console.log(`Cannot perform action: No warp lane from ${fromTerritory.id} to ${targetTerritory.id}`);
            return;
        }
        
        // Determine action based on target
        if (targetTerritory.ownerId === this.humanPlayer?.id && targetTerritory.id !== fromTerritory.id) {
            // Right-click on friendly territory - transfer
            this.transferArmies(fromTerritory, targetTerritory);
        } else if (targetTerritory.ownerId !== this.humanPlayer?.id && targetTerritory.ownerId !== null) {
            // Right-click on enemy territory - attack
            this.attackTerritory(fromTerritory, targetTerritory);
        } else if (targetTerritory.isColonizable) {
            // Right-click on colonizable territory - launch probe
            this.launchProbe(fromTerritory, targetTerritory);
        }
        
        // Visual feedback - flash the target territory
        targetTerritory.lastActionFlash = Date.now();
    }
    
    // Wheel handling moved to InputHandler
    
    handleUIClick(screenX, screenY) {
        // Handle UI element clicks (moved from old handleTerritorySelection)
        
        // Check for "PLAY AGAIN" button when human player is eliminated
        const humanPlayer = this.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            const buttonWidth = 200;
            const buttonHeight = 60;
            const buttonX = this.canvas.width / 2 - buttonWidth / 2;
            const buttonY = this.canvas.height / 2 + 50;
            
            if (screenX >= buttonX && screenX <= buttonX + buttonWidth &&
                screenY >= buttonY && screenY <= buttonY + buttonHeight) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for restart button on game over screen (mobile-friendly)
        if (this.gameState === 'ended' && this.ui && this.ui.restartButton) {
            const button = this.ui.restartButton;
            
            if (screenX >= button.x && screenX <= button.x + button.width &&
                screenY >= button.y && screenY <= button.y + button.height) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for leaderboard click (screen coordinates, not world coordinates)
        const leaderboardX = this.canvas.width - 220;
        const leaderboardY = 60;
        const leaderboardWidth = 200;
        const leaderboardHeight = this.leaderboardMinimized ? 30 : 200;
        
        if (screenX >= leaderboardX && screenX <= leaderboardX + leaderboardWidth &&
            screenY >= leaderboardY && screenY <= leaderboardY + leaderboardHeight) {
            this.leaderboardMinimized = !this.leaderboardMinimized;
            console.log('Leaderboard toggled:', this.leaderboardMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Check for minimap click - fix coordinate calculation
        const minimapSize = 150;
        const minimapX = this.canvas.width - minimapSize - 20;
        const minimapY = this.canvas.height - minimapSize - 20;
        const minimapHeight = this.minimapMinimized ? 30 : minimapSize;
        const minimapClickY = this.minimapMinimized ? (minimapY + minimapSize - 30) : minimapY;
        
        if (screenX >= minimapX && screenX <= minimapX + minimapSize &&
            screenY >= minimapClickY && screenY <= minimapClickY + minimapHeight) {
            this.minimapMinimized = !this.minimapMinimized;
            console.log('Minimap toggled:', this.minimapMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Zoom controls removed - using mousewheel only
        
        return false; // No UI element was clicked
    }
    
    launchProbe(fromTerritory, toTerritory) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            console.log('Not enough fleet power to launch probe! Need 10 fleet power.');
            return;
        }
        
        // Create probe with gameMap and game references for nebula detection and discovery bonuses
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            this.humanPlayer.id,
            this.humanPlayer.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        
        console.log(`Probe launched from territory ${fromTerritory.id} to colonizable planet ${toTerritory.id}`);
    }
    
    launchAIProbe(fromTerritory, toTerritory, player) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            return;
        }
        
        // Create AI probe with gameMap and game references for nebula detection
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            player.id,
            player.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        
        console.log(`AI ${player.name} launched probe from territory ${fromTerritory.id} to colonizable planet ${toTerritory.id}`);
    }
    
    transferFleet(fromTerritory, toTerritory) {
        if (fromTerritory.armySize <= 1) {
            console.log('Not enough armies to transfer!');
            return;
        }
        
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Transfer half the armies, leaving at least 1
        const transferAmount = Math.floor(fromTerritory.armySize / 2);
        fromTerritory.armySize -= transferAmount;
        toTerritory.armySize += transferAmount;
        
        console.log(`Transferred ${transferAmount} armies from territory ${fromTerritory.id} to ${toTerritory.id}`);
    }
    
    // Enhanced fleet transfer with specific amount
    transferFleetWithAmount(fromTerritory, toTerritory, amount) {
        if (fromTerritory.armySize <= 1) {
            console.log('Not enough armies to transfer!');
            return;
        }
        
        // Ensure we don't transfer more than available (minus 1 to keep)
        const maxTransfer = fromTerritory.armySize - 1;
        const actualTransfer = Math.min(amount, maxTransfer);
        
        if (actualTransfer <= 0) {
            console.log('No armies available to transfer!');
            return;
        }
        
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Execute transfer
        fromTerritory.armySize -= actualTransfer;
        toTerritory.armySize += actualTransfer;
        
        console.log(`Transferred ${actualTransfer} armies from territory ${fromTerritory.id} to ${toTerritory.id}`);
    }
    
    // Supply route system
    createSupplyRoute(fromTerritory, toTerritory) {
        // Find path between territories through owned network
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        
        if (path && path.length > 1) {
            const delayPerHop = 2000; // 2 seconds per intervening planet
            const totalDelay = (path.length - 2) * delayPerHop; // Don't count start and end
            
            this.supplyRoutes.set(fromTerritory.id, {
                targetId: toTerritory.id,
                path: path,
                delay: totalDelay,
                lastValidation: Date.now()
            });
            
            console.log(`Supply route created: ${fromTerritory.id} → ${toTerritory.id} (${path.length - 1} hops, ${totalDelay}ms delay)`);
            console.log('Path:', path.map(t => t.id).join(' → '));
        } else {
            console.log('No valid path found between territories');
        }
    }
    
    findPathBetweenTerritories(start, end) {
        // BFS to find shortest path through owned territories
        const queue = [[start]];
        const visited = new Set([start.id]);
        
        while (queue.length > 0) {
            const path = queue.shift();
            const current = path[path.length - 1];
            
            if (current.id === end.id) {
                return path;
            }
            
            // Check all neighbors
            current.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                
                if (neighbor && 
                    !visited.has(neighbor.id) && 
                    neighbor.ownerId === this.humanPlayer?.id) {
                    
                    visited.add(neighbor.id);
                    queue.push([...path, neighbor]);
                }
            });
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Check all supply routes for broken connections
        const routesToRemove = [];
        
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            // Check if territories still exist and are owned by player
            if (!fromTerritory || !toTerritory || 
                fromTerritory.ownerId !== this.humanPlayer?.id || 
                toTerritory.ownerId !== this.humanPlayer?.id) {
                routesToRemove.push(fromId);
                return;
            }
            
            // Revalidate path every few seconds
            const now = Date.now();
            if (now - route.lastValidation > 5000) {
                const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
                
                if (!newPath) {
                    routesToRemove.push(fromId);
                    console.log(`Supply route broken: ${fromId} → ${route.targetId}`);
                } else {
                    // Update path and delay if it changed
                    const delayPerHop = 2000;
                    const newDelay = (newPath.length - 2) * delayPerHop;
                    
                    route.path = newPath;
                    route.delay = newDelay;
                    route.lastValidation = now;
                }
            }
        });
        
        // Remove broken routes
        routesToRemove.forEach(id => {
            this.supplyRoutes.delete(id);
        });
    }
    
    processSupplyRoutes() {
        // Handle automatic ship sending along supply routes
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && fromTerritory.armySize > 2) {
                // Send new ships when they're generated (but not too frequently)
                const now = Date.now();
                if (!route.lastShipment || now - route.lastShipment > 3000) {
                    const shipsToSend = Math.floor(fromTerritory.armySize / 3); // Send 1/3 of armies
                    
                    if (shipsToSend > 0) {
                        fromTerritory.armySize -= shipsToSend;
                        route.lastShipment = now;
                        
                        // Create delayed transfer with route visualization
                        this.createDelayedSupplyTransfer(fromTerritory, toTerritory, shipsToSend, route.delay);
                    }
                }
            }
        });
    }
    
    createDelayedSupplyTransfer(fromTerritory, toTerritory, shipCount, delay) {
        // Find the supply route to get the path
        const route = this.supplyRoutes.get(fromTerritory.id);
        if (route && route.path && route.path.length > 1) {
            // Create multi-hop ship animation following the path
            this.createSupplyRouteAnimation(route.path, this.humanPlayer.color);
        } else {
            // Fallback to direct animation
            this.createShipAnimation(fromTerritory, toTerritory, false);
        }
        
        // Apply transfer after delay
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipCount;
                console.log(`Supply route delivered ${shipCount} ships to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    findTerritoryAt(x, y) {
        for (const territory of Object.values(this.gameMap.territories)) {
            const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
            if (distance <= territory.radius) {
                return territory;
            }
        }
        return null;
    }
    
    // Core fleet command execution with percentage control
    executeFleetCommand(fromTerritory, toTerritory, fleetPercentage) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Validate warp lane connectivity (except for colonizable planets which can be probed)
        if (!toTerritory.isColonizable && !fromTerritory.neighbors.includes(toTerritory.id)) {
            console.log(`Cannot send fleet: No warp lane from ${fromTerritory.id} to ${toTerritory.id}`);
            return;
        }
        
        // Calculate ships to send based on percentage
        const availableShips = Math.max(0, fromTerritory.armySize - 1); // Always leave at least 1
        const shipsToSend = Math.max(1, Math.floor(availableShips * fleetPercentage));
        
        // Visual feedback - show number flying off
        this.showFleetCommandFeedback(fromTerritory, shipsToSend, fleetPercentage);
        
        if (toTerritory.ownerId === this.humanPlayer?.id) {
            // Transfer to own territory with specific amount
            this.transferFleetWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Fleet transfer: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        } else if (toTerritory.isColonizable) {
            // Probe colonizable territory
            this.launchProbe(fromTerritory, toTerritory);
            console.log(`Probe launched from ${fromTerritory.id} to colonizable ${toTerritory.id}`);
        } else {
            // Attack enemy territory with specific amount
            this.attackTerritoryWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Attack: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        }
    }
    
    // Visual feedback for fleet commands
    showFleetCommandFeedback(territory, shipsToSend, percentage) {
        // Flash the territory briefly
        territory.lastCombatFlash = Date.now();
        
        // Show floating text with ship count
        const floatingText = {
            x: territory.x + (Math.random() - 0.5) * 40,
            y: territory.y - 20,
            text: `-${shipsToSend}`,
            color: percentage >= 0.8 ? '#ff4444' : percentage >= 0.5 ? '#ffaa00' : '#44ff44',
            startTime: Date.now(),
            duration: 1500
        };
        
        if (!this.floatingTexts) this.floatingTexts = [];
        this.floatingTexts.push(floatingText);
    }
    
    attackTerritory(attackingTerritory, defendingTerritory) {
        if (attackingTerritory.armySize <= 1) {
            console.log('Not enough armies to attack!');
            return;
        }
        
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        // Use 75% of armies for attack
        const attackingArmies = Math.floor(attackingTerritory.armySize * 0.75);
        const defendingArmies = defendingTerritory.armySize;
        
        console.log(`Attack: ${attackingArmies} vs ${defendingArmies}`);
        
        // Battle calculation with discovery bonuses
        let attackMultiplier = 0.8 + Math.random() * 0.4; // Base random factor
        let defenseMultiplier = 1.0 + Math.random() * 0.2; // Base defender advantage
        
        // Apply Precursor Weapons bonus to attacker (human player only)
        if (attackingTerritory.ownerId === this.humanPlayer?.id && this.discoveries.precursorWeapons > 0) {
            attackMultiplier *= (1 + this.discoveries.precursorWeapons * 0.1);
            console.log(`⚔️ Precursor Weapons bonus applied! Attack power increased by ${this.discoveries.precursorWeapons * 10}%`);
        }
        
        // Apply Precursor Shield bonus to defender (human player only)
        if (defendingTerritory.ownerId === this.humanPlayer?.id && this.discoveries.precursorShield > 0) {
            defenseMultiplier *= (1 + this.discoveries.precursorShield * 0.1);
            console.log(`🛡️ Precursor Shield bonus applied! Defense power increased by ${this.discoveries.precursorShield * 10}%`);
        }
        
        const attackPower = attackingArmies * attackMultiplier;
        const defensePower = defendingArmies * defenseMultiplier;
        
        if (attackPower > defensePower) {
            // Attack successful
            const oldOwnerId = defendingTerritory.ownerId;
            const survivingArmies = Math.max(1, attackingArmies - defendingArmies);
            
            // Check if this is a throne star capture
            if (defendingTerritory.isThronestar && oldOwnerId !== null) {
                const oldOwner = this.players[oldOwnerId];
                if (oldOwner) {
                    // THRONE STAR CAPTURED! Transfer ALL remaining territories
                    console.log(`THRONE STAR CAPTURED! ${oldOwner.name}'s empire falls to ${this.humanPlayer.name}!`);
                    
                    // Transfer all territories from old owner to attacker
                    const territoriesToTransfer = [...oldOwner.territories];
                    territoriesToTransfer.forEach(territoryId => {
                        const territory = this.gameMap.territories[territoryId];
                        if (territory && territory.ownerId === oldOwnerId) {
                            territory.ownerId = this.humanPlayer.id;
                            this.humanPlayer.territories.push(territoryId);
                        }
                    });
                    
                    // Clear old owner's territories
                    oldOwner.territories = [];
                    oldOwner.isEliminated = true;
                }
                
                // Destroy the captured throne star (no empire should have multiple thrones)
                defendingTerritory.isThronestar = false;
                defendingTerritory.ownerId = this.humanPlayer.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= attackingArmies;
                
                console.log(`👑 Throne star destroyed after capture - no duplicate thrones allowed`);
            } else {
                // Normal territory capture
                defendingTerritory.ownerId = this.humanPlayer.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= attackingArmies;
                
                // Update player territories
                this.humanPlayer.territories.push(defendingTerritory.id);
                
                if (oldOwnerId !== null) {
                    const oldOwner = this.players[oldOwnerId];
                    if (oldOwner) {
                        const index = oldOwner.territories.indexOf(defendingTerritory.id);
                        if (index > -1) {
                            oldOwner.territories.splice(index, 1);
                        }
                    }
                }
            }
            
            console.log('Territory captured!');
        } else {
            // Attack failed
            const survivingDefenders = Math.max(1, defendingArmies - Math.floor(attackingArmies * 0.7));
            const survivingAttackers = Math.max(1, Math.floor(attackingArmies * 0.3));
            
            defendingTerritory.armySize = survivingDefenders;
            attackingTerritory.armySize = attackingTerritory.armySize - attackingArmies + survivingAttackers;
            
            console.log('Attack failed!');
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Enhanced attack method with custom army amount
    attackTerritoryWithAmount(attackingTerritory, defendingTerritory, attackingArmies) {
        if (attackingTerritory.armySize <= 1) {
            console.log('Not enough armies to attack!');
            return;
        }
        
        // Ensure we don't use more armies than available (minus 1 to keep)
        const maxAttack = attackingTerritory.armySize - 1;
        const actualAttack = Math.min(attackingArmies, maxAttack);
        
        if (actualAttack <= 0) {
            console.log('No armies available to attack!');
            return;
        }
        
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        const defendingArmies = defendingTerritory.armySize;
        
        console.log(`Custom Attack: ${actualAttack} vs ${defendingArmies}`);
        
        // Battle calculation with discovery bonuses
        let attackMultiplier = 0.8 + Math.random() * 0.4; // Base random factor
        let defenseMultiplier = 1.0 + Math.random() * 0.2; // Base defender advantage
        
        // Apply Precursor Weapons bonus to attacker (human player only)
        if (attackingTerritory.ownerId === this.humanPlayer?.id && this.discoveries.precursorWeapons > 0) {
            attackMultiplier *= (1 + this.discoveries.precursorWeapons * 0.1);
        }
        
        // Apply Precursor Shield bonus to defender (human player only)
        if (defendingTerritory.ownerId === this.humanPlayer?.id && this.discoveries.precursorShield > 0) {
            defenseMultiplier *= (1 + this.discoveries.precursorShield * 0.1);
        }
        
        const attackPower = actualAttack * attackMultiplier;
        const defensePower = defendingArmies * defenseMultiplier;
        
        if (attackPower > defensePower) {
            // Attack successful
            const oldOwnerId = defendingTerritory.ownerId;
            const survivingArmies = Math.max(1, actualAttack - defendingArmies);
            
            // Check if this is a throne star capture
            if (defendingTerritory.isThronestar && oldOwnerId !== null) {
                const oldOwner = this.players[oldOwnerId];
                if (oldOwner) {
                    console.log(`THRONE STAR CAPTURED! ${oldOwner.name}'s empire falls!`);
                    
                    // Transfer all territories from old owner to attacker
                    const territoriesToTransfer = [...oldOwner.territories];
                    territoriesToTransfer.forEach(territoryId => {
                        const territory = this.gameMap.territories[territoryId];
                        if (territory && territory.ownerId === oldOwnerId) {
                            territory.ownerId = this.humanPlayer.id;
                            this.humanPlayer.territories.push(territoryId);
                        }
                    });
                    
                    // Clear old owner's territories
                    oldOwner.territories = [];
                    oldOwner.isEliminated = true;
                }
                
                // Destroy the captured throne star
                defendingTerritory.isThronestar = false;
                defendingTerritory.ownerId = this.humanPlayer.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= actualAttack;
                
                console.log(`👑 Throne star destroyed after capture`);
            } else {
                // Normal territory capture
                defendingTerritory.ownerId = this.humanPlayer.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= actualAttack;
                
                // Update player territories
                this.humanPlayer.territories.push(defendingTerritory.id);
                
                if (oldOwnerId !== null) {
                    const oldOwner = this.players[oldOwnerId];
                    if (oldOwner) {
                        const index = oldOwner.territories.indexOf(defendingTerritory.id);
                        if (index > -1) {
                            oldOwner.territories.splice(index, 1);
                        }
                    }
                }
            }
            
            console.log('Territory captured with custom attack!');
        } else {
            // Attack failed
            const survivingDefenders = Math.max(1, defendingArmies - Math.floor(actualAttack * 0.7));
            const survivingAttackers = Math.max(1, Math.floor(actualAttack * 0.3));
            
            defendingTerritory.armySize = survivingDefenders;
            attackingTerritory.armySize = attackingTerritory.armySize - actualAttack + survivingAttackers;
            
            console.log('Custom attack failed!');
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Touch event handlers for mobile
    handleTouchStart(e) {
        e.preventDefault();
        
        this.touchStartTime = Date.now();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchStart: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch - prepare for selection or pan
            const touch = e.touches[0];
            this.mousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            this.lastMousePos = { ...this.mousePos };
            this.isDragging = false;
            this.isMultiTouch = false;
            
            // Setup long press detection
            this.longPressStartPos = { ...this.mousePos };
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            this.longPressTarget = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            // Clear any existing long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
            }
            
            // Start long press timer
            this.longPressTimer = setTimeout(() => {
                this.handleLongPress();
            }, this.longPressThreshold);
            
            this.touchDebugInfo += `\nSingle: ${Math.round(this.mousePos.x)}, ${Math.round(this.mousePos.y)}`;
            
        } else if (e.touches.length === 2) {
            // Two touches - enhanced pinch zoom and pan
            this.isMultiTouch = true;
            this.isDragging = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Store initial touch positions for pan/zoom
            this.touchStartDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            this.pinchCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            this.lastMousePos = { ...this.pinchCenter };
            this.initialZoom = this.camera.zoom; // Store initial zoom for relative scaling
            this.lastPinchDistance = this.touchStartDistance; // Track for smooth updates
            
            this.touchDebugInfo += `\nPinch Start: dist ${Math.round(this.touchStartDistance)} zoom ${(this.initialZoom * 100).toFixed(0)}%`;
        }
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchMove: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch drag - pan
            const touch = e.touches[0];
            const currentPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            this.touchDebugInfo += `\nSingle: ${Math.round(currentPos.x)}, ${Math.round(currentPos.y)}`;
            
            if (this.lastMousePos) {
                const deltaX = currentPos.x - this.lastMousePos.x;
                const deltaY = currentPos.y - this.lastMousePos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Start dragging if moved more than 10 pixels
                if (!this.isDragging && distance > 10) {
                    this.isDragging = true;
                    this.touchDebugInfo += `\nStarted Pan`;
                    
                    // Cancel long press if we start dragging
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                }
                
                if (this.isDragging && !this.isMultiTouch) {
                    this.camera.pan(-deltaX, -deltaY);
                    this.touchDebugInfo += `\nPan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentPos;
            
        } else if (e.touches.length === 2) {
            // Two touches - pinch zoom and pan
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Calculate current distance for zoom
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            // Enhanced pinch-to-zoom with much higher sensitivity
            if (this.lastPinchDistance && Math.abs(currentDistance - this.lastPinchDistance) > 2) {
                // Use incremental scaling with higher sensitivity
                const distanceRatio = currentDistance / this.lastPinchDistance;
                
                // Apply incremental zoom change with dramatic sensitivity
                const zoomMultiplier = 1 + (distanceRatio - 1) * 1.5; // Dramatic scaling for responsive zoom
                const newZoom = Math.max(0.5, Math.min(3.0, this.camera.zoom * zoomMultiplier));
                
                // Calculate zoom center between the two fingers
                const centerX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                const centerY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
                
                // Apply zoom smoothly to the pinch center
                this.camera.zoomTo(newZoom, centerX, centerY);
                this.lastPinchDistance = currentDistance;
                this.lastZoomTime = Date.now();
                
                this.touchDebugInfo += `\nPinch Zoom: ${(newZoom * 100).toFixed(0)}% (dist: ${Math.round(currentDistance)})`;
            }
            
            // Enhanced two-finger pan with smoother movement
            const currentCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            if (this.lastMousePos && Date.now() - this.lastZoomTime > 50) {
                const deltaX = currentCenter.x - this.lastMousePos.x;
                const deltaY = currentCenter.y - this.lastMousePos.y;
                
                // Smoother pan threshold for better control
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    this.camera.pan(-deltaX * 0.8, -deltaY * 0.8); // Damped panning
                    this.touchDebugInfo += `\nTwo-finger pan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentCenter;
        }
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        const touchDuration = Date.now() - this.touchStartTime;
        console.log('Touch end:', e.touches.length, 'remaining touches, duration:', touchDuration);
        
        if (e.touches.length === 0) {
            // All fingers lifted
            if (!this.isDragging && touchDuration < 500 && this.mousePos) {
                // Quick tap - handle territory selection
                const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
                this.handleTerritorySelection(worldPos);
                console.log('Territory selection at:', worldPos);
            }
            
            this.isDragging = false;
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            this.lastPinchDistance = null;
            this.lastMousePos = null;
            this.pinchCenter = null;
            this.lastZoomTime = 0;
            this.initialZoom = 1.0;
            
            // Cancel long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            
        } else if (e.touches.length === 1) {
            // One finger lifted during multi-touch - continue with single touch
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            this.lastMousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }
    }
    
    // Keyboard handling is now done by InputHandler module
    
    handleDoubleClick(targetTerritory) {
        // Double-click detected - create supply route between owned territories
        if (!this.selectedTerritory || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        const toTerritory = targetTerritory;
        
        // Both territories must be owned by human player
        if (fromTerritory.ownerId !== this.humanPlayer?.id || toTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Must be different territories
        if (fromTerritory.id === toTerritory.id) {
            return;
        }
        
        // Check if connected by owned territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (path && path.length > 0) {
            this.createSupplyRoute(fromTerritory, toTerritory);
            console.log(`Double-click: Supply route created from ${fromTerritory.id} to ${toTerritory.id}`);
        } else {
            console.log('Double-click: Territories not connected by owned star lanes for supply route');
        }
    }
    
    restartGame() {
        // Reset game state
        this.gameState = 'lobby';
        this.gameTimer = 10 * 60 * 1000;
        this.selectedTerritory = null;
        
        // Clear players
        this.players = [];
        this.humanPlayer = null;
        
        // Regenerate map and restart
        this.gameMap = new GameMap(2000, 1500);
        this.startGame();
    }
}


================================================================================
FILE: client/src/game/GameMap.js (1,032 lines)  
================================================================================
import { Territory } from './Territory.js';

export class GameMap {
    constructor(width, height, config = {}) {
        this.width = width * 1.4; // Expand width by 40%
        this.height = height * 1.4; // Expand height by 40%
        this.territories = {};
        this.nebulas = []; // Purple nebula clouds
        this.gridSize = 150; // Increased space between territory centers for less crowding
        
        // Advanced configuration options
        this.layout = config.layout || 'organic'; // Layout type: organic, clusters, spiral, core, ring, binary
        this.connectionDistance = config.connectionRange || 80; // Max distance for territory connections - prevent long-distance warp lanes
        this.warpLaneDensity = config.warpLaneDensity || 80; // Percentage density for connections
        this.nebulaCount = config.nebulaCount !== undefined ? config.nebulaCount : 10; // Number of nebula fields
        this.nebulaSlowdown = config.nebulaSlowdown !== undefined ? config.nebulaSlowdown : true;
        this.supplyRoutes = config.supplyRoutes !== undefined ? config.supplyRoutes : true;
        this.probeColonization = config.probeColonization !== undefined ? config.probeColonization : true;
    }
    
    // Helper function to check if a point is within organic galaxy boundaries
    isWithinGalaxyBounds(x, y) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Calculate normalized position (0 to 1 from center)
        const normalizedX = (x - centerX) / (this.width / 2);
        const normalizedY = (y - centerY) / (this.height / 2);
        
        // Create organic galaxy shape using multiple sine waves for irregular edges
        const baseRadius = 0.85; // Base galaxy size (85% of max)
        
        // Use angle from center for perlin-like noise effect
        const angle = Math.atan2(normalizedY, normalizedX);
        
        // Create multiple frequency sine waves for organic edge variation
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        // Calculate distance from center
        const distanceFromCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        
        // Organic boundary with variation
        const maxDistance = baseRadius + edgeVariation;
        
        return distanceFromCenter <= maxDistance;
    }

    // Helper function to get max radius at a specific angle for organic boundary
    getMaxRadiusAtAngle(angle) {
        const baseRadius = 0.85; // Base galaxy size (85% of max)
        
        // Create organic edge variation using the same formula as boundary check
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        return baseRadius + edgeVariation;
    }

    // Helper function to check if a point is too close to existing points
    isValidPosition(x, y, existingPoints, minDistance = this.gridSize) {
        // First check if within organic galaxy boundaries
        if (!this.isWithinGalaxyBounds(x, y)) return false;
        
        // Then check minimum distance from other territories
        for (const point of existingPoints) {
            const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
            if (dist < minDistance) return false;
        }
        return true;
    }

    generateTerritories(count) {
        console.log(`Generating ${count} territories using ${this.layout} layout on ${this.width}x${this.height} map...`);
        
        // Generate territories based on selected layout
        let territories;
        switch (this.layout) {
            case 'clusters':
                territories = this.generateClusterLayout(count);
                break;
            case 'spiral':
                territories = this.generateSpiralLayout(count);
                break;
            case 'core':
                territories = this.generateCoreLayout(count);
                break;
            case 'ring':
                territories = this.generateRingLayout(count);
                break;
            case 'binary':
                territories = this.generateBinaryLayout(count);
                break;
            case 'organic':
            default:
                territories = this.poissonDiskSampling(count);
                break;
        }
        
        // Create Territory objects - ALL are now colonizable requiring probes
        territories.forEach((pos, index) => {
            // ALL territories are now colonizable
            const territory = new Territory(index, pos.x, pos.y, 25, true);
            
            // Hidden army count from 1 to 50, only revealed when probed
            territory.hiddenArmySize = Math.floor(Math.random() * 50) + 1;
            territory.armySize = 0; // Unknown until colonized
            
            this.territories[index] = territory;
        });
        
        // Generate nebulas after territories
        this.generateNebulas();
        
        // Connect territories based on layout
        this.connectTerritoriesForLayout();
        
        // All territories are now colonizable
        console.log(`Generated ${Object.keys(this.territories).length} territories with ${this.layout} layout`);
        console.log(`Generated ${this.nebulas.length} nebula clouds`);
        console.log(`All territories are colonizable planets requiring probes`);
        
        // Ensure connectivity by connecting isolated territories
        this.ensureConnectivity();
    }
    
    generateNebulas() {
        // Use configurable nebula count (0-20)
        const nebulaCount = this.nebulaCount;
        
        for (let i = 0; i < nebulaCount; i++) {
            let attempts = 0;
            let x, y;
            
            // Find positions within organic galaxy boundaries
            do {
                x = Math.random() * this.width;
                y = Math.random() * this.height;
                attempts++;
            } while (!this.isWithinGalaxyBounds(x, y) && attempts < 50);
            
            // If we couldn't find a valid position after many attempts, skip this nebula
            if (attempts >= 50) continue;
            
            const nebula = {
                x: x,
                y: y,
                radius: 80 + Math.random() * 120, // Size varies from 80 to 200
                opacity: 0.3 + Math.random() * 0.4, // Opacity varies from 0.3 to 0.7
                color: `rgba(147, 51, 234, ${0.3 + Math.random() * 0.4})` // Purple with varying opacity
            };
            this.nebulas.push(nebula);
        }
        
        console.log(`Generated ${nebulaCount} nebula fields (configured: ${this.nebulaCount})`);
    }
    
    poissonDiskSampling(numSamples) {
        const points = [];
        const attempts = numSamples * 150; // Increased attempts for natural clustering
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Create density clusters for realistic galaxy structure
        const clusters = this.generateDensityClusters();
        
        // Helper function to get density multiplier at a given position
        const getDensityAt = (x, y) => {
            let density = 0.1; // Base density everywhere
            
            // Add cluster influences
            clusters.forEach(cluster => {
                const dist = Math.sqrt((x - cluster.x) ** 2 + (y - cluster.y) ** 2);
                const influence = Math.exp(-dist / cluster.radius) * cluster.strength;
                density += influence;
            });
            
            // Add galactic bar density (central dense region)
            const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            const maxRadius = Math.min(this.width, this.height) * 0.4;
            if (distFromCenter < maxRadius * 0.3) {
                density += 0.8 * (1 - distFromCenter / (maxRadius * 0.3));
            }
            
            return Math.min(density, 1.0); // Cap at 1.0
        };
        
        // Helper function to check if a point is valid with adaptive spacing
        const isValidPoint = (x, y) => {
            if (!this.isWithinGalaxyBounds(x, y)) return false;
            
            const localDensity = getDensityAt(x, y);
            const adaptiveGridSize = this.gridSize * (1.2 - localDensity * 0.7); // Closer in dense areas
            
            for (const point of points) {
                const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (dist < adaptiveGridSize) return false;
            }
            return true;
        };
        
        // Strategy 1: Density-based placement using rejection sampling
        let attemptCount = 0;
        while (points.length < numSamples && attemptCount < attempts) {
            // Generate candidate position
            const angle = Math.random() * 2 * Math.PI;
            const maxRadiusAtAngle = this.getMaxRadiusAtAngle(angle);
            const radius = Math.random() * maxRadiusAtAngle * (this.width / 2) * 0.9;
            
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            
            // Accept point based on local density
            const density = getDensityAt(x, y);
            const acceptanceProbability = density;
            
            if (Math.random() < acceptanceProbability && isValidPoint(x, y)) {
                points.push({ x, y });
            }
            attemptCount++;
        }
        
        console.log(`Generated ${points.length} territories out of ${numSamples} requested using density-based clustering`);
        console.log(`Created ${clusters.length} density clusters for natural star formation`);
        return points;
    }
    
    generateDensityClusters() {
        const clusters = [];
        const numClusters = 8 + Math.floor(Math.random() * 8); // 8-15 clusters
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        for (let i = 0; i < numClusters; i++) {
            // Place clusters in spiral arms and random locations
            const clusterAngle = Math.random() * 2 * Math.PI;
            const clusterRadius = (Math.random() * 0.6 + 0.2) * Math.min(this.width, this.height) * 0.35;
            
            const cluster = {
                x: centerX + clusterRadius * Math.cos(clusterAngle),
                y: centerY + clusterRadius * Math.sin(clusterAngle),
                radius: 80 + Math.random() * 120, // Cluster influence radius
                strength: 0.3 + Math.random() * 0.5 // Density strength
            };
            
            clusters.push(cluster);
        }
        
        return clusters;
    }
    
    generateClusterLayout(count) {
        const points = [];
        const clusterCount = Math.max(3, Math.floor(count / 15)); // Create 3-8 clusters
        const pointsPerCluster = Math.floor(count / clusterCount);
        
        for (let cluster = 0; cluster < clusterCount; cluster++) {
            // Random cluster center
            const centerX = 100 + Math.random() * (this.width - 200);
            const centerY = 100 + Math.random() * (this.height - 200);
            const clusterRadius = 80 + Math.random() * 120; // Varying cluster sizes
            
            let clusterPoints = cluster === clusterCount - 1 ? 
                count - points.length : pointsPerCluster; // Last cluster gets remaining points
            
            for (let i = 0; i < clusterPoints; i++) {
                let attempts = 0;
                let validPoint = false;
                
                while (!validPoint && attempts < 50) {
                    // Use normal distribution for more natural clustering
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = Math.random() * clusterRadius;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    // Check if point is valid and not too close to existing points
                    if (x > 30 && x < this.width - 30 && y > 30 && y < this.height - 30) {
                        let tooClose = false;
                        for (const existing of points) {
                            const dist = Math.sqrt((x - existing.x) ** 2 + (y - existing.y) ** 2);
                            if (dist < this.gridSize) { // Use consistent spacing
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) {
                            points.push({ x, y });
                            validPoint = true;
                        }
                    }
                    attempts++;
                }
            }
        }
        
        return points;
    }
    
    generateSpiralLayout(count) {
        const points = [];
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const arms = 3 + Math.floor(Math.random() * 3); // 3-5 spiral arms
        const maxRadius = Math.min(this.width, this.height) * 0.4;
        
        for (let i = 0; i < count; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const armIndex = i % arms;
                const armProgress = Math.floor(i / arms) / Math.floor(count / arms);
                
                // Spiral equation with some randomness
                const baseAngle = (armIndex * 2 * Math.PI / arms) + (armProgress * 4 * Math.PI);
                const angle = baseAngle + (Math.random() - 0.5) * 0.8; // Add jitter
                const radius = armProgress * maxRadius + Math.random() * 30;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Ensure points stay within bounds
                const clampedX = Math.max(30, Math.min(this.width - 30, x));
                const clampedY = Math.max(30, Math.min(this.height - 30, y));
                
                // Check collision with existing points
                let tooClose = false;
                for (const existing of points) {
                    const dist = Math.sqrt((clampedX - existing.x) ** 2 + (clampedY - existing.y) ** 2);
                    if (dist < this.gridSize) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push({ x: clampedX, y: clampedY });
                    validPoint = true;
                }
                
                attempts++;
            }
            
            // Fallback: if couldn't place in spiral, use random position
            if (!validPoint) {
                console.warn(`Spiral layout: couldn't place point ${i}, using fallback`);
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    let tooClose = false;
                    for (const existing of points) {
                        const dist = Math.sqrt((x - existing.x) ** 2 + (y - existing.y) ** 2);
                        if (dist < this.gridSize) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        return points;
    }
    
    generateCoreLayout(count) {
        const points = [];
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const coreRadius = 80;
        const shellThickness = 100;
        
        // Dense core (20% of planets)
        const coreCount = Math.floor(count * 0.2);
        for (let i = 0; i < coreCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * coreRadius;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
        }
        
        // Concentric shells (80% of planets)
        const shellCount = count - coreCount;
        const shells = 3;
        const planetsPerShell = Math.floor(shellCount / shells);
        
        for (let shell = 0; shell < shells; shell++) {
            const shellRadius = coreRadius + (shell + 1) * shellThickness;
            const shellPlanets = shell === shells - 1 ? 
                shellCount - (planetsPerShell * shell) : planetsPerShell;
            
            for (let i = 0; i < shellPlanets; i++) {
                let attempts = 0;
                let validPoint = false;
                
                while (!validPoint && attempts < 100) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = shellRadius + (Math.random() - 0.5) * shellThickness * 0.5;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        validPoint = true;
                    }
                    attempts++;
                }
                
                // Fallback: random placement if shell placement fails
                if (!validPoint) {
                    for (let j = 0; j < 50; j++) {
                        const x = Math.random() * (this.width - 60) + 30;
                        const y = Math.random() * (this.height - 60) + 30;
                        
                        if (this.isValidPosition(x, y, points)) {
                            points.push({ x, y });
                            break;
                        }
                    }
                }
            }
        }
        
        return points;
    }
    
    generateRingLayout(count) {
        const points = [];
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const rings = 4 + Math.floor(Math.random() * 3); // 4-6 rings
        const planetsPerRing = Math.floor(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = 60 + ring * 70; // Rings spaced 70 units apart
            const ringPlanets = ring === rings - 1 ? 
                count - (planetsPerRing * ring) : planetsPerRing;
            
            for (let i = 0; i < ringPlanets; i++) {
                let attempts = 0;
                let validPoint = false;
                
                while (!validPoint && attempts < 100) {
                    const angle = (i / ringPlanets) * 2 * Math.PI + (Math.random() - 0.5) * 0.3;
                    const ringRadius = radius + (Math.random() - 0.5) * 30; // Slight radius variation
                    
                    const x = centerX + Math.cos(angle) * ringRadius;
                    const y = centerY + Math.sin(angle) * ringRadius;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        validPoint = true;
                    }
                    attempts++;
                }
                
                // Fallback: random placement if ring placement fails
                if (!validPoint) {
                    for (let j = 0; j < 50; j++) {
                        const x = Math.random() * (this.width - 60) + 30;
                        const y = Math.random() * (this.height - 60) + 30;
                        
                        if (this.isValidPosition(x, y, points)) {
                            points.push({ x, y });
                            break;
                        }
                    }
                }
            }
        }
        
        return points;
    }
    
    generateBinaryLayout(count) {
        const points = [];
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        const systemRadius = Math.min(this.width, this.height) * 0.25;
        
        // Split planets between two major systems
        const leftCount = Math.floor(count / 2);
        const rightCount = count - leftCount;
        
        // Left system
        for (let i = 0; i < leftCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = leftCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        // Right system
        for (let i = 0; i < rightCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = rightCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        return points;
    }
    
    connectTerritoriesForLayout() {
        // Different connection strategies based on layout
        switch (this.layout) {
            case 'clusters':
                this.connectClusters();
                break;
            case 'spiral':
                this.connectSpiral();
                break;
            case 'core':
                this.connectCore();
                break;
            case 'ring':
                this.connectRings();
                break;
            case 'binary':
                this.connectBinary();
                break;
            case 'organic':
            default:
                this.connectTerritories();
                break;
        }
    }
    
    connectClusters() {
        const territoryList = Object.values(this.territories);
        
        // First connect within clusters (short distance connections)
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const closeNeighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= 80) { // Close cluster connections
                    closeNeighbors.push({ territory: other, distance });
                }
            }
            
            closeNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, closeNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = closeNeighbors[k].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
        
        // Then add bridge connections between clusters
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const bridgeTargets = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance > 80 && distance <= 200) { // Bridge connections
                    bridgeTargets.push({ territory: other, distance });
                }
            }
            
            if (bridgeTargets.length > 0) {
                bridgeTargets.sort((a, b) => a.distance - b.distance);
                const neighbor = bridgeTargets[0].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
    }
    
    connectSpiral() {
        const territoryList = Object.values(this.territories);
        
        // Connect along spiral arms and between nearby arms
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, neighbors.length); // Fewer connections for spiral
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
    }
    
    connectCore() {
        const territoryList = Object.values(this.territories);
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Identify core territories (close to center)
        const coreTerritories = territoryList.filter(t => {
            const distToCenter = Math.sqrt((t.x - centerX) ** 2 + (t.y - centerY) ** 2);
            return distToCenter <= 100;
        });
        
        // Dense connections in core
        for (const territory of coreTerritories) {
            const coreNeighbors = [];
            
            for (const other of coreTerritories) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= 120) {
                    coreNeighbors.push({ territory: other, distance });
                }
            }
            
            coreNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(5, coreNeighbors.length); // Dense core
            
            for (let k = 0; k < connections; k++) {
                const neighbor = coreNeighbors[k].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
        
        // Radial connections from core to shells
        for (const territory of territoryList) {
            if (coreTerritories.includes(territory)) continue;
            
            const radialNeighbors = [];
            for (const other of territoryList) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    radialNeighbors.push({ territory: other, distance });
                }
            }
            
            radialNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, radialNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = radialNeighbors[k].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
    }
    
    connectRings() {
        const territoryList = Object.values(this.territories);
        
        // Connect within rings and between adjacent rings
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, neighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addHiddenNeighbor(neighbor.id);
                neighbor.addHiddenNeighbor(territory.id);
            }
        }
    }
    
    connectBinary() {
        const territoryList = Object.values(this.territories);
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        
        // Identify left and right system territories
        const leftSystem = territoryList.filter(t => t.x < this.width / 2);
        const rightSystem = territoryList.filter(t => t.x >= this.width / 2);
        
        // Connect within each system
        [leftSystem, rightSystem].forEach(system => {
            for (const territory of system) {
                const systemNeighbors = [];
                
                for (const other of system) {
                    if (territory.id === other.id) continue;
                    const distance = territory.getDistanceTo(other);
                    
                    if (distance <= this.connectionDistance) {
                        systemNeighbors.push({ territory: other, distance });
                    }
                }
                
                systemNeighbors.sort((a, b) => a.distance - b.distance);
                const connections = Math.min(4, systemNeighbors.length);
                
                for (let k = 0; k < connections; k++) {
                    const neighbor = systemNeighbors[k].territory;
                    territory.addHiddenNeighbor(neighbor.id);
                    neighbor.addHiddenNeighbor(territory.id);
                }
            }
        });
        
        // Add bridge connections between systems
        const bridgeConnections = Math.min(3, Math.min(leftSystem.length, rightSystem.length));
        for (let i = 0; i < bridgeConnections; i++) {
            const leftTerr = leftSystem[Math.floor(Math.random() * leftSystem.length)];
            const rightTerr = rightSystem[Math.floor(Math.random() * rightSystem.length)];
            
            leftTerr.addHiddenNeighbor(rightTerr.id);
            rightTerr.addHiddenNeighbor(leftTerr.id);
        }
    }
    
    connectTerritories() {
        const territoryList = Object.values(this.territories);
        
        // Use Delaunay triangulation approximation for natural connections
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const nearbyTerritories = [];
            
            // Find all territories within connection distance
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    nearbyTerritories.push({ territory: other, distance });
                }
            }
            
            // Sort by distance and connect to closest neighbors
            nearbyTerritories.sort((a, b) => a.distance - b.distance);
            
            // Connect to 2-6 closest neighbors, influenced by warp lane density
            const baseDensity = this.warpLaneDensity / 100; // Convert percentage to decimal
            const maxConnections = Math.min(6, Math.max(2, nearbyTerritories.length));
            const adjustedConnections = Math.max(1, Math.floor(maxConnections * baseDensity));
            const numConnections = Math.min(adjustedConnections, 2 + Math.floor(Math.random() * 3));
            
            for (let k = 0; k < numConnections && k < nearbyTerritories.length; k++) {
                const neighbor = nearbyTerritories[k].territory;
                
                // Additional density check - some connections may be skipped based on density
                if (Math.random() * 100 > this.warpLaneDensity) continue;
                
                // If either territory is colonizable, make it a hidden connection
                if (territory.isColonizable || neighbor.isColonizable) {
                    territory.addHiddenNeighbor(neighbor.id);
                    neighbor.addHiddenNeighbor(territory.id);
                } else {
                    territory.addNeighbor(neighbor.id);
                    neighbor.addNeighbor(territory.id);
                }
            }
        }
        
        // Ensure connectivity by connecting isolated territories
        this.ensureConnectivity();
    }
    
    ensureConnectivity() {
        const visited = new Set();
        const territoryIds = Object.keys(this.territories);
        
        if (territoryIds.length === 0) return;
        
        // BFS to find connected components
        const bfs = (startId) => {
            const queue = [startId];
            const component = [];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                if (visited.has(currentId)) continue;
                
                visited.add(currentId);
                component.push(currentId);
                
                const territory = this.territories[currentId];
                territory.neighbors.forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        queue.push(neighborId);
                    }
                });
            }
            
            return component;
        };
        
        const components = [];
        
        // Find all connected components
        territoryIds.forEach(id => {
            if (!visited.has(id)) {
                components.push(bfs(id));
            }
        });
        
        // Connect isolated components
        while (components.length > 1) {
            const comp1 = components[0];
            const comp2 = components[1];
            
            // Find closest territories between components
            let minDistance = Infinity;
            let bestConnection = null;
            
            comp1.forEach(id1 => {
                const territory1 = this.territories[id1];
                comp2.forEach(id2 => {
                    const territory2 = this.territories[id2];
                    const distance = territory1.getDistanceTo(territory2);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestConnection = { territory1, territory2 };
                    }
                });
            });
            
            // Connect the closest territories
            if (bestConnection) {
                bestConnection.territory1.addNeighbor(bestConnection.territory2.id);
                bestConnection.territory2.addNeighbor(bestConnection.territory1.id);
            }
            
            // Merge components
            components[0] = comp1.concat(comp2);
            components.splice(1, 1);
        }
    }
    
    // Get territories within a rectangular area (for culling)
    getTerritoriesInBounds(bounds) {
        const result = [];
        
        Object.values(this.territories).forEach(territory => {
            if (territory.x + territory.radius >= bounds.left &&
                territory.x - territory.radius <= bounds.right &&
                territory.y + territory.radius >= bounds.top &&
                territory.y - territory.radius <= bounds.bottom) {
                result.push(territory);
            }
        });
        
        return result;
    }
    
    // Find nearest territory to a point
    findNearestTerritory(x, y) {
        let nearest = null;
        let minDistance = Infinity;
        
        Object.values(this.territories).forEach(territory => {
            const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = territory;
            }
        });
        
        return nearest;
    }
    
    // Get map statistics
    getMapStats() {
        const territoryCount = Object.keys(this.territories).length;
        let totalConnections = 0;
        let neutralTerritories = 0;
        
        Object.values(this.territories).forEach(territory => {
            totalConnections += territory.neighbors.length;
            if (territory.ownerId === null) {
                neutralTerritories++;
            }
        });
        
        return {
            territories: territoryCount,
            connections: totalConnections / 2, // Each connection counted twice
            averageConnections: totalConnections / territoryCount,
            neutralTerritories: neutralTerritories,
            width: this.width,
            height: this.height
        };
    }
    
    // Serialize map data for network transmission (future multiplayer)
    serialize() {
        const serializedTerritories = {};
        
        Object.keys(this.territories).forEach(id => {
            serializedTerritories[id] = this.territories[id].serialize();
        });
        
        return {
            width: this.width,
            height: this.height,
            territories: serializedTerritories
        };
    }
    
    // Deserialize map data from network (future multiplayer)
    static deserialize(data) {
        const map = new GameMap(data.width, data.height);
        
        Object.keys(data.territories).forEach(id => {
            map.territories[id] = Territory.deserialize(data.territories[id]);
        });
        
        return map;
    }
    
    isInNebula(x, y) {
        // Check if a point is inside any nebula
        for (const nebula of this.nebulas) {
            const distance = Math.sqrt((x - nebula.x) ** 2 + (y - nebula.y) ** 2);
            if (distance <= nebula.radius) {
                return true;
            }
        }
        return false;
    }


}


================================================================================
FILE: client/src/game/GameUI.js (1,044 lines)
================================================================================
export class GameUI {
    constructor(canvas, camera) {
        this.canvas = canvas;
        this.camera = camera;
        
        // UI state
        this.showLeaderboard = true;
        this.showMinimap = true;
        this.showStats = true;
        this.showHelp = false;
        
        // Animation
        this.animationPhase = 0;
        
        // Colors with better contrast
        this.bgColor = 'rgba(0, 0, 0, 0.85)';
        this.textColor = '#ffffff';
        this.accentColor = '#00ddff';
        this.warningColor = '#ff4444';
        this.successColor = '#44ff44';
        this.shadowColor = 'rgba(0, 0, 0, 0.8)';
    }

    // Helper function to render text with shadow for better readability
    renderTextWithShadow(ctx, text, x, y, fillColor = this.textColor, shadowOffset = 2) {
        // Draw shadow
        ctx.fillStyle = this.shadowColor;
        ctx.fillText(text, x + shadowOffset, y + shadowOffset);
        
        // Draw main text
        ctx.fillStyle = fillColor;
        ctx.fillText(text, x, y);
    }
    
    // Method for FSM to update UI state
    setInputState(state, data = {}) {
        this.inputState = state;
        this.inputStateData = data;
        
        // Update cursor based on FSM state
        if (this.canvas) {
            const cursorModes = {
                'Default': 'default',
                'TerritorySelected': 'pointer',
                'ProbeTargeting': 'crosshair',
                'EnemySelected': 'help'
            };
            this.canvas.style.cursor = cursorModes[state] || 'default';
        }
    }
    
    render(ctx, gameData) {
        this.animationPhase += 0.02;
        
        // Render different UI elements based on game state
        switch (gameData.gameState) {
            case 'lobby':
                this.renderLobbyUI(ctx, gameData);
                break;
            case 'playing':
                this.renderGameUI(ctx, gameData);
                break;
            case 'ended':
                this.renderEndGameUI(ctx, gameData);
                break;
        }
    }
    
    renderLobbyUI(ctx, gameData) {
        // Title screen
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Star Throne', this.canvas.width / 2, this.canvas.height / 2 - 100);
        
        ctx.font = '24px Arial';
        ctx.fillText('Massive Multiplayer Strategy Game', this.canvas.width / 2, this.canvas.height / 2 - 50);
        
        ctx.font = '18px Arial';
        ctx.fillText('Click anywhere to start', this.canvas.width / 2, this.canvas.height / 2 + 50);
        
        // Animated dots
        const dots = '...'.substring(0, Math.floor(this.animationPhase * 3) % 4);
        ctx.fillText(`Loading${dots}`, this.canvas.width / 2, this.canvas.height / 2 + 100);
    }
    
    renderGameUI(ctx, gameData) {
        // Top bar with timer and game info
        this.renderTopBar(ctx, gameData);
        
        // Leaderboard
        if (this.showLeaderboard) {
            this.renderLeaderboard(ctx, gameData);
        }
        
        // All UI panels removed for minimal clean interface
        
        // Minimap (minimizable)
        if (this.showMinimap) {
            this.renderMinimap(ctx, gameData);
        }
        
        // Discovery panel showing empire bonuses
        this.renderDiscoveryPanel(ctx, gameData);
        
        // Performance panel (togglable with P key)
        this.renderPerformanceInfo(ctx, gameData);
        
        // Zoom controls removed - using mousewheel only
        
        // Tooltip for hovered territory
        this.renderTooltip(ctx, gameData);
        
        // Render notifications
        this.renderNotifications(ctx, gameData);
        
        // Floating discovery announcements at top center
        this.renderFloatingAnnouncements(ctx, gameData);
        
        // Game over screen for human player
        const humanPlayer = gameData.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            this.renderGameOverScreen(ctx, gameData);
        }
    }
    
    renderEndGameUI(ctx, gameData) {
        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 150);
        
        // Final leaderboard
        this.renderFinalLeaderboard(ctx, gameData);
        
        // Mobile-friendly restart button
        const buttonWidth = 200;
        const buttonHeight = 50;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height - 100;
        
        // Restart button background
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border
        ctx.strokeStyle = this.textColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button text
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Tap to Restart', this.canvas.width / 2, buttonY + 32);
        
        // Store button area for touch detection
        this.restartButton = {
            x: buttonX,
            y: buttonY,
            width: buttonWidth,
            height: buttonHeight
        };
    }
    
    renderTopBar(ctx, gameData) {
        const barHeight = 60;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, barHeight);
        
        // Timer
        const timeLeft = Math.max(0, gameData.gameTimer);
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        ctx.fillStyle = timeLeft < 60000 ? this.warningColor : this.textColor;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(timeString, this.canvas.width / 2, 35);
        
        // Player count
        ctx.fillStyle = this.textColor;
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Players: ${gameData.currentPlayers}/${gameData.maxPlayers}`, 20, 25);
        
        // Game title
        ctx.textAlign = 'left';
        ctx.fillText('Star Throne', 20, 45);
        
        // Camera info
        ctx.textAlign = 'right';
        const zoom = (this.camera.zoom * 100).toFixed(0);
        ctx.fillText(`Zoom: ${zoom}%`, this.canvas.width - 20, 25);
    }
    
    renderLeaderboard(ctx, gameData) {
        const startX = this.canvas.width - 250;
        const startY = 80;
        const width = 230;
        const itemHeight = 25;
        
        if (gameData.leaderboardMinimized) {
            // Minimized leaderboard - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY, width, 35);
            
            ctx.fillStyle = this.accentColor;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Leaderboard (tap to expand)', startX + width / 2, startY + 22);
            
            // Add minimize indicator
            ctx.fillStyle = this.textColor;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('▼', startX + width - 10, startY + 22);
            return;
        }
        
        // Sort players by score
        const sortedPlayers = gameData.players
            .filter(p => !p.isEliminated)
            .sort((a, b) => b.score - a.score)
            .slice(0, 10); // Top 10
        
        const height = 40 + sortedPlayers.length * itemHeight;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title with minimize indicator
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Leaderboard', startX + width / 2, startY + 20, this.accentColor);
        
        // Add minimize indicator
        ctx.font = '16px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '▲', startX + width - 10, startY + 20, this.textColor);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 40 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            
            // Rank
            ctx.fillStyle = this.textColor;
            ctx.font = isHuman ? 'bold 14px Arial' : '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${index + 1}.`, startX + 10, y);
            
            // Player color indicator
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 35, y - 8, 12, 12);
            
            // Player name
            ctx.fillStyle = isHuman ? this.accentColor : this.textColor;
            ctx.textAlign = 'left';
            const name = player.name.length > 10 ? player.name.substring(0, 10) + '...' : player.name;
            ctx.fillText(name, startX + 55, y);
            
            // Territory count
            ctx.fillStyle = this.textColor;
            ctx.textAlign = 'right';
            ctx.fillText(player.territories.length.toString(), startX + width - 10, y);
        });
        
        // Eliminated count
        const eliminatedCount = gameData.players.filter(p => p.isEliminated).length;
        if (eliminatedCount > 0) {
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${eliminatedCount} eliminated`, startX + width / 2, startY + height + 15);
        }
    }
    
    renderTerritoryInfo(ctx, gameData) {
        const territory = gameData.selectedTerritory;
        const startX = 20;
        const startY = this.canvas.height - 150;
        const width = 200;
        const height = 120;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Territory ${territory.id}`, startX + 10, startY + 20);
        
        // Owner info
        if (territory.ownerId !== null) {
            const owner = gameData.players[territory.ownerId];
            if (owner) {
                ctx.fillStyle = owner.color;
                ctx.fillRect(startX + 10, startY + 30, 12, 12);
                
                ctx.fillStyle = this.textColor;
                ctx.font = '14px Arial';
                ctx.fillText(`Owner: ${owner.name}`, startX + 30, startY + 40);
            }
        } else {
            ctx.fillStyle = this.textColor;
            ctx.font = '14px Arial';
            ctx.fillText('Neutral Territory', startX + 10, startY + 40);
        }
        
        // Army count
        ctx.fillText(`Armies: ${territory.armySize}`, startX + 10, startY + 60);
        
        // Neighbors
        ctx.font = '12px Arial';
        ctx.fillText(`Neighbors: ${territory.neighbors.length}`, startX + 10, startY + 80);
        
        // Action hint
        if (territory.ownerId === gameData.humanPlayer.id) {
            ctx.fillStyle = this.successColor;
            ctx.fillText('Click neighbor to attack', startX + 10, startY + 100);
        } else if (gameData.selectedTerritory && 
                   gameData.selectedTerritory.ownerId === gameData.humanPlayer.id &&
                   gameData.selectedTerritory.neighbors.includes(territory.id)) {
            ctx.fillStyle = this.warningColor;
            ctx.fillText('Click to attack', startX + 10, startY + 100);
        }
    }
    
    renderPlayerStats(ctx, gameData) {
        const player = gameData.humanPlayer;
        const startX = 250;
        const startY = this.canvas.height - 100;
        const width = 200;
        const height = 80;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Player name
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(player.name, startX + 10, startY + 20);
        
        // Stats
        ctx.fillStyle = this.textColor;
        ctx.font = '14px Arial';
        ctx.fillText(`Territories: ${player.territories.length}`, startX + 10, startY + 40);
        ctx.fillText(`Total Armies: ${player.totalArmies}`, startX + 10, startY + 55);
        ctx.fillText(`Score: ${player.score}`, startX + 10, startY + 70);
    }
    
    renderSpectatorMessage(ctx) {
        const startX = this.canvas.width / 2 - 150;
        const startY = 100;
        const width = 300;
        const height = 60;
        
        // Background
        ctx.fillStyle = 'rgba(255, 68, 68, 0.9)';
        ctx.fillRect(startX, startY, width, height);
        
        // Message
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('You have been eliminated!', startX + width / 2, startY + 25);
        
        ctx.font = '14px Arial';
        ctx.fillText('Spectator Mode', startX + width / 2, startY + 45);
    }
    
    renderHelpPanel(ctx) {
        const startX = 20;
        const startY = 80;
        const width = 200;
        const height = 140;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Controls', startX + 10, startY + 18);
        
        // Help text - mobile-friendly
        ctx.fillStyle = this.textColor;
        ctx.font = '12px Arial';
        const helpLines = [
            'Tap: Select/Attack',
            'Drag: Pan camera',
            'Pinch: Zoom in/out',
            'Two finger: Pan & zoom',
            'ESC: Deselect',
            'R: Restart (when ended)'
        ];
        
        helpLines.forEach((line, index) => {
            ctx.fillText(line, startX + 10, startY + 35 + index * 15);
        });
    }
    
    renderPerformanceInfo(ctx, gameData) {
        // Show detailed performance panel if enabled
        if (gameData.showPerformancePanel) {
            const x = this.canvas.width - 250;
            const y = 50;
            const width = 240;
            const height = 160;
            
            // Background with transparency
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - 10, y - 10, width, height);
            
            // Border
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 10, width, height);
            
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            
            // Performance metrics with color coding
            const fps = gameData.fps || 0;
            const fpsColor = fps > 50 ? '#00ff00' : fps > 30 ? '#ffff00' : '#ff0000';
            this.renderTextWithShadow(ctx, `FPS: ${fps}`, x, y, fpsColor);
            
            this.renderTextWithShadow(ctx, `Frame: ${(gameData.frameTime || 0).toFixed(1)}ms`, x, y + 20, this.textColor);
            this.renderTextWithShadow(ctx, `Render: ${(gameData.renderTime || 0).toFixed(1)}ms`, x, y + 40, this.textColor);
            this.renderTextWithShadow(ctx, `Update: ${(gameData.updateTime || 0).toFixed(1)}ms`, x, y + 60, this.textColor);
            
            // Game-specific metrics
            this.renderTextWithShadow(ctx, `Territories: ${gameData.territoryCount || 0}`, x, y + 80, this.textColor);
            this.renderTextWithShadow(ctx, `Rendered: ${gameData.visibleTerritories || 0}`, x, y + 100, this.textColor);
            this.renderTextWithShadow(ctx, `Probes: ${gameData.probeCount || 0}`, x, y + 120, this.textColor);
            
            // Toggle hint
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, 'Press P to toggle', x + width - 15, y + height - 15, '#888888');
        } else {
            // Simple FPS counter
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`FPS: ${gameData.fps}`, this.canvas.width - 20, this.canvas.height - 10);
        }
        
        // Mobile touch debug info
        if (gameData.touchDebugInfo && gameData.showTouchDebug) {
            ctx.fillStyle = this.accentColor;
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            const lines = gameData.touchDebugInfo.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, 10, this.canvas.height - 60 + (index * 16));
            });
        }
    }
    
    renderProbeNotification(ctx, gameData) {
        // Show temporary probe notification above discovery panel for 3 seconds
        const recentProbeResults = gameData.recentProbeResults || [];
        const now = Date.now();
        
        // Get most recent probe result for human player within last 3 seconds
        const latestProbe = recentProbeResults
            .filter(result => result.playerId === gameData.humanPlayer?.id && (now - result.timestamp) < 3000)
            .sort((a, b) => b.timestamp - a.timestamp)[0];
        
        if (!latestProbe) return;
        
        // Top center positioning
        const width = 400;
        const height = 50;
        const x = (this.canvas.width - width) / 2;
        const y = 20;
        
        // Background with transparency
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Border with probe result color
        const borderColor = latestProbe.success ? '#00ff88' : '#ff4444';
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Probe notification text
        ctx.fillStyle = borderColor;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        
        const probeText = latestProbe.success 
            ? `✓ Probe succeeded: ${latestProbe.discoveryName}`
            : `✗ Probe failed: ${latestProbe.discoveryName}`;
            
        ctx.fillText(probeText, x + 10, y + 25);
        
        // Fade out effect
        const age = now - latestProbe.timestamp;
        if (age > 2000) { // Start fading after 2 seconds
            const fadeAlpha = 1 - ((age - 2000) / 1000); // Fade over 1 second
            ctx.globalAlpha = Math.max(0, fadeAlpha);
            ctx.fillText(probeText, x + 10, y + 25);
            ctx.globalAlpha = 1; // Reset alpha
        }
    }
    
    renderDiscoveryPanel(ctx, gameData) {
        // Only show human player's discoveries
        if (!gameData.playerDiscoveries || !gameData.humanPlayer) return;
        
        const discoveries = gameData.playerDiscoveries.get(gameData.humanPlayer.id);
        if (!discoveries) return;
        
        let discoveryCount = 0;
        
        // Count active discoveries (with safety checks)
        if (discoveries && discoveries.precursorWeapons > 0) discoveryCount++;
        if (discoveries && discoveries.precursorDrive > 0) discoveryCount++;
        if (discoveries && discoveries.precursorShield > 0) discoveryCount++;
        if (discoveries && discoveries.precursorNanotech > 0) discoveryCount++;
        if (discoveries && discoveries.factoryPlanets && discoveries.factoryPlanets.size > 0) discoveryCount++;
        
        // Show panel only if there are permanent empire discoveries
        if (discoveryCount === 0) return;
        
        const x = 20;
        const width = 280;
        const lineHeight = 20;
        const padding = 10;
        const discoveryHeight = discoveryCount * lineHeight;
        const titleHeight = 25;
        const height = Math.max(80, titleHeight + discoveryHeight + padding * 2);
        const y = this.canvas.height - height - 20; // Bottom left positioning
        
        // Background with transparency
        ctx.fillStyle = 'rgba(0, 20, 40, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery theme color
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Title
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        this.renderTextWithShadow(ctx, '🔬 Empire Discoveries', x + padding, y + 20, '#4CAF50');
        
        let currentY = y + 40; // Start showing permanent bonuses
        
        // Show empire-wide bonuses only (no temporary notifications)
        ctx.font = '12px Arial';
        
        // Show empire-wide bonuses (with safety checks)
        if (discoveries && discoveries.precursorWeapons > 0) {
            this.renderTextWithShadow(ctx, `⚔️ Weapons Lvl ${discoveries.precursorWeapons}: +${discoveries.precursorWeapons * 10}% Attack`, x + padding, currentY, '#FF6B6B');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorDrive > 0) {
            this.renderTextWithShadow(ctx, `🚀 Drive Lvl ${discoveries.precursorDrive}: +${discoveries.precursorDrive * 20}% Speed`, x + padding, currentY, '#4ECDC4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorShield > 0) {
            this.renderTextWithShadow(ctx, `🛡️ Shield Lvl ${discoveries.precursorShield}: +${discoveries.precursorShield * 10}% Defense`, x + padding, currentY, '#45B7D1');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorNanotech > 0) {
            this.renderTextWithShadow(ctx, `🔬 Nanotech Lvl ${discoveries.precursorNanotech}: +${discoveries.precursorNanotech * 10}% Generation`, x + padding, currentY, '#96CEB4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.factoryPlanets && discoveries.factoryPlanets.size > 0) {
            this.renderTextWithShadow(ctx, `🏭 Factory Worlds: ${discoveries.factoryPlanets.size} (+100% each)`, x + padding, currentY, '#FECA57');
            currentY += lineHeight;
        }
        
        // Discovery count summary
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, `Total: ${discoveryCount} discoveries`, x + width - padding, y + height - 5, '#888888');
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 255, g: 255, b: 255};
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': '💀',
            'extra_fleet': '👽',
            'precursor_weapons': '⚔️',
            'precursor_drive': '🚀',
            'precursor_shield': '🛡️',
            'precursor_nanotech': '🔬',
            'factory_complex': '🏭',
            'mineral_deposits': '💎',
            'void_storm': '⚡',
            'ancient_ruins': '🏛️'
        };
        return icons[effect] || '🔍';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    renderFloatingAnnouncements(ctx, gameData) {
        if (!gameData.discoveryLog || !gameData.humanPlayer) return;
        
        const now = Date.now();
        const humanPlayerId = gameData.humanPlayer.id;
        const announcements = gameData.discoveryLog.filter(entry => {
            const age = (now - entry.timestamp) / 1000;
            return age <= 3 && entry.playerId === humanPlayerId; // Only show human player discoveries for 3 seconds
        });
        
        // Show only the most recent announcement at top center
        if (announcements.length === 0) return;
        
        const latestAnnouncement = announcements.sort((a, b) => b.timestamp - a.timestamp)[0];
        const age = (now - latestAnnouncement.timestamp) / 1000;
        const fadeProgress = age / 3; // Fade over 3 seconds
        const opacity = Math.max(0, 1 - fadeProgress);
        
        // Get discovery info
        const icon = this.getDiscoveryIcon(latestAnnouncement.discovery.effect);
        const color = this.getDiscoveryColor(latestAnnouncement.discovery.effect);
        
        // Apply opacity
        const rgb = this.hexToRgb(color);
        const fadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
        
        // Top center positioning
        const width = 400;
        const height = 50;
        const x = (this.canvas.width - width) / 2;
        const y = 20;
        
        // Background with transparency
        ctx.fillStyle = `rgba(0, 0, 0, ${0.9 * opacity})`;
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery color
        ctx.strokeStyle = fadeColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Discovery text
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        const text = `${icon} ${latestAnnouncement.discovery.name}`;
        this.renderTextWithShadow(ctx, text, x + width/2, y + height/2 + 5, fadeColor);
    }
    
    renderMinimap(ctx, gameData) {
        const size = 150;
        const startX = this.canvas.width - size - 20;
        const startY = this.canvas.height - size - 20;
        
        if (gameData.minimapMinimized) {
            // Minimized minimap - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY + size - 30, size, 30);
            
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            this.renderTextWithShadow(ctx, 'Map (tap to expand)', startX + size / 2, startY + size - 12, this.accentColor);
            
            // Add expand indicator
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, '▲', startX + size - 10, startY + size - 12, this.textColor);
            return;
        }
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(startX, startY, size, size);
        
        // Border
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, size, size);
        
        // Calculate scale
        const mapWidth = 2000; // From GameMap
        const mapHeight = 1500;
        const scaleX = size / mapWidth;
        const scaleY = size / mapHeight;
        
        // Draw territories on minimap
        Object.values(gameData.players).forEach(player => {
            if (player.isEliminated) return;
            
            ctx.fillStyle = player.color;
            player.territories.forEach(territoryId => {
                const territory = gameData.selectedTerritory ? 
                    (gameData.selectedTerritory.id === territoryId ? gameData.selectedTerritory : null) : null;
                // This is a simplified version - in real implementation we'd access territories from gameMap
                
                if (territory) {
                    const x = startX + territory.x * scaleX;
                    const y = startY + territory.y * scaleY;
                    const radius = Math.max(1, territory.radius * scaleX * 0.5);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });
        
        // Draw camera viewport
        if (this.camera) {
            const viewBounds = this.camera.getViewBounds();
            const viewX = startX + viewBounds.left * scaleX;
            const viewY = startY + viewBounds.top * scaleY;
            const viewWidth = (viewBounds.right - viewBounds.left) * scaleX;
            const viewHeight = (viewBounds.bottom - viewBounds.top) * scaleY;
            
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(viewX, viewY, viewWidth, viewHeight);
        }
        
        // Minimap title with minimize indicator
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Map', startX + size / 2, startY - 5, this.textColor);
        
        // Add minimize indicator
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '▼', startX + size - 5, startY - 5, this.textColor);
    }
    
    renderTooltip(ctx, gameData) {
        if (!gameData.hoveredTerritory || !gameData.mousePos) return;
        
        const territory = gameData.hoveredTerritory;
        const mouseX = gameData.mousePos.x;
        const mouseY = gameData.mousePos.y;
        
        // Get territory information
        let ownerName = 'Neutral';
        let territoryColor = '#666666';
        
        if (territory.ownerId !== null && gameData.players[territory.ownerId]) {
            const owner = gameData.players[territory.ownerId];
            ownerName = owner.name;
            territoryColor = owner.color;
        }
        
        // Prepare tooltip text
        let tooltipLines = [];
        if (territory.isColonizable) {
            tooltipLines.push(`Unexplored System`);
            
            // Only show "Click to probe" if player has a valid selected territory that can reach it
            const canProbe = gameData.selectedTerritory && 
                            gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id &&
                            gameData.selectedTerritory.armySize >= 10; // Need 10 fleets for probe
            
            if (canProbe) {
                tooltipLines.push(`Click to probe (10 fleets)`);
            } else if (gameData.selectedTerritory && gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id) {
                tooltipLines.push(`Need 10 fleets to probe`);
            } else {
                tooltipLines.push(`Select owned territory first`);
            }
        } else {
            tooltipLines.push(`${ownerName}`);
            tooltipLines.push(`${territory.armySize} Fleets`);
            
            if (territory.isThronestar) {
                tooltipLines.push(`👑 Throne Star`);
            }
        }
        
        // Tooltip dimensions
        const padding = 8;
        const lineHeight = 16;
        const fontSize = 12;
        ctx.font = `${fontSize}px Arial`;
        
        const maxWidth = Math.max(...tooltipLines.map(line => ctx.measureText(line).width));
        const tooltipWidth = maxWidth + padding * 2;
        const tooltipHeight = tooltipLines.length * lineHeight + padding * 2;
        
        // Position tooltip near mouse but keep it on screen
        let tooltipX = mouseX + 15;
        let tooltipY = mouseY - tooltipHeight - 10;
        
        if (tooltipX + tooltipWidth > this.canvas.width) {
            tooltipX = mouseX - tooltipWidth - 15;
        }
        if (tooltipY < 0) {
            tooltipY = mouseY + 15;
        }
        
        // Draw tooltip background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip border
        ctx.strokeStyle = territoryColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip text
        ctx.fillStyle = '#ffffff';
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'left';
        
        tooltipLines.forEach((line, index) => {
            ctx.fillText(
                line,
                tooltipX + padding,
                tooltipY + padding + (index + 1) * lineHeight - 4
            );
        });
    }
    
    renderZoomControls(ctx, gameData) {
        const buttonSize = 50;
        const margin = 20;
        const spacing = 5;
        
        // Position in bottom left
        const zoomInX = margin;
        const zoomInY = this.canvas.height - margin - buttonSize;
        const zoomOutX = margin;
        const zoomOutY = this.canvas.height - margin - (buttonSize * 2) - spacing;
        
        // Current zoom percentage
        const zoomPercent = Math.round(gameData.camera?.zoom * 100) || 40;
        
        // Zoom Out button (-)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '-', zoomOutX + buttonSize/2, zoomOutY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom In button (+)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomInX, zoomInY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomInX, zoomInY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '+', zoomInX + buttonSize/2, zoomInY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom level display
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, `${zoomPercent}%`, zoomOutX + buttonSize/2, zoomOutY - 8, this.textColor);
    }
    
    renderGameOverScreen(ctx, gameData) {
        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 100, '#ff4444');
        
        // Subtitle
        ctx.font = '24px Arial';
        this.renderTextWithShadow(ctx, 'All your territories have been conquered!', this.canvas.width / 2, this.canvas.height / 2 - 50, this.textColor);
        
        // Spectator message
        ctx.font = '18px Arial';
        this.renderTextWithShadow(ctx, 'You can continue watching the game...', this.canvas.width / 2, this.canvas.height / 2, this.textColor);
        
        // Play Again button
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height / 2 + 50;
        
        // Button background
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button text
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'PLAY AGAIN', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2 + 7, '#ffffff');
    }
    
    renderFinalLeaderboard(ctx, gameData) {
        const startX = this.canvas.width / 2 - 200;
        const startY = this.canvas.height / 2 - 50;
        const width = 400;
        const itemHeight = 30;
        
        // Sort all players by score
        const sortedPlayers = [...gameData.players].sort((a, b) => b.score - a.score);
        const height = 60 + sortedPlayers.length * itemHeight;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Final Results', startX + width / 2, startY + 30);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 60 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            const isWinner = index === 0 && !player.isEliminated;
            
            // Background for winner
            if (isWinner) {
                ctx.fillStyle = 'rgba(68, 255, 68, 0.2)';
                ctx.fillRect(startX + 5, y - 20, width - 10, itemHeight - 5);
            }
            
            // Rank
            ctx.fillStyle = isWinner ? this.successColor : this.textColor;
            ctx.font = isHuman ? 'bold 16px Arial' : '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${index + 1}.`, startX + 20, y);
            
            // Player color
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 50, y - 10, 15, 15);
            
            // Player name
            ctx.fillStyle = isHuman ? this.accentColor : (isWinner ? this.successColor : this.textColor);
            ctx.fillText(player.name, startX + 75, y);
            
            // Stats
            ctx.fillStyle = this.textColor;
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`${player.territories.length} territories`, startX + width - 120, y - 5);
            ctx.fillText(`${player.score} points`, startX + width - 120, y + 10);
            
            // Status
            if (player.isEliminated) {
                ctx.fillStyle = this.warningColor;
                ctx.fillText('Eliminated', startX + width - 20, y);
            } else if (isWinner) {
                ctx.fillStyle = this.successColor;
                ctx.fillText('Winner!', startX + width - 20, y);
            }
        });
    }
    
    // Render notification messages for discoveries
    renderNotifications(ctx, gameData) {
        if (!gameData.notifications || gameData.notifications.length === 0) return;
        
        const notifications = gameData.notifications;
        const startY = 150; // Start below top UI elements
        const lineHeight = 40;
        const padding = 15;
        const maxWidth = 400;
        
        notifications.forEach((notification, index) => {
            const y = startY + index * lineHeight;
            const x = this.canvas.width - maxWidth - 20; // Right side of screen
            
            // Background with fade
            ctx.globalAlpha = notification.opacity;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Border based on notification type
            ctx.strokeStyle = notification.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Text
            ctx.fillStyle = notification.color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(notification.text, x, y);
            
            ctx.globalAlpha = 1.0; // Reset opacity
        });
    }
}


================================================================================
FILE: client/src/game/Renderer.js
================================================================================
/**
 * Renderer.js - Dedicated rendering module
 * 
 * Exclusively responsible for all drawing operations on the HTML5 Canvas.
 * Receives game state and renders it without modifying the state.
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants.ts';

export class Renderer {
    constructor(canvas, camera) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.camera = camera;
        
        // Performance tracking
        this.visibleTerritories = 0;
        this.lastVisibilityUpdate = 0;
        
        // Object pooling for ship animations
        this.shipAnimationPool = [];
        this.activeShipAnimations = [];
        
        // Parallax starfield layers
        this.starLayers = {
            far: [],
            mid: [],
            near: []
        };
        
        this.setupCanvas();
        this.initializeStarfield();
    }
    
    setupCanvas() {
        // Set canvas size
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        
        // Configure context settings
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.camera.updateViewport(this.canvas.width, this.canvas.height);
        });
    }
    
    initializeStarfield() {
        // Generate three layers of parallax stars
        const generateStars = (count, minSize, maxSize, minOpacity, maxOpacity) => {
            const stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_WIDTH * 1.5,
                    y: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_HEIGHT * 1.5,
                    size: Math.random() * (maxSize - minSize) + minSize,
                    opacity: Math.random() * (maxOpacity - minOpacity) + minOpacity,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            return stars;
        };
        
        this.starLayers.far = generateStars(300, 0.5, 1.0, 0.2, 0.4);
        this.starLayers.mid = generateStars(150, 1.0, 1.5, 0.3, 0.6);
        this.starLayers.near = generateStars(80, 1.5, 2.5, 0.4, 0.8);
    }
    
    render(gameData) {
        const startTime = performance.now();
        
        // Clear canvas
        this.ctx.fillStyle = GAME_CONSTANTS.BACKGROUND_COLOR;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Apply camera transform
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render parallax starfield
        this.renderStarfield();
        
        // Render nebulas (behind territories)
        this.renderNebulas(gameData.gameMap);
        
        // Update visible territories for performance
        this.updateVisibleTerritories(gameData.gameMap);
        
        // Render game objects
        this.renderConnections(gameData.gameMap);
        this.renderSupplyRoutes(gameData.supplyRoutes);
        this.renderTerritories(gameData.gameMap, gameData.humanPlayer, gameData.discoveries);
        this.renderProbes(gameData.probes, gameData.gameMap);
        this.renderShipAnimations();
        
        // Render selection and drag preview
        if (gameData.inputState?.selectedTerritory) {
            this.renderSelection(gameData.inputState.selectedTerritory);
        }
        this.renderDragPreview(gameData);
        
        this.ctx.restore();
        
        // Render UI (screen coordinates)
        this.renderUI(gameData);
        
        const renderTime = performance.now() - startTime;
        return { renderTime, visibleTerritories: this.visibleTerritories };
    }
    
    renderStarfield() {
        const viewBounds = this.camera.getViewBounds();
        const cameraPos = this.camera.getWorldCenter();
        
        // Render each layer with different parallax factors
        this.renderStarLayer(this.starLayers.far, 0.05, viewBounds, cameraPos);
        this.renderStarLayer(this.starLayers.mid, 0.15, viewBounds, cameraPos);
        this.renderStarLayer(this.starLayers.near, 0.30, viewBounds, cameraPos);
    }
    
    renderStarLayer(stars, parallaxFactor, viewBounds, cameraPos) {
        this.ctx.save();
        
        for (const star of stars) {
            // Apply parallax offset
            const parallaxX = star.x - cameraPos.x * parallaxFactor;
            const parallaxY = star.y - cameraPos.y * parallaxFactor;
            
            // Viewport culling
            if (parallaxX < viewBounds.left - 50 || parallaxX > viewBounds.right + 50 ||
                parallaxY < viewBounds.top - 50 || parallaxY > viewBounds.bottom + 50) {
                continue;
            }
            
            // Twinkling animation
            star.twinklePhase += star.twinkleSpeed;
            const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
            const opacity = star.opacity * twinkle;
            
            this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.restore();
    }
    
    renderNebulas(gameMap) {
        if (!gameMap.nebulas) return;
        
        const viewBounds = this.camera.getViewBounds();
        
        for (const nebula of gameMap.nebulas) {
            // Viewport culling
            if (nebula.x + nebula.radius < viewBounds.left || nebula.x - nebula.radius > viewBounds.right ||
                nebula.y + nebula.radius < viewBounds.top || nebula.y - nebula.radius > viewBounds.bottom) {
                continue;
            }
            
            // Create radial gradient
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, 'rgba(128, 0, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(64, 0, 128, 0.2)');
            gradient.addColorStop(1, 'rgba(32, 0, 64, 0.1)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    updateVisibleTerritories(gameMap) {
        const now = Date.now();
        if (now - this.lastVisibilityUpdate < 100) return; // Throttle to 10fps
        
        this.lastVisibilityUpdate = now;
        this.visibleTerritories = 0;
        
        const viewBounds = this.camera.getViewBounds();
        const margin = 50;
        
        for (const territory of Object.values(gameMap.territories)) {
            if (this.camera.isRectVisible(
                territory.x - territory.radius, territory.y - territory.radius,
                territory.radius * 2, territory.radius * 2, margin
            )) {
                territory.isVisible = true;
                this.visibleTerritories++;
            } else {
                territory.isVisible = false;
            }
        }
    }
    
    renderConnections(gameMap) {
        this.ctx.save();
        this.ctx.strokeStyle = GAME_CONSTANTS.CONNECTION_COLOR;
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.6;
        
        const renderedConnections = new Set();
        
        for (const territory of Object.values(gameMap.territories)) {
            if (!territory.isVisible) continue;
            
            for (const neighborId of territory.neighbors) {
                const neighbor = gameMap.territories[neighborId];
                if (!neighbor || !neighbor.isVisible) continue;
                
                // Avoid duplicate rendering
                const connectionKey = territory.id < neighborId ? 
                    `${territory.id}-${neighborId}` : `${neighborId}-${territory.id}`;
                
                if (renderedConnections.has(connectionKey)) continue;
                renderedConnections.add(connectionKey);
                
                // Color connections between same-owned territories
                if (territory.ownerId && territory.ownerId === neighbor.ownerId) {
                    const player = this.findPlayerById(territory.ownerId);
                    this.ctx.strokeStyle = player?.color || GAME_CONSTANTS.CONNECTION_COLOR;
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.8;
                } else {
                    this.ctx.strokeStyle = GAME_CONSTANTS.CONNECTION_COLOR;
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.6;
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            }
        }
        
        this.ctx.restore();
    }
    
    renderSupplyRoutes(supplyRoutes) {
        if (!supplyRoutes || supplyRoutes.length === 0) return;
        
        this.ctx.save();
        this.ctx.strokeStyle = GAME_CONSTANTS.SUPPLY_ROUTE_COLOR;
        this.ctx.lineWidth = 3;
        this.ctx.globalAlpha = 0.8;
        
        const currentTime = Date.now();
        const dashOffset = (currentTime * GAME_CONSTANTS.SUPPLY_ROUTE_DASH_ANIMATION_SPEED) % 20;
        this.ctx.setLineDash([10, 10]);
        this.ctx.lineDashOffset = dashOffset;
        
        for (const route of supplyRoutes) {
            if (!route.active || !route.path || route.path.length < 2) continue;
            
            this.ctx.beginPath();
            const firstTerritory = route.path[0];
            this.ctx.moveTo(firstTerritory.x, firstTerritory.y);
            
            for (let i = 1; i < route.path.length; i++) {
                const territory = route.path[i];
                this.ctx.lineTo(territory.x, territory.y);
            }
            
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
    
    renderTerritories(gameMap, humanPlayer, discoveries = []) {
        const currentTime = Date.now();
        const zoomLevel = this.camera.getZoomLevel();
        
        // Level of Detail rendering
        const showDetails = zoomLevel > 0.5;
        const showNumbers = zoomLevel > 0.3;
        
        for (const territory of Object.values(gameMap.territories)) {
            if (!territory.isVisible) continue;
            
            this.ctx.save();
            
            // Render territory circle
            this.renderTerritoryCircle(territory, currentTime, humanPlayer);
            
            // Render throne star crown
            if (territory.isThronestar) {
                this.renderThroneStarCrown(territory);
            }
            
            // Render colonizable planet indicator
            if (territory.isColonizable) {
                this.renderColonizableIndicator(territory);
            }
            
            // Render army count
            if (showNumbers && !territory.isColonizable) {
                this.renderArmyCount(territory);
            }
            
            // Render floating text
            if (territory.floatingText && showDetails) {
                this.renderFloatingText(territory);
            }
            
            // Render human player flag
            if (territory.ownerId === humanPlayer?.id && showDetails) {
                this.renderHumanPlayerFlag(territory);
            }
            
            this.ctx.restore();
        }
    }
    
    renderTerritoryCircle(territory, currentTime, humanPlayer) {
        // Flash effects
        let flashAlpha = 1.0;
        if (territory.combatFlashTime && currentTime - territory.combatFlashTime < territory.combatFlashDuration) {
            flashAlpha = 0.3 + 0.7 * Math.sin((currentTime - territory.combatFlashTime) * 0.02);
        }
        
        // Base color
        let fillColor = territory.baseColor;
        if (territory.ownerId) {
            const player = this.findPlayerById(territory.ownerId);
            fillColor = player?.color || territory.baseColor;
        }
        
        // Human player pulsing effect
        if (territory.ownerId === humanPlayer?.id) {
            const pulseIntensity = 0.3 + 0.2 * Math.sin(currentTime * 0.005);
            this.ctx.globalAlpha = pulseIntensity;
            this.ctx.fillStyle = '#00ffff';
            this.ctx.beginPath();
            this.ctx.arc(territory.x, territory.y, territory.radius + 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Main territory circle
        this.ctx.globalAlpha = flashAlpha;
        this.ctx.fillStyle = fillColor;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Border
        this.ctx.strokeStyle = territory.strokeColor;
        this.ctx.lineWidth = territory.ownerId === humanPlayer?.id ? 3 : 2;
        this.ctx.stroke();
    }
    
    renderThroneStarCrown(territory) {
        const crownSize = 8;
        const crownY = territory.y - territory.radius - 10;
        
        this.ctx.fillStyle = '#FFD700';
        this.ctx.strokeStyle = '#FFA500';
        this.ctx.lineWidth = 1;
        
        // Crown base
        this.ctx.fillRect(territory.x - crownSize, crownY, crownSize * 2, crownSize * 0.6);
        
        // Crown spikes
        this.ctx.beginPath();
        this.ctx.moveTo(territory.x - crownSize, crownY);
        this.ctx.lineTo(territory.x - crownSize * 0.5, crownY - crownSize * 0.8);
        this.ctx.lineTo(territory.x, crownY - crownSize);
        this.ctx.lineTo(territory.x + crownSize * 0.5, crownY - crownSize * 0.8);
        this.ctx.lineTo(territory.x + crownSize, crownY);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    }
    
    renderColonizableIndicator(territory) {
        const pulsePhase = territory.pulsePhase || 0;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(pulsePhase * 0.05);
        
        this.ctx.fillStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
        this.ctx.font = 'bold 16px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // Text shadow
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.lineWidth = 3;
        this.ctx.strokeText('?', territory.x, territory.y);
        this.ctx.fillText('?', territory.x, territory.y);
    }
    
    renderArmyCount(territory) {
        this.ctx.fillStyle = 'black';
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 2;
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        const text = territory.armySize.toString();
        this.ctx.strokeText(text, territory.x, territory.y);
        this.ctx.fillText(text, territory.x, territory.y);
    }
    
    renderFloatingText(territory) {
        if (!territory.floatingText || Date.now() > territory.floatingText.endTime) {
            territory.floatingText = null;
            return;
        }
        
        const elapsed = Date.now() - territory.floatingText.startTime;
        const progress = elapsed / territory.floatingText.duration;
        const yOffset = -progress * 30;
        const alpha = 1.0 - progress;
        
        this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        this.ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
        this.ctx.lineWidth = 2;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        const text = territory.floatingText.text;
        const textY = territory.y + yOffset - territory.radius - 10;
        
        this.ctx.strokeText(text, territory.x, textY);
        this.ctx.fillText(text, territory.x, textY);
    }
    
    renderHumanPlayerFlag(territory) {
        const flagSize = 6;
        const flagX = territory.x + territory.radius - flagSize;
        const flagY = territory.y - territory.radius + flagSize;
        
        // Flag pole
        this.ctx.strokeStyle = '#888888';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(flagX, flagY);
        this.ctx.lineTo(flagX, flagY + flagSize * 2);
        this.ctx.stroke();
        
        // Flag
        this.ctx.fillStyle = '#00ffff';
        this.ctx.fillRect(flagX, flagY, flagSize, flagSize);
        
        // Star on flag
        this.ctx.fillStyle = 'white';
        this.ctx.font = '8px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('★', flagX + flagSize/2, flagY + flagSize/2);
    }
    
    renderProbes(probes, gameMap) {
        const currentTime = Date.now();
        
        for (const probe of probes) {
            if (!probe.isVisible) continue;
            
            const fromTerritory = gameMap.territories[probe.fromTerritoryId];
            const toTerritory = gameMap.territories[probe.toTerritoryId];
            
            if (!fromTerritory || !toTerritory) continue;
            
            // Calculate current position
            const progress = probe.progress;
            const x = fromTerritory.x + (toTerritory.x - fromTerritory.x) * progress;
            const y = fromTerritory.y + (toTerritory.y - fromTerritory.y) * progress;
            
            // Check if probe is in nebula
            let inNebula = false;
            if (gameMap.nebulas) {
                for (const nebula of gameMap.nebulas) {
                    const distance = Math.sqrt((x - nebula.x) ** 2 + (y - nebula.y) ** 2);
                    if (distance < nebula.radius) {
                        inNebula = true;
                        break;
                    }
                }
            }
            
            this.ctx.save();
            
            // Probe visual effects
            if (inNebula) {
                const fadeAlpha = 0.3 + 0.4 * Math.sin(currentTime * 0.01);
                this.ctx.globalAlpha = fadeAlpha;
            }
            
            // Probe circle
            this.ctx.fillStyle = probe.playerColor;
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
            
            // Probe trail
            this.ctx.strokeStyle = probe.playerColor;
            this.ctx.lineWidth = 2;
            this.ctx.globalAlpha = 0.5;
            this.ctx.beginPath();
            
            const trailLength = 20;
            const trailStartProgress = Math.max(0, progress - 0.1);
            const trailStartX = fromTerritory.x + (toTerritory.x - fromTerritory.x) * trailStartProgress;
            const trailStartY = fromTerritory.y + (toTerritory.y - fromTerritory.y) * trailStartProgress;
            
            this.ctx.moveTo(trailStartX, trailStartY);
            this.ctx.lineTo(x, y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }
    }
    
    renderShipAnimations() {
        const currentTime = Date.now();
        
        for (let i = this.activeShipAnimations.length - 1; i >= 0; i--) {
            const animation = this.activeShipAnimations[i];
            
            if (currentTime >= animation.endTime) {
                // Return to pool
                this.shipAnimationPool.push(animation);
                this.activeShipAnimations.splice(i, 1);
                continue;
            }
            
            this.renderShipAnimation(animation, currentTime);
        }
    }
    
    renderShipAnimation(animation, currentTime) {
        const elapsed = currentTime - animation.startTime;
        const progress = elapsed / animation.duration;
        
        // Multi-hop animation
        if (animation.segments && animation.segments.length > 1) {
            this.renderMultiHopShipAnimation(animation, progress);
        } else {
            this.renderSingleShipAnimation(animation, progress);
        }
    }
    
    renderSingleShipAnimation(animation, progress) {
        const x = animation.from.x + (animation.to.x - animation.from.x) * progress;
        const y = animation.from.y + (animation.to.y - animation.from.y) * progress;
        
        this.ctx.save();
        this.ctx.fillStyle = animation.color;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.8;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderMultiHopShipAnimation(animation, totalProgress) {
        const segmentProgress = totalProgress * animation.segments.length;
        const currentSegmentIndex = Math.floor(segmentProgress);
        const segmentLocalProgress = segmentProgress - currentSegmentIndex;
        
        if (currentSegmentIndex >= animation.segments.length) return;
        
        const segment = animation.segments[currentSegmentIndex];
        const x = segment.from.x + (segment.to.x - segment.from.x) * segmentLocalProgress;
        const y = segment.from.y + (segment.to.y - segment.from.y) * segmentLocalProgress;
        
        this.ctx.save();
        this.ctx.fillStyle = animation.color;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.8;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderSelection(selectedTerritory) {
        if (!selectedTerritory) return;
        
        this.ctx.save();
        this.ctx.strokeStyle = '#00ffff';
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([5, 5]);
        this.ctx.lineDashOffset = Date.now() * 0.01;
        
        this.ctx.beginPath();
        this.ctx.arc(selectedTerritory.x, selectedTerritory.y, selectedTerritory.radius + 5, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderDragPreview(gameData) {
        // Render proportional drag preview
        if (gameData.isProportionalDrag && gameData.proportionalDragStart && gameData.dragEnd) {
            this.renderProportionalDragPreview(gameData);
        }
    }
    
    renderProportionalDragPreview(gameData) {
        const from = gameData.proportionalDragStart.territory;
        const to = gameData.dragEnd;
        const percentage = gameData.fleetPercentage;
        
        if (!from || !to) return;
        
        this.ctx.save();
        
        // Drag line
        const lineColor = to.isColonizable ? '#ffff00' : 
                         (to.ownerId === gameData.humanPlayer?.id ? '#00ff00' : '#ff0000');
        
        this.ctx.strokeStyle = lineColor;
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([10, 5]);
        
        this.ctx.beginPath();
        this.ctx.moveTo(from.x, from.y);
        this.ctx.lineTo(to.x, to.y);
        this.ctx.stroke();
        
        // Percentage indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(midX - 30, midY - 10, 60, 20);
        
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(`${Math.round(percentage * 100)}%`, midX, midY);
        
        this.ctx.restore();
    }
    
    renderUI(gameData) {
        // UI rendering is handled by the GameUI class
        // This method exists for extensibility
    }
    
    // Helper methods
    findPlayerById(playerId, players = []) {
        return players.find(p => p.id === playerId);
    }
    
    // Object pooling for ship animations
    createShipAnimation(from, to, color, duration, segments = null) {
        let animation;
        
        if (this.shipAnimationPool.length > 0) {
            animation = this.shipAnimationPool.pop();
        } else {
            animation = {};
        }
        
        animation.from = from;
        animation.to = to;
        animation.color = color;
        animation.duration = duration;
        animation.startTime = Date.now();
        animation.endTime = animation.startTime + duration;
        animation.segments = segments;
        
        this.activeShipAnimations.push(animation);
        return animation;
    }
    
    // Performance monitoring
    getPerformanceStats() {
        return {
            visibleTerritories: this.visibleTerritories,
            activeShipAnimations: this.activeShipAnimations.length,
            pooledAnimations: this.shipAnimationPool.length
        };
    }
}

================================================================================
FILE: client/src/game/Player.js
================================================================================
// AI Finite State Machine states for enhanced strategic behavior
const AI_STATE = {
    EARLY_GAME_EXPANSION: 'EARLY_GAME_EXPANSION',
    CONSOLIDATING: 'CONSOLIDATING',
    AGGRESSIVE_ATTACK: 'AGGRESSIVE_ATTACK', 
    DEFENSIVE_POSTURING: 'DEFENSIVE_POSTURING',
};

export class Player {
    constructor(id, name, color, type = 'ai') {
        this.id = id;
        this.name = name;
        this.color = color;
        this.type = type; // 'human' or 'ai'
        
        // Game state
        this.territories = [];
        this.totalArmies = 0;
        this.isEliminated = false;
        this.score = 0;
        this.throneStarId = null; // ID of this player's throne star (starting planet)
        
        // Enhanced AI properties with state machine
        this.aiThinkTimer = 0;
        this.aiThinkInterval = 1000 + Math.random() * 2000; // 1-3 seconds
        this.aiStrategy = this.selectAIStrategy();
        this.aiTarget = null;
        
        // AI state machine for better strategic decisions
        if (this.type === 'ai') {
            this.aiState = AI_STATE.EARLY_GAME_EXPANSION;
            this.decisionTimer = 0;
            this.decisionInterval = 1000 + Math.random() * 500; // Faster decisions with jitter
            this.lastStateTransition = Date.now();
        }
        
        // Stats tracking
        this.territoriesConquered = 0;
        this.battlesWon = 0;
        this.battlesLost = 0;
        this.armiesLost = 0;
        
        // Last activity timestamp
        this.lastActivity = Date.now();
    }
    
    selectAIStrategy() {
        const strategies = ['aggressive', 'defensive', 'expansionist', 'opportunistic'];
        return strategies[Math.floor(Math.random() * strategies.length)];
    }
    
    update(deltaTime, gameMap, gameSpeed = 1.0, game = null) {
        // Generate armies for all owned territories with speed multiplier and discovery bonuses
        this.territories.forEach(territoryId => {
            const territory = gameMap.territories[territoryId];
            if (territory) {
                territory.generateArmies(deltaTime, this, gameSpeed, game);
            }
        });
        
        // Update stats
        this.updateStats();
        
        // AI logic
        if (this.type === 'ai' && !this.isEliminated) {
            this.updateAI(deltaTime, gameMap);
        }
    }
    
    updateStats() {
        this.totalArmies = this.territories.reduce((total, territoryId) => {
            // Note: We'd need access to gameMap here, so this might need to be called differently
            return total;
        }, 0);
        
        // Calculate score based on territories and armies
        this.score = this.territories.length * 100 + this.territoriesConquered * 50;
    }
    
    updateAI(deltaTime, gameMap) {
        this.aiThinkTimer += deltaTime;
        
        if (this.aiThinkTimer < this.aiThinkInterval) return;
        
        this.aiThinkTimer = 0;
        this.aiThinkInterval = 2000 + Math.random() * 3000; // Slower AI thinking for performance
        
        // Cache territory lookups to reduce map access
        const ownedTerritories = [];
        for (const id of this.territories) {
            const territory = gameMap.territories[id];
            if (territory && territory.armySize > 2) {
                ownedTerritories.push(territory);
            }
        }
        
        if (ownedTerritories.length === 0) return;
        
        // 20% chance to consider probe colonization (reduced for performance)
        if (Math.random() < 0.2) {
            if (this.considerProbeColonization(ownedTerritories, gameMap)) {
                return; // Probe launched, skip regular attack this turn
            }
        }
        
        // Limit AI actions per update to reduce computational load
        const maxActions = Math.min(2, Math.ceil(ownedTerritories.length / 5));
        
        // Select strategy-based action with performance limits
        switch (this.aiStrategy) {
            case 'aggressive':
                this.executeAggressiveStrategy(ownedTerritories, gameMap, maxActions);
                break;
            case 'defensive':
                this.executeDefensiveStrategy(ownedTerritories, gameMap, maxActions);
                break;
            case 'expansionist':
                this.executeExpansionistStrategy(ownedTerritories, gameMap, maxActions);
                break;
            case 'opportunistic':
                this.executeOpportunisticStrategy(ownedTerritories, gameMap, maxActions);
                break;
        }
    }
    
    executeAggressiveStrategy(attackableTerritories, gameMap, maxActions = 2) {
        let actionsPerformed = 0;
        
        // Attack strongest enemy territories with performance limits
        for (const territory of attackableTerritories) {
            if (actionsPerformed >= maxActions) break;
            
            const targets = this.findAttackTargets(territory, gameMap)
                .filter(target => target.ownerId !== null && target.ownerId !== this.id)
                .sort((a, b) => b.armySize - a.armySize)
                .slice(0, 3); // Limit target evaluation
            
            if (targets.length > 0) {
                const target = targets[0];
                if (territory.armySize > target.armySize) {
                    this.executeAttack(territory, target, gameMap);
                    actionsPerformed++;
                }
            }
        }
        return actionsPerformed;
    }
    
    executeDefensiveStrategy(attackableTerritories, gameMap) {
        // Reinforce weak territories and attack only weak enemies
        for (const territory of attackableTerritories) {
            const targets = this.findAttackTargets(territory, gameMap)
                .filter(target => target.ownerId !== null && target.ownerId !== this.id)
                .sort((a, b) => a.armySize - b.armySize);
            
            if (targets.length > 0) {
                const target = targets[0];
                if (territory.armySize > target.armySize * 1.5) {
                    this.executeAttack(territory, target, gameMap);
                    return;
                }
            }
        }
    }
    
    executeExpansionistStrategy(attackableTerritories, gameMap) {
        // Prioritize neutral territories
        for (const territory of attackableTerritories) {
            const neutralTargets = this.findAttackTargets(territory, gameMap)
                .filter(target => target.ownerId === null);
            
            if (neutralTargets.length > 0) {
                const target = neutralTargets[Math.floor(Math.random() * neutralTargets.length)];
                this.executeAttack(territory, target, gameMap);
                return;
            }
        }
        
        // If no neutral targets, attack weakest enemy
        this.executeOpportunisticStrategy(attackableTerritories, gameMap);
    }
    
    executeOpportunisticStrategy(attackableTerritories, gameMap) {
        // Attack best opportunities (weak targets with good strategic value)
        const allTargets = [];
        
        for (const territory of attackableTerritories) {
            const targets = this.findAttackTargets(territory, gameMap)
                .filter(target => target.ownerId !== this.id);
            
            targets.forEach(target => {
                const winChance = this.calculateWinChance(territory, target);
                if (winChance > 0.6) {
                    allTargets.push({
                        from: territory,
                        to: target,
                        winChance: winChance,
                        strategicValue: this.calculateStrategicValue(target, gameMap)
                    });
                }
            });
        }
        
        if (allTargets.length > 0) {
            // Sort by combined win chance and strategic value
            allTargets.sort((a, b) => (b.winChance * b.strategicValue) - (a.winChance * a.strategicValue));
            const bestTarget = allTargets[0];
            this.executeAttack(bestTarget.from, bestTarget.to, gameMap);
        }
    }
    
    findAttackTargets(territory, gameMap) {
        return territory.neighbors
            .map(id => gameMap.territories[id])
            .filter(neighbor => neighbor !== null && !neighbor.isColonizable);
    }
    
    calculateWinChance(attackingTerritory, defendingTerritory) {
        const attackPower = attackingTerritory.armySize * 0.75 * (0.8 + Math.random() * 0.4);
        const defensePower = defendingTerritory.armySize * (1.0 + Math.random() * 0.2);
        
        return attackPower / (attackPower + defensePower);
    }
    
    calculateStrategicValue(territory, gameMap) {
        let value = 1;
        
        // Neutral territories are valuable for expansion
        if (territory.ownerId === null) {
            value += 0.5;
        }
        
        // Territories with many neighbors are strategically valuable
        value += territory.neighbors.length * 0.1;
        
        // Territories that would connect our regions are valuable
        const ourNeighbors = territory.neighbors.filter(id => {
            const neighbor = gameMap.territories[id];
            return neighbor && neighbor.ownerId === this.id;
        });
        
        if (ourNeighbors.length >= 2) {
            value += 0.3; // Connection bonus
        }
        
        return value;
    }
    
    executeAttack(attackingTerritory, defendingTerritory, gameMap) {
        if (attackingTerritory.armySize <= 1) return;
        
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for AI attack (access via gameMap reference)
        if (gameMap.game) {
            gameMap.game.createShipAnimation(attackingTerritory, defendingTerritory, true);
        }
        
        // Store original owner ID first for debugging
        const oldOwnerId = defendingTerritory.ownerId;
        
        // Enhanced logging for throne star attacks
        if (defendingTerritory.isThronestar || Math.random() < 0.05) {
            console.log(`AI ${this.name} attacking territory ${defendingTerritory.id} from ${attackingTerritory.id}${defendingTerritory.isThronestar ? ' (👑 THRONE STAR!)' : ''}`);
        }
        
        // Debug: Log attacking army strength for throne star attacks
        if (defendingTerritory.isThronestar) {
            console.log(`Throne attack details: Attacker ${attackingTerritory.armySize} armies (${Math.floor(attackingTerritory.armySize * 0.7)} attacking) vs Defender ${defendingTerritory.armySize} armies`);
            const isHumanTarget = oldOwnerId === 0; // Human player always has ID 0
            console.log(`Defending player: ${oldOwnerId} ${isHumanTarget ? '(👤 HUMAN PLAYER!)' : '(AI player)'}`);
        }
        
        // Use 70% of armies for attack
        const attackingArmies = Math.floor(attackingTerritory.armySize * 0.7);
        const defendingArmies = defendingTerritory.armySize;
        
        // Battle calculation
        const attackPower = attackingArmies * (0.8 + Math.random() * 0.4);
        const defensePower = defendingArmies * (1.0 + Math.random() * 0.2);
        
        if (attackPower > defensePower) {
            // Attack successful
            const survivingArmies = Math.max(1, attackingArmies - defendingArmies);
            
            // Debug: Log successful throne attacks
            if (defendingTerritory.isThronestar) {
                console.log(`🏆 THRONE ATTACK SUCCESSFUL! ${this.name} captures throne star ${defendingTerritory.id} from ${oldOwnerId}`);
            }
            
            // Check if this is a throne star capture
            if (defendingTerritory.isThronestar && oldOwnerId !== null && gameMap.players && gameMap.players[oldOwnerId]) {
                const oldOwner = gameMap.players[oldOwnerId];
                // THRONE STAR CAPTURED! Transfer ALL remaining territories
                console.log(`🏆 THRONE STAR CAPTURED! ${oldOwner.name}'s empire falls to ${this.name}!`);
                console.log(`Transferring ${oldOwner.territories.length} territories from ${oldOwner.name} to ${this.name}`);
                
                // Special alert if human player's throne is captured (by AI)
                const isHumanPlayer = oldOwner && (oldOwner.type === 'human' || oldOwner.id === 0);
                if (isHumanPlayer) {
                    console.log(`💀 HUMAN PLAYER'S THRONE STAR CAPTURED! Game should end!`);
                    console.log(`TRIGGERING GAME END: Human player ${oldOwner.name} (ID: ${oldOwner.id}) defeated by ${this.name}`);
                    if (gameMap.game) {
                        gameMap.game.gameState = 'ended';
                        gameMap.game.showMessage(`💀 Your empire has fallen! ${this.name} captured your throne star!`, 10000);
                        // Force UI to show game over screen
                        if (gameMap.game.ui) {
                            gameMap.game.ui.showGameOver = true;
                        }
                    }
                }
                
                // Transfer all territories from old owner to attacker
                const territoriesToTransfer = [...oldOwner.territories];
                territoriesToTransfer.forEach(territoryId => {
                    const territory = gameMap.territories[territoryId];
                    if (territory && territory.ownerId === oldOwnerId) {
                        territory.ownerId = this.id;
                        this.territories.push(territoryId);
                    }
                });
                
                // Clear old owner's territories
                oldOwner.territories = [];
                oldOwner.isEliminated = true;
                this.territoriesConquered += territoriesToTransfer.length;
                
                // Destroy the captured throne star (no empire should have multiple thrones)
                defendingTerritory.isThronestar = false;
                defendingTerritory.ownerId = this.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= attackingArmies;
                
                console.log(`👑 Throne star destroyed after capture - no duplicate thrones allowed`);
            } else {
                // Normal territory capture
                defendingTerritory.ownerId = this.id;
                defendingTerritory.armySize = survivingArmies;
                attackingTerritory.armySize -= attackingArmies;
                
                // Update player territories
                this.territories.push(defendingTerritory.id);
                this.territoriesConquered++;
                
                // Remove from old owner
                if (oldOwnerId !== null && gameMap.players && gameMap.players[oldOwnerId]) {
                    const oldOwner = gameMap.players[oldOwnerId];
                    const index = oldOwner.territories.indexOf(defendingTerritory.id);
                    if (index > -1) {
                        oldOwner.territories.splice(index, 1);
                        oldOwner.battlesLost++;
                    }
                }
            }
            
            this.battlesWon++;
        } else {
            // Attack failed
            const survivingDefenders = Math.max(1, defendingArmies - Math.floor(attackingArmies * 0.7));
            const survivingAttackers = Math.max(1, Math.floor(attackingArmies * 0.3));
            
            defendingTerritory.armySize = survivingDefenders;
            attackingTerritory.armySize = attackingTerritory.armySize - attackingArmies + survivingAttackers;
            
            // Debug: Log failed throne attacks
            if (defendingTerritory.isThronestar) {
                console.log(`❌ THRONE ATTACK FAILED! ${this.name} failed to capture throne star ${defendingTerritory.id} from ${oldOwnerId}`);
                console.log(`Attack Power: ${attackPower.toFixed(1)} vs Defense Power: ${defensePower.toFixed(1)}`);
            }
            
            this.battlesLost++;
            this.armiesLost += (attackingArmies - survivingAttackers);
        }
        
        this.lastActivity = Date.now();
    }
    
    // Get player statistics for leaderboard
    getStats() {
        return {
            id: this.id,
            name: this.name,
            color: this.color,
            territories: this.territories.length,
            totalArmies: this.totalArmies,
            score: this.score,
            isEliminated: this.isEliminated,
            territoriesConquered: this.territoriesConquered,
            battlesWon: this.battlesWon,
            battlesLost: this.battlesLost,
            winRate: this.battlesWon + this.battlesLost > 0 ? 
                     (this.battlesWon / (this.battlesWon + this.battlesLost) * 100).toFixed(1) : '0.0'
        };
    }
    
    // Serialize player data for network transmission (future multiplayer)
    serialize() {
        return {
            id: this.id,
            name: this.name,
            color: this.color,
            type: this.type,
            territories: this.territories,
            totalArmies: this.totalArmies,
            isEliminated: this.isEliminated,
            score: this.score,
            territoriesConquered: this.territoriesConquered,
            battlesWon: this.battlesWon,
            battlesLost: this.battlesLost
        };
    }
    
    considerProbeColonization(attackableTerritories, gameMap) {
        // Find territories with enough fleet power for probes (need 10+ armies)
        const probeCapableTerritories = attackableTerritories.filter(t => t.armySize >= 15); // Keep some buffer
        
        if (probeCapableTerritories.length === 0) return false;
        
        // Find visible colonizable planets (within reasonable distance)
        const colonizableTargets = [];
        
        for (const territory of probeCapableTerritories) {
            // Look for colonizable planets within a reasonable range
            Object.values(gameMap.territories).forEach(target => {
                if (target.isColonizable && target.ownerId === null) {
                    const distance = Math.sqrt(
                        (territory.x - target.x) ** 2 + (territory.y - target.y) ** 2
                    );
                    
                    // Only consider colonizable planets within reasonable probe range
                    if (distance < 300) { // Adjust range as needed
                        colonizableTargets.push({
                            from: territory,
                            to: target,
                            distance: distance,
                            strategicValue: this.calculateColonizationValue(target, gameMap)
                        });
                    }
                }
            });
        }
        
        if (colonizableTargets.length === 0) return false;
        
        // Sort by strategic value and distance
        colonizableTargets.sort((a, b) => {
            const scoreA = a.strategicValue - (a.distance * 0.001);
            const scoreB = b.strategicValue - (b.distance * 0.001);
            return scoreB - scoreA;
        });
        
        // Launch probe to best target
        const bestTarget = colonizableTargets[0];
        if (gameMap.game && gameMap.game.launchAIProbe) {
            gameMap.game.launchAIProbe(bestTarget.from, bestTarget.to, this);
            return true;
        }
        
        return false;
    }
    
    calculateColonizationValue(territory, gameMap) {
        let value = 1;
        
        // Higher value for territories that would connect to our existing territories
        const nearbyOwned = territory.hiddenNeighbors.filter(id => {
            const neighbor = gameMap.territories[id];
            return neighbor && neighbor.ownerId === this.id;
        }).length;
        
        value += nearbyOwned * 2; // High value for connecting territories
        
        // Value based on potential connections
        value += territory.hiddenNeighbors.length * 0.2;
        
        return value;
    }

    // Enhanced AI state machine methods for strategic behavior
    evaluateAndTransitionState(gameMap) {
        if (this.type !== 'ai' || !this.aiState) return;
        
        const totalTerritories = Object.keys(gameMap.territories).length;
        const ownedTerritoryCount = this.territories.length;
        const territoryPercent = ownedTerritoryCount / totalTerritories;
        
        const timeSinceLastTransition = Date.now() - (this.lastStateTransition || 0);
        const minTransitionTime = 5000; // Minimum 5 seconds between transitions
        
        if (timeSinceLastTransition < minTransitionTime) return;
        
        let newState = this.aiState;
        
        // State transition logic based on game situation
        if (territoryPercent > 0.3) {
            newState = AI_STATE.AGGRESSIVE_ATTACK;
        } else if (ownedTerritoryCount > 5 && territoryPercent > 0.15) {
            newState = AI_STATE.CONSOLIDATING;
        } else if (ownedTerritoryCount < 3) {
            newState = AI_STATE.EARLY_GAME_EXPANSION;
        } else {
            // Analyze threat level for defensive posturing
            const threatenedTerritories = this.countThreatenedTerritories(gameMap);
            if (threatenedTerritories > ownedTerritoryCount * 0.4) {
                newState = AI_STATE.DEFENSIVE_POSTURING;
            }
        }
        
        if (newState !== this.aiState) {
            console.log(`AI ${this.name} transitioning from ${this.aiState} to ${newState}`);
            this.aiState = newState;
            this.lastStateTransition = Date.now();
        }
    }

    makeStrategicDecision(gameMap) {
        if (this.type !== 'ai' || !this.aiState) return;
        
        switch (this.aiState) {
            case AI_STATE.EARLY_GAME_EXPANSION:
                this.doExpansion(gameMap);
                break;
            case AI_STATE.AGGRESSIVE_ATTACK:
                this.doAggressiveAttack(gameMap);
                break;
            case AI_STATE.CONSOLIDATING:
                this.doConsolidation(gameMap);
                break;
            case AI_STATE.DEFENSIVE_POSTURING:
                this.doDefensivePosturing(gameMap);
                break;
        }
    }

    doExpansion(gameMap) {
        const ownedTerritories = this.territories
            .map(id => gameMap.territories[id])
            .filter(t => t && t.ownerId === this.id);
        
        for (const territory of ownedTerritories) {
            if (territory.armySize >= 11) { // Probe launch cost
                // Look for colonizable neighbors
                const colonizableNeighbor = territory.neighbors
                    .map(id => gameMap.territories[id])
                    .find(t => t && t.isColonizable);
                
                if (colonizableNeighbor && gameMap.game && gameMap.game.launchAIProbe) {
                    gameMap.game.launchAIProbe(territory, colonizableNeighbor, this);
                    return;
                }
            }
        }
    }

    doAggressiveAttack(gameMap) {
        const ownedTerritories = this.territories
            .map(id => gameMap.territories[id])
            .filter(t => t && t.ownerId === this.id)
            .sort((a, b) => b.armySize - a.armySize); // Attack with strongest territories first
        
        for (const territory of ownedTerritories) {
            if (territory.armySize > 5) {
                const weakEnemyNeighbor = territory.neighbors
                    .map(id => gameMap.territories[id])
                    .filter(t => t && t.ownerId && t.ownerId !== this.id)
                    .sort((a, b) => a.armySize - b.armySize)[0]; // Target weakest enemy
                
                if (weakEnemyNeighbor && territory.armySize > weakEnemyNeighbor.armySize * 1.5) {
                    this.executeAttack(territory, weakEnemyNeighbor, gameMap);
                    return;
                }
            }
        }
    }

    doConsolidation(gameMap) {
        // Focus on moving armies from safe territories to border territories
        const ownedTerritories = this.territories
            .map(id => gameMap.territories[id])
            .filter(t => t && t.ownerId === this.id);
        
        const borderTerritories = ownedTerritories.filter(t => 
            t.neighbors.some(nId => {
                const neighbor = gameMap.territories[nId];
                return neighbor && neighbor.ownerId !== this.id;
            })
        );
        
        // Strengthen weakest border territories first
        const weakBorderTerritory = borderTerritories
            .sort((a, b) => a.armySize - b.armySize)[0];
        
        if (weakBorderTerritory && weakBorderTerritory.armySize < 10) {
            // Look for adjacent strong territories to transfer from
            const adjacentStrong = weakBorderTerritory.neighbors
                .map(id => gameMap.territories[id])
                .filter(t => t && t.ownerId === this.id && t.armySize > 15)
                .sort((a, b) => b.armySize - a.armySize)[0];
            
            if (adjacentStrong && gameMap.game) {
                gameMap.game.transferFleet(adjacentStrong, weakBorderTerritory);
            }
        }
    }

    doDefensivePosturing(gameMap) {
        // Focus on defending threatened territories
        const threatenedTerritories = this.getThreatenedTerritories(gameMap);
        
        for (const territory of threatenedTerritories) {
            if (territory.armySize > 8) {
                // Look for preemptive strikes against dangerous neighbors
                const dangerousNeighbor = territory.neighbors
                    .map(id => gameMap.territories[id])
                    .filter(t => t && t.ownerId && t.ownerId !== this.id)
                    .sort((a, b) => b.armySize - a.armySize)[0];
                
                if (dangerousNeighbor && territory.armySize > dangerousNeighbor.armySize * 1.1) {
                    this.executeAttack(territory, dangerousNeighbor, gameMap);
                    return;
                }
            }
        }
    }

    countThreatenedTerritories(gameMap) {
        return this.territories
            .map(id => gameMap.territories[id])
            .filter(t => t && this.isTerritoryThreatened(t, gameMap))
            .length;
    }

    getThreatenedTerritories(gameMap) {
        return this.territories
            .map(id => gameMap.territories[id])
            .filter(t => t && this.isTerritoryThreatened(t, gameMap));
    }

    isTerritoryThreatened(territory, gameMap) {
        return territory.neighbors.some(nId => {
            const neighbor = gameMap.territories[nId];
            return neighbor && neighbor.ownerId && 
                   neighbor.ownerId !== this.id && 
                   neighbor.armySize >= territory.armySize * 0.8;
        });
    }
}


================================================================================
FILE: client/src/game/Territory.js
================================================================================
export class Territory {
    constructor(id, x, y, radius = 25, isColonizable = false) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.neighbors = [];
        this.hiddenNeighbors = []; // Connections revealed after colonization
        this.ownerId = null; // null for neutral, or player ID
        this.armySize = 0;
        this.isColonizable = isColonizable; // Special planets requiring probe colonization
        
        // Visual properties
        this.baseColor = '#444444';
        this.neutralColor = isColonizable ? '#222222' : '#666666'; // Much darker for colonizable
        this.strokeColor = isColonizable ? '#444444' : '#888888'; // Different stroke for colonizable
        
        // Animation
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.lastArmyGeneration = 0;
        this.armyGenerationRate = 3000; // Generate army every 3 seconds (matches GAME_CONSTANTS)
        
        // Combat flash effect
        this.combatFlashTime = 0;
        this.combatFlashDuration = 800; // Flash for 800ms
        
        // Probe launch visual feedback
        this.probeFlashTime = 0;
        this.probeFlashDuration = 1000; // Flash for 1 second
        this.floatingText = null; // For floating "-10" text
    }
    
    addNeighbor(territoryId) {
        if (!this.neighbors.includes(territoryId)) {
            this.neighbors.push(territoryId);
        }
    }
    
    addHiddenNeighbor(territoryId) {
        if (!this.hiddenNeighbors.includes(territoryId)) {
            this.hiddenNeighbors.push(territoryId);
        }
    }
    
    revealConnections() {
        // Move hidden connections to visible neighbors when colonized
        this.neighbors.push(...this.hiddenNeighbors);
        this.hiddenNeighbors = [];
        this.isColonizable = false; // No longer colonizable
    }
    
    isNeutral() {
        return this.ownerId === null;
    }
    
    triggerCombatFlash() {
        this.combatFlashTime = Date.now();
    }
    
    triggerProbeFlash() {
        this.probeFlashTime = Date.now();
        this.floatingText = {
            text: '-10',
            startTime: Date.now(),
            duration: 1000,
            startY: this.y - this.radius - 10,
            color: '#ff4444'
        };
    }
    
    generateArmies(deltaTime, player, gameSpeed = 1.0, game = null) {
        // Neutral territories have fixed army sizes and don't generate armies
        if (this.ownerId === null) return;
        
        // Don't generate armies until a few seconds after game start to prevent initialization issues
        if (game && game.gameStartTime && (Date.now() - game.gameStartTime) < 5000) {
            return;
        }
        
        // Apply game speed multiplier to army generation timing
        const speedAdjustedDelta = deltaTime * gameSpeed;
        this.lastArmyGeneration += speedAdjustedDelta;
        
        // Calculate generation rate with discovery bonuses
        let effectiveGenerationRate = this.armyGenerationRate;
        
        // Apply planet-specific bonuses
        if (this.discoveryBonus === 'factory') {
            effectiveGenerationRate *= 0.5; // 200% speed (half the time)
        } else if (this.discoveryBonus === 'minerals') {
            effectiveGenerationRate *= 0.67; // 150% speed
        } else if (this.discoveryBonus === 'void_storm') {
            effectiveGenerationRate *= 1.33; // 75% speed
        }
        
        // Apply empire-wide nanotech bonus
        if (game && game.discoveries && game.discoveries.precursorNanotech > 0) {
            const nanotechBonus = 1 + (game.discoveries.precursorNanotech * 0.1);
            effectiveGenerationRate /= nanotechBonus;
        }
        
        if (this.lastArmyGeneration >= effectiveGenerationRate) {
            const armiesGenerated = Math.floor(this.lastArmyGeneration / effectiveGenerationRate);
            this.armySize += armiesGenerated;
            this.lastArmyGeneration = this.lastArmyGeneration % effectiveGenerationRate;
            
            if (player) {
                player.totalArmies += armiesGenerated;
            }
        }
    }
    
    render(ctx, players, selectedTerritory, gameData, hoveredTerritory = null) {
        const isSelected = selectedTerritory && selectedTerritory.id === this.id;
        const isHovered = hoveredTerritory && hoveredTerritory.id === this.id;
        
        // Determine territory color
        let fillColor = this.neutralColor;
        if (this.ownerId !== null && players[this.ownerId]) {
            fillColor = players[this.ownerId].color;
        }
        
        // Add home system flashing effect for human player
        if (gameData && gameData.humanPlayer && this.ownerId === gameData.humanPlayer.id && 
            gameData.homeSystemFlashStart && gameData.humanPlayer.territories.includes(this.id)) {
            const currentTime = Date.now();
            const elapsed = currentTime - gameData.homeSystemFlashStart;
            
            if (elapsed < gameData.homeSystemFlashDuration) {
                // Flash every 300ms for 3 seconds
                const flashCycle = Math.floor(elapsed / 300) % 2;
                if (flashCycle === 1) {
                    fillColor = '#ffffff'; // Flash to white
                }
            }
        }
        
        // Add combat flash effect
        const currentTime = Date.now();
        if (this.combatFlashTime > 0 && currentTime - this.combatFlashTime < this.combatFlashDuration) {
            const flashProgress = (currentTime - this.combatFlashTime) / this.combatFlashDuration;
            const flashIntensity = Math.sin(flashProgress * Math.PI * 6) * (1 - flashProgress);
            if (flashIntensity > 0) {
                fillColor = this.adjustColorBrightness('#ff4444', 1 + flashIntensity * 0.8);
            }
        }
        
        // Add selection highlighting
        if (isSelected) {
            // Pulsing selection effect
            this.pulsePhase += 0.1;
            const pulseIntensity = Math.sin(this.pulsePhase) * 0.3 + 0.7;
            fillColor = this.adjustColorBrightness(fillColor, pulseIntensity);
        }
        
        // Optimize rendering with batch operations
        ctx.save();
        
        // Add hover glow effect
        if (isHovered && !isSelected) {
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Draw territory circle and border in single operation
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        
        // Clear shadow for subsequent rendering
        ctx.shadowBlur = 0;
        
        // Optimize player lookup using direct access
        const player = this.ownerId ? players[this.ownerId] : null;
        const isHumanPlayer = player && player.type === 'human';
        
        // Set stroke properties based on state
        if (isSelected) {
            // Pulsating selection outline
            const pulseIntensity = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulseIntensity})`;
            ctx.lineWidth = 4;
        } else if (isHovered) {
            // Bright white hover outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
        } else if (isHumanPlayer) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
        } else {
            ctx.strokeStyle = this.strokeColor;
            ctx.lineWidth = 1;
        }
        ctx.stroke();
        
        // Action confirmation flash
        if (this.lastActionFlash && (currentTime - this.lastActionFlash) < 300) {
            const flashProgress = (currentTime - this.lastActionFlash) / 300;
            const flashIntensity = 1 - flashProgress;
            ctx.strokeStyle = `rgba(0, 255, 0, ${flashIntensity})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Add extra ring for player territories
        if (this.ownerId !== null && player) {
            // Draw outer ring for all player territories
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 4, 0, Math.PI * 2);
            
            if (isHumanPlayer) {
                // Bright cyan outer ring for human player
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 6;
            } else {
                // Player color outer ring for AI players
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 3;
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        // Draw flag for human player territories
        if (isHumanPlayer) {
            this.renderHumanFlag(ctx);
        }
        
        // Draw crown for throne star territories
        if (this.isThronestar && this.ownerId !== null) {
            this.renderCrown(ctx);
        }
        
        // Draw factory icon for Precursor Factory discoveries
        if (this.hasFactory) {
            this.renderFactoryIcon(ctx);
        }
        
        // Draw explosion animation for failed probes
        if (this.explosionTime && Date.now() - this.explosionTime < this.explosionDuration) {
            this.renderExplosion(ctx);
        }
        
        // Draw army count for neutral territories or "?" for colonizable
        if (this.ownerId === null) {
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            if (this.isColonizable) {
                // Simple yellow question mark for colonizable planets
                ctx.fillStyle = '#ffff00'; // Yellow text
                ctx.font = 'bold 16px Arial';
                
                const displayText = '?';
                ctx.fillText(displayText, this.x, this.y + 5);
                
                // Subtle pulsing border effect (reduced intensity)
                const pulseIntensity = 0.7 + 0.2 * Math.sin(Date.now() * 0.002 + this.pulsePhase);
                ctx.strokeStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                // Regular neutral territory styling
                ctx.fillStyle = '#000000'; // Black text
                ctx.strokeStyle = '#ffffff'; // White outline for contrast
                ctx.lineWidth = 2;
                
                const displayText = this.armySize.toString();
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            }
        }
        
        // Draw territory ID (for debugging)
        if (isSelected) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`T${this.id}`, this.x, this.y - this.radius - 8);
        }
        
        // Draw army count for owned territories with probe flash effect
        if (this.ownerId !== null) {
            const player = players[this.ownerId];
            if (player) {
                // Check for probe flash effect
                const currentTime = Date.now();
                const isProbeFlashing = (currentTime - this.probeFlashTime) < this.probeFlashDuration;
                
                let textColor = '#000000'; // Default black text
                if (isProbeFlashing) {
                    // Red flash effect for probe launch
                    const flashProgress = (currentTime - this.probeFlashTime) / this.probeFlashDuration;
                    const flashIntensity = Math.sin(flashProgress * Math.PI * 4) * 0.5 + 0.5;
                    textColor = `rgb(${255 * flashIntensity}, 0, 0)`;
                }
                
                ctx.fillStyle = textColor;
                ctx.strokeStyle = '#ffffff'; // White outline for better readability
                ctx.lineWidth = 2;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                
                const displayText = this.armySize.toString();
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            }
        }
        
        // Draw floating "-10" text for probe launches
        if (this.floatingText) {
            const currentTime = Date.now();
            const elapsed = currentTime - this.floatingText.startTime;
            
            if (elapsed < this.floatingText.duration) {
                const progress = elapsed / this.floatingText.duration;
                const alpha = 1 - progress;
                const yOffset = progress * 30; // Float upward
                
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    this.floatingText.text,
                    this.x,
                    this.floatingText.startY - yOffset
                );
            } else {
                this.floatingText = null; // Remove when done
            }
        }
        
        // Highlight potential targets if this territory is selected
        if (isSelected && this.ownerId !== null) {
            this.renderPotentialTargets(ctx, players);
        }
        
        ctx.restore();
    }
    
    renderHumanFlag(ctx) {
        // Small flag pole and flag for human territories
        const flagX = this.x + this.radius * 0.6;
        const flagY = this.y - this.radius * 0.8;
        const poleHeight = this.radius * 0.7;
        const flagWidth = this.radius * 0.4;
        const flagHeight = this.radius * 0.25;
        
        // Draw flag pole
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX, flagY + poleHeight);
        ctx.stroke();
        
        // Draw flag
        ctx.fillStyle = '#00ffff';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX + flagWidth, flagY + flagHeight / 2);
        ctx.lineTo(flagX, flagY + flagHeight);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Add small star on flag
        ctx.fillStyle = '#ffffff';
        ctx.font = `${Math.max(8, this.radius * 0.3)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('★', flagX + flagWidth * 0.4, flagY + flagHeight * 0.7);
    }
    
    renderCrown(ctx) {
        // Crown positioned above the planet
        const crownX = this.x;
        const crownY = this.y - this.radius - 15;
        const crownSize = Math.max(12, this.radius * 0.8);
        
        ctx.save();
        
        // Crown shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${crownSize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('👑', crownX + 1, crownY + 1);
        
        // Main crown - golden color
        ctx.fillStyle = '#FFD700';
        ctx.font = `bold ${crownSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('👑', crownX, crownY);
        
        ctx.restore();
    }
    
    renderFactoryIcon(ctx) {
        // Factory icon positioned to the right of the planet
        const factoryX = this.x + this.radius + 10;
        const factoryY = this.y;
        const factorySize = Math.max(10, this.radius * 0.6);
        
        ctx.save();
        
        // Factory shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${factorySize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('🏭', factoryX + 1, factoryY + 1);
        
        // Main factory icon - orange/industrial color
        ctx.fillStyle = '#FF8C00';
        ctx.font = `bold ${factorySize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('🏭', factoryX, factoryY);
        
        ctx.restore();
    }
    
    renderExplosion(ctx) {
        const elapsed = Date.now() - this.explosionTime;
        const progress = elapsed / this.explosionDuration;
        
        if (progress >= 1) return; // Animation finished
        
        ctx.save();
        
        // Multiple explosion rings expanding outward
        const maxRadius = this.radius * 3;
        const numRings = 3;
        
        for (let i = 0; i < numRings; i++) {
            const ringProgress = Math.max(0, progress - i * 0.2);
            const radius = ringProgress * maxRadius;
            const opacity = Math.max(0, 1 - ringProgress * 2);
            
            if (radius > 0 && opacity > 0) {
                // Orange/red explosion colors
                const colors = ['#ff4444', '#ff8800', '#ffaa00'];
                ctx.strokeStyle = colors[i % colors.length];
                ctx.globalAlpha = opacity;
                ctx.lineWidth = Math.max(1, 4 - ringProgress * 3);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Central flash effect
        if (progress < 0.3) {
            const flashOpacity = (0.3 - progress) / 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity * 0.8})`;
            ctx.globalAlpha = flashOpacity;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    renderPotentialTargets(ctx, players) {
        // Show attackable neighbors with red outline
        this.neighbors.forEach(neighborId => {
            const neighbor = this.gameMap?.territories[neighborId];
            if (neighbor && neighbor.ownerId !== this.ownerId) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(neighbor.x, neighbor.y, neighbor.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }
    
    adjustColorBrightness(hex, factor) {
        if (hex.startsWith('#')) {
            hex = hex.slice(1);
        }
        
        const num = parseInt(hex, 16);
        const r = Math.min(255, Math.floor((num >> 16) * factor));
        const g = Math.min(255, Math.floor(((num >> 8) & 0x00FF) * factor));
        const b = Math.min(255, Math.floor((num & 0x0000FF) * factor));
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    getDistanceTo(otherTerritory) {
        const dx = this.x - otherTerritory.x;
        const dy = this.y - otherTerritory.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    isNeighborOf(otherTerritory) {
        return this.neighbors.includes(otherTerritory.id);
    }
    
    // Serialize territory data for network transmission (future multiplayer)
    serialize() {
        return {
            id: this.id,
            x: this.x,
            y: this.y,
            radius: this.radius,
            neighbors: this.neighbors,
            ownerId: this.ownerId,
            armySize: this.armySize
        };
    }
    
    // Deserialize territory data from network (future multiplayer)
    static deserialize(data) {
        const territory = new Territory(data.id, data.x, data.y, data.radius);
        territory.neighbors = data.neighbors || [];
        territory.ownerId = data.ownerId;
        territory.armySize = data.armySize || 0;
        return territory;
    }
}


================================================================================
FILE: client/src/game/InputHandler.js
================================================================================
/**
 * InputHandler.js - Dedicated input processing module
 * 
 * Encapsulates all user input processing, including mouse, touch, and keyboard events.
 * Translates raw browser events into game-specific commands.
 */

import { InputStateMachine } from './InputStateMachine.js';

export class InputHandler {
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        
        // Input state
        this.mousePos = { x: 0, y: 0 };
        this.lastMousePos = { x: 0, y: 0 };
        this.isDragging = false;
        this.isDraggingForSupplyRoute = false;
        this.isProportionalDrag = false;
        this.proportionalDragStart = null;
        this.fleetPercentage = 0.5;
        this.dragStartPos = null;
        this.dragStartTime = null;
        this.dragStart = null;
        this.dragEnd = null;
        
        // Modifier keys state
        this.modifierKeys = {
            shift: false,
            ctrl: false,
            alt: false
        };
        
        // Touch state
        this.touchState = {
            activeTouches: new Map(),
            lastTouchDistance: null,
            lastPinchCenter: null,
            longPressTimer: null,
            longPressStarted: false,
            panVelocity: { x: 0, y: 0 },
            lastPanTime: 0
        };
        
        // Modifier keys
        this.modifierKeys = {
            shift: false,
            ctrl: false,
            alt: false
        };
        
        // Initialize FSM
        this.inputFSM = new InputStateMachine(game);
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
        
        // Keyboard events
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
    }
    
    handleMouseDown(e) {
        e.preventDefault();
        this.isDragging = false;
        this.isDraggingForSupplyRoute = false;
        this.isProportionalDrag = false;
        
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        
        this.dragStartPos = { ...this.mousePos };
        this.dragStartTime = Date.now();
        this.lastMousePos = { ...this.mousePos };
        
        const worldPos = this.game.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        this.dragStart = this.game.findTerritoryAt(worldPos.x, worldPos.y);
    }
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const newMousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        
        // Check for drag threshold
        if (this.dragStartPos && !this.isDragging && !this.isProportionalDrag) {
            const dragDistance = Math.sqrt(
                Math.pow(newMousePos.x - this.dragStartPos.x, 2) + 
                Math.pow(newMousePos.y - this.dragStartPos.y, 2)
            );
            
            const timeSinceDragStart = Date.now() - (this.dragStartTime || 0);
            
            if (dragDistance > 15 && timeSinceDragStart > 300) {
                this.startProportionalDrag();
            } else if (dragDistance > 10 && !this.game.selectedTerritory) {
                this.isDragging = true;
            }
        }
        
        // Handle camera panning
        if (this.isDragging && !this.isProportionalDrag) {
            const deltaX = newMousePos.x - this.lastMousePos.x;
            const deltaY = newMousePos.y - this.lastMousePos.y;
            this.game.camera.pan(-deltaX, -deltaY);
        }
        
        // Handle proportional drag
        if (this.isProportionalDrag && this.proportionalDragStart) {
            this.updateProportionalDrag(newMousePos);
        }
        
        // Update edge panning
        this.game.camera.updateEdgePanning(newMousePos.x, newMousePos.y, 16);
        
        this.lastMousePos = newMousePos;
        this.mousePos = newMousePos;
    }
    
    handleMouseUp(e) {
        const clickDuration = Date.now() - (this.dragStartTime || 0);
        const wasQuickClick = clickDuration < 300 && !this.isDragging && !this.isDraggingForSupplyRoute;
        
        const worldPos = this.game.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.game.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Debug logging for click detection
        if (!targetTerritory && wasQuickClick && this.game.selectedTerritory) {
            console.log('Empty space click detected - deselecting territory');
        }
        
        // Handle proportional fleet command
        if (this.isProportionalDrag && this.proportionalDragStart && targetTerritory) {
            this.game.executeFleetCommand(this.proportionalDragStart.territory, targetTerritory, this.fleetPercentage);
        }
        // Handle supply route creation
        else if (this.isDraggingForSupplyRoute && this.dragStart) {
            if (targetTerritory && targetTerritory.ownerId === this.game.humanPlayer?.id && targetTerritory.id !== this.dragStart.id) {
                this.game.createSupplyRoute(this.dragStart, targetTerritory);
            }
        }
        else if (e.button === 0 && (wasQuickClick || (!this.isDragging && !this.isProportionalDrag))) {
            // Check UI elements first
            if (this.game.handleUIClick(this.mousePos.x, this.mousePos.y)) {
                this.resetDragState();
                return;
            }
            
            // Skip game logic if not in playing state
            if (this.game.gameState !== 'playing') {
                this.resetDragState();
                return;
            }
            
            // Fix for territory deselection: Allow empty space clicks to deselect regardless of minor movement
            if (!targetTerritory && this.game.selectedTerritory) {
                console.log('Empty space click detected - deselecting territory via FSM');
                this.inputFSM.handleInput('leftClick', {
                    territory: null,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            } else {
                // Left click - use FSM for input handling
                this.inputFSM.handleInput('leftClick', {
                    territory: targetTerritory,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            }
        }
        else if (e.button === 2 && wasQuickClick) {
            // Right click deselection support: empty space right-click should deselect
            if (!targetTerritory && this.game.selectedTerritory) {
                console.log('Empty space right-click detected - deselecting territory via FSM');
                this.inputFSM.handleInput('leftClick', {
                    territory: null,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            } else {
                // Right click - use FSM for input handling
                this.inputFSM.handleInput('rightClick', {
                    territory: targetTerritory,
                    worldPos: worldPos,
                    screenPos: this.mousePos
                });
            }
        }
        
        this.resetDragState();
    }
    
    handleWheel(e) {
        e.preventDefault();
        
        if (!this.game.camera) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(3.0, this.game.camera.targetZoom * zoomFactor));
        this.game.camera.zoomTo(newZoom, mouseX, mouseY);
        
        console.log('Mouse wheel zoom:', Math.round(this.game.camera.targetZoom * 100) + '%');
    }
    
    handleTouchStart(e) {
        e.preventDefault();
        
        for (const touch of e.changedTouches) {
            this.touchState.activeTouches.set(touch.identifier, {
                x: touch.clientX,
                y: touch.clientY,
                startTime: Date.now()
            });
        }
        
        if (this.touchState.activeTouches.size === 1) {
            this.startLongPressTimer();
        } else if (this.touchState.activeTouches.size === 2) {
            this.clearLongPressTimer();
            this.initializePinchGesture();
        }
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        
        this.clearLongPressTimer();
        
        if (this.touchState.activeTouches.size === 1) {
            this.handleSingleTouchMove(e);
        } else if (this.touchState.activeTouches.size === 2) {
            this.handlePinchGesture(e);
        }
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        
        this.clearLongPressTimer();
        
        for (const touch of e.changedTouches) {
            const touchData = this.touchState.activeTouches.get(touch.identifier);
            if (touchData && this.touchState.activeTouches.size === 1) {
                this.handleTouchTap(touch, touchData);
            }
            this.touchState.activeTouches.delete(touch.identifier);
        }
        
        if (this.touchState.activeTouches.size === 0) {
            this.touchState.lastTouchDistance = null;
            this.touchState.lastPinchCenter = null;
        }
    }
    
    handleKeyDown(e) {
        // Track modifier keys
        this.modifierKeys.shift = e.shiftKey;
        this.modifierKeys.ctrl = e.ctrlKey;
        this.modifierKeys.alt = e.altKey;
        
        // First check if FSM handles the key
        if (this.inputFSM.handleInput('keyPress', { key: e.key })) {
            return;
        }
        
        // Handle non-FSM keys
        switch (e.key) {
            case 'r':
            case 'R':
                if (this.game.gameState === 'ended') {
                    this.game.restartGame();
                }
                break;
            case 'd':
            case 'D':
                this.game.showTouchDebug = !this.game.showTouchDebug;
                break;
            case 'm':
            case 'M':
                this.game.minimapMinimized = !this.game.minimapMinimized;
                console.log('Minimap toggled with M key:', this.game.minimapMinimized ? 'minimized' : 'maximized');
                break;
            case 'q':
            case 'Q':
                this.game.showPerformancePanel = !this.game.showPerformancePanel;
                console.log('Performance panel toggled with Q key:', this.game.showPerformancePanel ? 'shown' : 'hidden');
                break;
            case ' ':
                // Spacebar - Focus on Selected Territory
                const fsmState = this.inputFSM.getState();
                if (fsmState.selectedTerritory) {
                    this.game.camera.focusOnTerritory(fsmState.selectedTerritory);
                    console.log('Focused camera on selected territory');
                } else if (this.game.humanPlayer && this.game.humanPlayer.territories.length > 0) {
                    const firstTerritory = this.game.gameMap.territories[this.game.humanPlayer.territories[0]];
                    if (firstTerritory) {
                        this.game.camera.focusOnTerritory(firstTerritory);
                        console.log('Focused camera on first owned territory');
                    }
                }
                break;
            case 'h':
            case 'H':
                // H key - Frame all human player territories
                if (this.game.humanPlayer && this.game.humanPlayer.territories.length > 0) {
                    const playerTerritories = this.game.humanPlayer.territories.map(id => this.game.gameMap.territories[id]);
                    this.game.camera.frameRegion(playerTerritories);
                    console.log('Framed all player territories');
                }
                break;
        }
    }
    
    handleKeyUp(e) {
        // Update modifier key state
        this.modifierKeys.shift = e.shiftKey;
        this.modifierKeys.ctrl = e.ctrlKey;
        this.modifierKeys.alt = e.altKey;
    }
    
    // Helper methods
    startProportionalDrag() {
        if (this.dragStart && this.dragStart.ownerId === this.game.humanPlayer?.id) {
            this.isProportionalDrag = true;
            this.proportionalDragStart = {
                territory: this.dragStart,
                startPos: { ...this.dragStartPos }
            };
        }
    }
    
    updateProportionalDrag(mousePos) {
        const distance = Math.sqrt(
            Math.pow(mousePos.x - this.proportionalDragStart.startPos.x, 2) +
            Math.pow(mousePos.y - this.proportionalDragStart.startPos.y, 2)
        );
        
        this.fleetPercentage = Math.min(1.0, Math.max(0.1, distance / 100));
        
        const worldPos = this.game.camera.screenToWorld(mousePos.x, mousePos.y);
        this.dragEnd = this.game.findTerritoryAt(worldPos.x, worldPos.y);
    }
    
    resetDragState() {
        this.isDragging = false;
        this.isDraggingForSupplyRoute = false;
        this.isProportionalDrag = false;
        this.proportionalDragStart = null;
        this.fleetPercentage = 0.5;
        this.dragStartPos = null;
        this.dragStartTime = null;
        this.dragStart = null;
        this.dragEnd = null;
    }
    
    startLongPressTimer() {
        this.touchState.longPressTimer = setTimeout(() => {
            this.touchState.longPressStarted = true;
            this.handleLongPress();
        }, 800);
    }
    
    clearLongPressTimer() {
        if (this.touchState.longPressTimer) {
            clearTimeout(this.touchState.longPressTimer);
            this.touchState.longPressTimer = null;
        }
        this.touchState.longPressStarted = false;
    }
    
    handleLongPress() {
        // Long press logic for mobile
        console.log('Long press detected');
    }
    
    handleSingleTouchMove(e) {
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const currentPos = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
        
        if (this.lastMousePos) {
            const deltaX = currentPos.x - this.lastMousePos.x;
            const deltaY = currentPos.y - this.lastMousePos.y;
            this.game.camera.pan(-deltaX, -deltaY);
        }
        
        this.mousePos = currentPos;
        this.lastMousePos = currentPos;
    }
    
    initializePinchGesture() {
        const touches = Array.from(this.touchState.activeTouches.values());
        if (touches.length >= 2) {
            const distance = Math.sqrt(
                Math.pow(touches[0].x - touches[1].x, 2) +
                Math.pow(touches[0].y - touches[1].y, 2)
            );
            
            this.touchState.lastTouchDistance = distance;
            this.touchState.lastPinchCenter = {
                x: (touches[0].x + touches[1].x) / 2,
                y: (touches[0].y + touches[1].y) / 2
            };
        }
    }
    
    handlePinchGesture(e) {
        if (e.touches.length < 2) return;
        
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        
        const rect = this.canvas.getBoundingClientRect();
        const pos1 = {
            x: touch1.clientX - rect.left,
            y: touch1.clientY - rect.top
        };
        const pos2 = {
            x: touch2.clientX - rect.left,
            y: touch2.clientY - rect.top
        };
        
        const currentDistance = Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2)
        );
        
        if (this.touchState.lastTouchDistance && Math.abs(currentDistance - this.touchState.lastTouchDistance) > 2) {
            const zoomFactor = currentDistance / this.touchState.lastTouchDistance;
            const adjustedFactor = 1 + (zoomFactor - 1) * 1.5;
            
            const centerX = (pos1.x + pos2.x) / 2;
            const centerY = (pos1.y + pos2.y) / 2;
            
            const newZoom = Math.max(0.1, Math.min(3.0, this.game.camera.targetZoom * adjustedFactor));
            this.game.camera.zoomTo(newZoom, centerX, centerY);
        }
        
        this.touchState.lastTouchDistance = currentDistance;
    }
    
    handleTouchTap(touch, touchData) {
        const rect = this.canvas.getBoundingClientRect();
        const tapPos = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
        
        const tapDuration = Date.now() - touchData.startTime;
        const tapDistance = Math.sqrt(
            Math.pow(tapPos.x - touchData.x, 2) +
            Math.pow(tapPos.y - touchData.y, 2)
        );
        
        if (tapDuration < 500 && tapDistance < 20) {
            // Check UI elements first
            if (this.game.handleUIClick(tapPos.x, tapPos.y)) {
                return;
            }
            
            if (this.game.gameState !== 'playing') return;
            
            const worldPos = this.game.camera.screenToWorld(tapPos.x, tapPos.y);
            const targetTerritory = this.game.findTerritoryAt(worldPos.x, worldPos.y);
            
            this.inputFSM.handleInput('leftClick', {
                territory: targetTerritory,
                worldPos: worldPos,
                screenPos: tapPos
            });
        }
    }
    
    // Public interface for game engine
    getSelectedTerritory() {
        return this.inputFSM.getState().selectedTerritory;
    }
    
    getInputState() {
        return this.inputFSM.getState();
    }
    
    resetInputState() {
        this.inputFSM.reset();
        this.resetDragState();
    }
}

================================================================================
FILE: client/src/game/InputStateMachine.js
================================================================================
/**
 * Player Input Finite State Machine (FSM)
 * 
 * This FSM manages all player input interactions to eliminate ambiguity
 * and conflicts in the probe launch and territory selection systems.
 * 
 * States:
 * - Default: No territory selected, awaiting input
 * - TerritorySelected: Player owns selected territory, awaiting command
 * - ProbeTargeting: Active probe targeting mode
 * - EnemySelected: Enemy/neutral territory selected for inspection
 */

export class InputStateMachine {
    constructor(game) {
        this.game = game;
        this.currentState = 'Default';
        this.selectedTerritory = null;
        this.probeOrigin = null;
        this.stateData = {};
        
        // Cursor modes for visual feedback
        this.cursorModes = {
            'Default': 'default',
            'TerritorySelected': 'pointer',
            'ProbeTargeting': 'crosshair',
            'EnemySelected': 'help'
        };
        
        // Initialize state handlers
        this.stateHandlers = {
            'Default': new DefaultState(this),
            'TerritorySelected': new TerritorySelectedState(this),
            'ProbeTargeting': new ProbeTargetingState(this),
            'EnemySelected': new EnemySelectedState(this)
        };
        
        console.log('InputStateMachine initialized in Default state');
    }
    
    // Main input event processor
    handleInput(inputType, data) {
        const currentHandler = this.stateHandlers[this.currentState];
        if (!currentHandler) {
            console.error(`No handler for state: ${this.currentState}`);
            return false;
        }
        
        const result = currentHandler.handleInput(inputType, data);
        
        // Update cursor based on current state
        this.updateCursor();
        
        return result;
    }
    
    // State transition with logging
    transitionTo(newState, data = {}) {
        const oldState = this.currentState;
        this.currentState = newState;
        this.stateData = { ...this.stateData, ...data };
        
        console.log(`FSM: ${oldState} -> ${newState}`, data);
        
        // Notify state handlers of transition
        if (this.stateHandlers[newState]) {
            this.stateHandlers[newState].onEnter(data);
        }
        
        if (this.stateHandlers[oldState]) {
            this.stateHandlers[oldState].onExit();
        }
        
        this.updateCursor();
        this.updateUI();
    }
    
    // Get current state for external queries
    getState() {
        return {
            currentState: this.currentState,
            selectedTerritory: this.selectedTerritory,
            probeOrigin: this.probeOrigin,
            stateData: this.stateData
        };
    }
    
    // Update cursor visual feedback
    updateCursor() {
        const cursorMode = this.cursorModes[this.currentState] || 'default';
        if (this.game.canvas) {
            this.game.canvas.style.cursor = cursorMode;
        }
    }
    
    // Update UI to reflect current state
    updateUI() {
        if (this.game.ui) {
            this.game.ui.setInputState(this.getState());
        }
    }
    
    // Helper method to check if territory is valid for current context
    isValidTarget(territory, action) {
        const handler = this.stateHandlers[this.currentState];
        return handler ? handler.isValidTarget(territory, action) : false;
    }
    
    // Reset FSM to default state
    reset() {
        this.transitionTo('Default');
        this.selectedTerritory = null;
        this.probeOrigin = null;
        this.stateData = {};
    }
}

// Base State Class
class BaseState {
    constructor(fsm) {
        this.fsm = fsm;
        this.game = fsm.game;
    }
    
    handleInput(inputType, data) {
        console.warn(`Unhandled input ${inputType} in state ${this.constructor.name}`);
        return false;
    }
    
    onEnter(data) {
        // Override in subclasses
    }
    
    onExit() {
        // Override in subclasses
    }
    
    isValidTarget(territory, action) {
        return false;
    }
    
    // Helper to check if territory is owned by human player
    isOwnedByPlayer(territory) {
        return territory && territory.ownerId === this.game.humanPlayer?.id;
    }
    
    // Helper to check if territories are neighbors
    areNeighbors(territory1, territory2) {
        return territory1 && territory2 && 
               territory1.neighbors.includes(territory2.id);
    }
}

// Default State: Nothing selected
class DefaultState extends BaseState {
    handleInput(inputType, data) {
        switch (inputType) {
            case 'leftClick':
                return this.handleLeftClick(data.territory, data.worldPos);
            case 'rightClick':
                return this.handleRightClick(data.territory, data.worldPos);
            case 'keyPress':
                return this.handleKeyPress(data.key);
            default:
                return false;
        }
    }
    
    handleLeftClick(territory, worldPos) {
        if (!territory) {
            // Clicked empty space - stay in Default
            return true;
        }
        
        if (this.isOwnedByPlayer(territory)) {
            this.fsm.selectedTerritory = territory;
            this.fsm.transitionTo('TerritorySelected', { selectedTerritory: territory });
            return true;
        } else {
            // Enemy, neutral, or colonizable territory
            this.fsm.selectedTerritory = territory;
            this.fsm.transitionTo('EnemySelected', { selectedTerritory: territory });
            return true;
        }
    }
    
    handleRightClick(territory, worldPos) {
        // Right click in default state - camera drag (handled elsewhere)
        return false;
    }
    
    handleKeyPress(key) {
        // No special keys in default state
        return false;
    }
    
    isValidTarget(territory, action) {
        return true; // All territories can be selected from default
    }
}

// Territory Selected State: Player owns selected territory
class TerritorySelectedState extends BaseState {
    onEnter(data) {
        this.selectedTerritory = data.selectedTerritory;
        console.log(`Selected owned territory ${this.selectedTerritory.id} with ${this.selectedTerritory.armySize} armies`);
    }
    
    handleInput(inputType, data) {
        switch (inputType) {
            case 'leftClick':
                return this.handleLeftClick(data.territory, data.worldPos);
            case 'rightClick':
                return this.handleRightClick(data.territory, data.worldPos);
            case 'keyPress':
                return this.handleKeyPress(data.key);
            default:
                return false;
        }
    }
    
    handleLeftClick(territory, worldPos) {
        if (!territory) {
            // Clicked empty space - deselect
            this.fsm.transitionTo('Default');
            return true;
        }
        
        // Clicking same territory - keep selected (no deselect for better UX)
        if (territory.id === this.selectedTerritory.id) {
            // Stay selected to allow multiple actions
            return true;
        }
        
        // Clicking another owned territory
        if (this.isOwnedByPlayer(territory)) {
            if (this.areNeighbors(this.selectedTerritory, territory)) {
                // Fleet transfer to adjacent territory
                this.game.transferFleet(this.selectedTerritory, territory);
                // Keep territory selected for multiple transfers
                return true;
            } else {
                // Select new territory (distant owned territory)
                this.fsm.selectedTerritory = territory;
                this.fsm.transitionTo('TerritorySelected', { selectedTerritory: territory });
                return true;
            }
        }
        
        // Clicking enemy/neutral territory - attack
        if (!territory.isColonizable) {
            this.game.attackTerritory(this.selectedTerritory, territory);
            // Keep territory selected for multiple attacks
            return true;
        }
        
        // Clicking colonizable territory - select it for inspection
        this.fsm.selectedTerritory = territory;
        this.fsm.transitionTo('EnemySelected', { selectedTerritory: territory });
        return true;
    }
    
    handleRightClick(territory, worldPos) {
        console.log(`TerritorySelected: Right-click on territory ${territory?.id}, isColonizable: ${territory?.isColonizable}`);
        
        if (!territory) {
            return false; // Camera drag
        }
        
        // Right-click on colonizable planet - launch probe
        if (territory.isColonizable) {
            console.log(`Attempting probe launch: from ${this.selectedTerritory.id} (${this.selectedTerritory.armySize} armies) to ${territory.id}`);
            if (this.selectedTerritory.armySize >= 10) {
                this.game.launchProbe(this.selectedTerritory, territory);
                console.log(`Probe launched successfully via right-click`);
                // Stay in TerritorySelected to allow multiple probes
                return true;
            } else {
                this.game.showError("Need at least 10 fleet strength to launch probe");
                return true;
            }
        }
        
        return false;
    }
    
    handleKeyPress(key) {
        switch (key) {
            case 'p':
            case 'P':
                // Activate probe targeting mode
                this.fsm.probeOrigin = this.selectedTerritory;
                this.fsm.transitionTo('ProbeTargeting', { 
                    probeOrigin: this.selectedTerritory 
                });
                return true;
            case 'Escape':
                this.fsm.transitionTo('Default');
                return true;
            default:
                return false;
        }
    }
    
    isValidTarget(territory, action) {
        switch (action) {
            case 'transfer':
                return this.isOwnedByPlayer(territory) && 
                       this.areNeighbors(this.selectedTerritory, territory);
            case 'attack':
                return !this.isOwnedByPlayer(territory) && !territory.isColonizable;
            case 'probe':
                return territory.isColonizable;
            default:
                return false;
        }
    }
}

// Probe Targeting State: Active probe targeting mode
class ProbeTargetingState extends BaseState {
    onEnter(data) {
        this.probeOrigin = data.probeOrigin;
        console.log(`Entering probe targeting mode from territory ${this.probeOrigin.id}`);
        this.game.showMessage("Select a colonizable planet to probe", 3000);
    }
    
    onExit() {
        this.game.hideMessage();
    }
    
    handleInput(inputType, data) {
        switch (inputType) {
            case 'leftClick':
                return this.handleLeftClick(data.territory, data.worldPos);
            case 'rightClick':
                return this.handleRightClick(data.territory, data.worldPos);
            case 'keyPress':
                return this.handleKeyPress(data.key);
            default:
                return false;
        }
    }
    
    handleLeftClick(territory, worldPos) {
        if (!territory) {
            // Clicked empty space - stay in probe targeting
            return true;
        }
        
        if (territory.isColonizable) {
            if (this.probeOrigin.armySize >= 10) {
                this.game.launchProbe(this.probeOrigin, territory);
                // Return to territory selected state
                this.fsm.selectedTerritory = this.probeOrigin;
                this.fsm.transitionTo('TerritorySelected', { 
                    selectedTerritory: this.probeOrigin 
                });
                return true;
            } else {
                this.game.showError("Need at least 10 fleet strength to launch probe");
                return true;
            }
        } else {
            this.game.showError("Invalid probe target. Select an unexplored planet.");
            return true;
        }
    }
    
    handleRightClick(territory, worldPos) {
        // Right-click cancels probe targeting
        this.fsm.selectedTerritory = this.probeOrigin;
        this.fsm.transitionTo('TerritorySelected', { 
            selectedTerritory: this.probeOrigin 
        });
        return true;
    }
    
    handleKeyPress(key) {
        switch (key) {
            case 'Escape':
                // Cancel probe targeting
                this.fsm.selectedTerritory = this.probeOrigin;
                this.fsm.transitionTo('TerritorySelected', { 
                    selectedTerritory: this.probeOrigin 
                });
                return true;
            default:
                return false;
        }
    }
    
    isValidTarget(territory, action) {
        return action === 'probe' && territory.isColonizable;
    }
}

// Enemy Selected State: Enemy/neutral/colonizable territory selected
class EnemySelectedState extends BaseState {
    onEnter(data) {
        this.selectedTerritory = data.selectedTerritory;
        if (this.selectedTerritory.isColonizable) {
            console.log(`Selected colonizable planet ${this.selectedTerritory.id}`);
        } else {
            console.log(`Selected enemy territory ${this.selectedTerritory.id}`);
        }
    }
    
    handleInput(inputType, data) {
        switch (inputType) {
            case 'leftClick':
                return this.handleLeftClick(data.territory, data.worldPos);
            case 'rightClick':
                return this.handleRightClick(data.territory, data.worldPos);
            case 'keyPress':
                return this.handleKeyPress(data.key);
            default:
                return false;
        }
    }
    
    handleLeftClick(territory, worldPos) {
        if (!territory) {
            // Clicked empty space - deselect
            this.fsm.transitionTo('Default');
            return true;
        }
        
        // Any click selects new territory (transition based on ownership)
        if (this.isOwnedByPlayer(territory)) {
            this.fsm.selectedTerritory = territory;
            this.fsm.transitionTo('TerritorySelected', { selectedTerritory: territory });
            return true;
        } else {
            this.fsm.selectedTerritory = territory;
            this.fsm.transitionTo('EnemySelected', { selectedTerritory: territory });
            return true;
        }
    }
    
    handleRightClick(territory, worldPos) {
        // Right-click in enemy selected - camera drag
        return false;
    }
    
    handleKeyPress(key) {
        switch (key) {
            case 'Escape':
                this.fsm.transitionTo('Default');
                return true;
            default:
                return false;
        }
    }
    
    isValidTarget(territory, action) {
        return false; // No actions available from enemy selected state
    }
}

================================================================================
FILE: client/src/game/CombatSystem.js
================================================================================
/**
 * CombatSystem.js - Combat resolution module
 * 
 * Contains all logic related to resolving conflicts between players.
 * Encapsulates combat mechanics for easier balancing and modification.
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants.ts';

export class CombatSystem {
    constructor(game) {
        this.game = game;
    }
    
    attackTerritory(fromTerritory, toTerritory) {
        if (!this.validateAttack(fromTerritory, toTerritory)) {
            return false;
        }
        
        const attackingPlayer = this.game.players.find(p => p.id === fromTerritory.ownerId);
        const defendingPlayer = toTerritory.ownerId ? 
            this.game.players.find(p => p.id === toTerritory.ownerId) : null;
        
        // Calculate attacking force
        const attackingArmies = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.ATTACK_TRANSFER_RATIO);
        
        if (attackingArmies < GAME_CONSTANTS.MIN_ATTACK_ARMY_SIZE) {
            console.log('Not enough armies to attack!');
            return false;
        }
        
        // Apply discovery bonuses
        const attackBonus = this.calculateAttackBonus(attackingPlayer);
        const defenseBonus = this.calculateDefenseBonus(defendingPlayer);
        
        // Calculate combat result
        const combatResult = this.resolveCombat(
            attackingArmies, 
            toTerritory.armySize, 
            attackBonus, 
            defenseBonus
        );
        
        // Apply combat result
        fromTerritory.armySize -= attackingArmies;
        
        if (combatResult.victory) {
            // Attacker wins
            this.handleVictoriousAttack(
                fromTerritory, toTerritory, 
                attackingPlayer, defendingPlayer,
                combatResult.survivingArmies
            );
        } else {
            // Defender wins
            this.handleFailedAttack(fromTerritory, toTerritory, combatResult.survivingArmies);
        }
        
        // Visual feedback
        this.triggerCombatFlash(toTerritory);
        this.createFloatingDamageText(toTerritory, combatResult);
        
        // Check for throne star capture - CRITICAL FIX
        if (combatResult.victory && toTerritory.isThronestar) {
            console.log(`🏆 THRONE STAR CAPTURE DETECTED! ${attackingPlayer.name} captures ${defendingPlayer?.name}'s throne!`);
            this.handleThroneStarCapture(attackingPlayer, defendingPlayer, toTerritory);
        }
        
        // Check elimination
        this.checkPlayerElimination();
        
        // Check win conditions
        this.checkWinConditions();
        
        return true;
    }
    
    validateAttack(fromTerritory, toTerritory) {
        // Check ownership
        if (fromTerritory.ownerId !== this.game.humanPlayer?.id) {
            console.log('Cannot attack from territory you don\'t own');
            return false;
        }
        
        // Check if target is colonizable (use probes instead)
        if (toTerritory.isColonizable) {
            console.log('Cannot attack colonizable planets - use probes instead');
            return false;
        }
        
        // Check adjacency
        if (!fromTerritory.neighbors.includes(toTerritory.id)) {
            console.log('Territories must be adjacent to attack');
            return false;
        }
        
        // Check self-attack
        if (fromTerritory.ownerId === toTerritory.ownerId) {
            console.log('Cannot attack your own territory');
            return false;
        }
        
        // Check minimum army requirement
        const attackingArmies = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.ATTACK_TRANSFER_RATIO);
        if (attackingArmies < GAME_CONSTANTS.MIN_ATTACK_ARMY_SIZE) {
            console.log('Need at least 2 armies to attack');
            return false;
        }
        
        return true;
    }
    
    resolveCombat(attackingArmies, defendingArmies, attackBonus = 0, defenseBonus = 0) {
        // Calculate effective combat strength
        const baseAttackPower = attackingArmies * GAME_CONSTANTS.ATTACK_POWER_BASE_MULTIPLIER;
        const randomAttackModifier = Math.random() * GAME_CONSTANTS.ATTACK_POWER_RANDOM_RANGE;
        const attackPower = (baseAttackPower + randomAttackModifier) * (1 + attackBonus / 100);
        
        const baseDefensePower = defendingArmies * GAME_CONSTANTS.DEFENSE_POWER_BASE_MULTIPLIER;
        const randomDefenseModifier = Math.random() * GAME_CONSTANTS.DEFENSE_POWER_RANDOM_RANGE;
        const defensePower = (baseDefensePower + randomDefenseModifier) * (1 + defenseBonus / 100);
        
        console.log(`Combat: Attack ${attackPower.toFixed(1)} vs Defense ${defensePower.toFixed(1)}`);
        
        const victory = attackPower > defensePower;
        const powerDifference = Math.abs(attackPower - defensePower);
        
        // Calculate survivors based on power difference
        let survivingArmies;
        if (victory) {
            // Attacker wins - survivors proportional to excess power
            const casualtyRate = Math.min(0.8, defensePower / attackPower);
            survivingArmies = Math.max(1, Math.floor(attackingArmies * (1 - casualtyRate)));
        } else {
            // Defender wins - survivors based on defense efficiency
            const casualtyRate = Math.min(0.9, attackPower / defensePower);
            survivingArmies = Math.max(0, Math.floor(defendingArmies * (1 - casualtyRate)));
        }
        
        return {
            victory,
            survivingArmies,
            attackPower,
            defensePower,
            powerDifference
        };
    }
    
    calculateAttackBonus(player) {
        if (!player) return 0;
        
        let bonus = 0;
        
        // Check for Precursor Weapons discovery
        if (this.game.discoveries) {
            const weaponsDiscoveries = this.game.discoveries.filter(d => 
                d.playerId === player.id && d.type === 'precursor_weapons'
            );
            bonus += weaponsDiscoveries.length * 10; // +10% per level
        }
        
        return bonus;
    }
    
    calculateDefenseBonus(player) {
        if (!player) return 0;
        
        let bonus = 0;
        
        // Check for Precursor Shield discovery
        if (this.game.discoveries) {
            const shieldDiscoveries = this.game.discoveries.filter(d => 
                d.playerId === player.id && d.type === 'precursor_shield'
            );
            bonus += shieldDiscoveries.length * 10; // +10% per level
        }
        
        return bonus;
    }
    
    handleVictoriousAttack(fromTerritory, toTerritory, attackingPlayer, defendingPlayer, survivingArmies) {
        console.log(`${attackingPlayer.name} captures territory ${toTerritory.id}`);
        
        // CRITICAL: Check for throne star capture BEFORE any territory transfers!
        console.log(`DEBUG: Throne check - isThronestar: ${toTerritory.isThronestar}, defendingPlayer: ${defendingPlayer ? defendingPlayer.name : 'null'}, defendingPlayer.type: ${defendingPlayer ? defendingPlayer.type : 'null'}`);
        if (toTerritory.isThronestar && defendingPlayer) {
            console.log(`👑 THRONE STAR CAPTURED! ${attackingPlayer.name} conquers ${defendingPlayer.name}'s empire!`);
            
            // Transfer ALL remaining territories from defender to attacker
            const defendingTerritories = [...defendingPlayer.territories];
            for (const territoryId of defendingTerritories) {
                const territory = this.game.gameMap.territories[territoryId];
                if (territory && territory.id !== toTerritory.id) { // Skip the throne being captured
                    // Remove from defender
                    const defenderIndex = defendingPlayer.territories.indexOf(territoryId);
                    if (defenderIndex > -1) {
                        defendingPlayer.territories.splice(defenderIndex, 1);
                    }
                    
                    // Transfer to attacker
                    territory.ownerId = attackingPlayer.id;
                    territory.baseColor = attackingPlayer.color;
                    territory.strokeColor = attackingPlayer.color;
                    attackingPlayer.territories.push(territoryId);
                    
                    console.log(`Territory ${territoryId} transferred to ${attackingPlayer.name}`);
                }
            }
            
            // CRITICAL FIX: Clear ALL remaining territories from defending player to trigger game over
            defendingPlayer.territories = [];
            
            // Mark defender as eliminated
            defendingPlayer.isEliminated = true;
            console.log(`${defendingPlayer.name} has been eliminated!`);
            
            // Special handling if human player's throne is captured
            if (defendingPlayer.type === 'human') {
                console.log(`💀 HUMAN PLAYER'S THRONE STAR CAPTURED! Game over triggered!`);
                this.game.gameState = 'ended';
            }
            
            // Destroy the captured throne star to prevent multiple thrones
            toTerritory.isThronestar = false;
            console.log(`Throne star ${toTerritory.id} destroyed`);
        }
        
        // Remove territory from defender
        if (defendingPlayer) {
            const territoryIndex = defendingPlayer.territories.indexOf(toTerritory.id);
            if (territoryIndex > -1) {
                defendingPlayer.territories.splice(territoryIndex, 1);
            }
        }
        
        // Transfer territory to attacker
        console.log(`DEBUG: About to transfer territory ${toTerritory.id} from ${toTerritory.ownerId} to ${attackingPlayer.id}`);
        toTerritory.ownerId = attackingPlayer.id;
        toTerritory.armySize = survivingArmies;
        attackingPlayer.territories.push(toTerritory.id);
        
        // Reveal hidden connections for newly captured territory
        if (toTerritory.hiddenNeighbors && toTerritory.hiddenNeighbors.length > 0) {
            toTerritory.neighbors.push(...toTerritory.hiddenNeighbors);
            toTerritory.hiddenNeighbors = [];
            console.log(`Hidden star lanes revealed for territory ${toTerritory.id}`);
        }
        
        // Update territory visual properties
        const player = this.game.players.find(p => p.id === toTerritory.ownerId);
        if (player) {
            toTerritory.baseColor = player.color;
            toTerritory.strokeColor = player.color;
        }
        
        // Create ship animation
        this.game.createShipAnimation(fromTerritory, toTerritory, attackingPlayer.color, 1000);
    }
    
    handleFailedAttack(fromTerritory, toTerritory, survivingDefenders) {
        console.log(`Attack on territory ${toTerritory.id} repelled`);
        
        // Update defender army count
        toTerritory.armySize = survivingDefenders;
        
        // Create failed attack animation
        const attackingPlayer = this.game.players.find(p => p.id === fromTerritory.ownerId);
        if (attackingPlayer) {
            this.game.createShipAnimation(fromTerritory, toTerritory, attackingPlayer.color, 800);
        }
    }
    
    handleThroneStarCapture(attackingPlayer, defendingPlayer) {
        if (!defendingPlayer) return;
        
        console.log(`🏆 ${attackingPlayer.name} captures ${defendingPlayer.name}'s throne star!`);
        
        // Transfer all remaining territories
        const territoriesToTransfer = [...defendingPlayer.territories];
        for (const territoryId of territoriesToTransfer) {
            const territory = this.game.gameMap.territories[territoryId];
            if (territory && territory.id !== territory.id) { // Don't transfer the throne star itself again
                territory.ownerId = attackingPlayer.id;
                attackingPlayer.territories.push(territoryId);
                
                // Update visual properties
                territory.baseColor = attackingPlayer.color;
                territory.strokeColor = attackingPlayer.color;
            }
        }
        
        // Clear defender's territories
        defendingPlayer.territories = [];
        defendingPlayer.isEliminated = true;
        
        // Destroy the captured throne star
        const throneTerritory = this.game.gameMap.territories[defendingPlayer.territories[0]];
        if (throneTerritory) {
            throneTerritory.isThronestar = false;
        }
        
        // Create dramatic visual effect
        this.game.showMessage(`👑 ${attackingPlayer.name} conquers ${defendingPlayer.name}'s empire!`, 5000);
    }
    
    triggerCombatFlash(territory) {
        territory.combatFlashTime = Date.now();
    }
    
    createFloatingDamageText(territory, combatResult) {
        const damageValue = Math.floor(combatResult.powerDifference);
        const text = combatResult.victory ? `-${damageValue}` : `+${damageValue}`;
        const color = combatResult.victory ? '#ff4444' : '#44ff44';
        
        territory.floatingText = {
            text: text,
            color: color,
            startTime: Date.now(),
            duration: 2000,
            endTime: Date.now() + 2000
        };
    }
    
    checkPlayerElimination() {
        for (const player of this.game.players) {
            if (player.territories.length === 0 && !player.isEliminated) {
                player.isEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player.id === this.game.humanPlayer?.id) {
                    this.game.showMessage('💀 You have been eliminated! The galaxy belongs to others...', 5000);
                }
            }
        }
    }
    
    checkWinConditions() {
        const activePlayers = this.game.players.filter(p => !p.isEliminated);
        
        if (activePlayers.length === 1) {
            const winner = activePlayers[0];
            this.endGame(winner);
        } else if (this.game.humanPlayer && this.game.humanPlayer.isEliminated) {
            // Human player eliminated but others still fighting
            this.game.showMessage('🎮 Game Over - You can continue spectating', 3000);
        }
    }
    
    endGame(winner) {
        this.game.gameState = 'ended';
        this.game.winner = winner;
        
        console.log(`🏆 Game Over! Winner: ${winner.name}`);
        
        if (winner.id === this.game.humanPlayer?.id) {
            this.game.showMessage('🎉 Victory! You have conquered the galaxy!', 10000);
        } else {
            this.game.showMessage(`👑 ${winner.name} conquers the galaxy!`, 10000);
        }
        
        // Stop AI updates
        this.game.stopGameLoop = true;
    }
    
    // Transfer armies between friendly territories
    transferArmies(fromTerritory, toTerritory) {
        if (!this.validateTransfer(fromTerritory, toTerritory)) {
            return false;
        }
        
        const transferAmount = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.TRANSFER_AMOUNT_RATIO);
        
        if (transferAmount < 1) {
            console.log('No armies to transfer');
            return false;
        }
        
        fromTerritory.armySize -= transferAmount;
        toTerritory.armySize += transferAmount;
        
        console.log(`Transferred ${transferAmount} armies from ${fromTerritory.id} to ${toTerritory.id}`);
        
        // Create transfer animation
        const player = this.game.players.find(p => p.id === fromTerritory.ownerId);
        if (player) {
            this.game.createShipAnimation(fromTerritory, toTerritory, player.color, 1200);
        }
        
        // Visual feedback
        toTerritory.floatingText = {
            text: `+${transferAmount}`,
            color: '#44ff44',
            startTime: Date.now(),
            duration: 2000,
            endTime: Date.now() + 2000
        };
        
        return true;
    }
    
    validateTransfer(fromTerritory, toTerritory) {
        // Check ownership
        if (fromTerritory.ownerId !== this.game.humanPlayer?.id || 
            toTerritory.ownerId !== this.game.humanPlayer?.id) {
            console.log('Can only transfer between your own territories');
            return false;
        }
        
        // Check adjacency
        if (!fromTerritory.neighbors.includes(toTerritory.id)) {
            console.log('Territories must be adjacent for transfer');
            return false;
        }
        
        // Check army availability
        const transferAmount = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.TRANSFER_AMOUNT_RATIO);
        if (transferAmount < 1) {
            console.log('Not enough armies to transfer');
            return false;
        }
        
        return true;
    }
}

================================================================================
FILE: client/src/game/SupplySystem.js
================================================================================
/**
 * SupplySystem.js - Supply route management module
 * 
 * Manages the creation, validation, and processing of supply routes.
 * Handles pathfinding and automated ship transfers between territories.
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants.ts';

export class SupplySystem {
    constructor(game) {
        this.game = game;
        this.supplyRoutes = [];
        this.routeValidationFrame = 0;
        this.routeProcessingFrame = 0;
    }
    
    createSupplyRoute(fromTerritory, toTerritory) {
        if (!this.validateSupplyRouteCreation(fromTerritory, toTerritory)) {
            return false;
        }
        
        // Check if route already exists
        const existingRoute = this.findExistingRoute(fromTerritory.id, toTerritory.id);
        if (existingRoute) {
            console.log('Supply route already exists between these territories');
            return false;
        }
        
        // Find path between territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (!path || path.length < 2) {
            console.log('No valid path found between territories');
            return false;
        }
        
        // Create new supply route
        const route = {
            id: this.generateRouteId(),
            from: fromTerritory.id,
            to: toTerritory.id,
            path: path,
            active: true,
            lastTransfer: 0,
            transferCooldown: GAME_CONSTANTS.SUPPLY_ROUTE_TRANSFER_COOLDOWN,
            createdTime: Date.now()
        };
        
        this.supplyRoutes.push(route);
        
        console.log(`Supply route created: ${fromTerritory.id} → ${toTerritory.id} (${path.length} hops)`);
        
        // Visual feedback
        this.game.showMessage(`Supply route established: ${path.length - 1} hop${path.length > 2 ? 's' : ''}`, 2000);
        
        return true;
    }
    
    validateSupplyRouteCreation(fromTerritory, toTerritory) {
        const humanPlayerId = this.game.humanPlayer?.id;
        
        // Check ownership
        if (fromTerritory.ownerId !== humanPlayerId || toTerritory.ownerId !== humanPlayerId) {
            console.log('Both territories must be owned by player to create supply route');
            return false;
        }
        
        // Check if territories are different
        if (fromTerritory.id === toTerritory.id) {
            console.log('Cannot create supply route to same territory');
            return false;
        }
        
        return true;
    }
    
    findExistingRoute(fromId, toId) {
        return this.supplyRoutes.find(route => 
            (route.from === fromId && route.to === toId) ||
            (route.from === toId && route.to === fromId)
        );
    }
    
    findPathBetweenTerritories(fromTerritory, toTerritory) {
        const humanPlayerId = this.game.humanPlayer?.id;
        const visited = new Set();
        const queue = [{
            territory: fromTerritory,
            path: [fromTerritory]
        }];
        
        visited.add(fromTerritory.id);
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            // Found target
            if (current.territory.id === toTerritory.id) {
                return current.path;
            }
            
            // Explore neighbors
            for (const neighborId of current.territory.neighbors) {
                if (visited.has(neighborId)) continue;
                
                const neighbor = this.game.gameMap.territories[neighborId];
                if (!neighbor) continue;
                
                // Only traverse through owned territories
                if (neighbor.ownerId !== humanPlayerId) continue;
                
                visited.add(neighborId);
                queue.push({
                    territory: neighbor,
                    path: [...current.path, neighbor]
                });
            }
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Throttle validation to every 45 frames
        this.routeValidationFrame++;
        if (this.routeValidationFrame < 45) return;
        this.routeValidationFrame = 0;
        
        const humanPlayerId = this.game.humanPlayer?.id;
        
        for (let i = this.supplyRoutes.length - 1; i >= 0; i--) {
            const route = this.supplyRoutes[i];
            
            // Check if territories still exist and are owned
            const fromTerritory = this.game.gameMap.territories[route.from];
            const toTerritory = this.game.gameMap.territories[route.to];
            
            if (!fromTerritory || !toTerritory ||
                fromTerritory.ownerId !== humanPlayerId ||
                toTerritory.ownerId !== humanPlayerId) {
                
                console.log(`Supply route ${route.id} invalidated - territory ownership changed`);
                this.supplyRoutes.splice(i, 1);
                continue;
            }
            
            // Validate path integrity
            if (!this.isPathValid(route.path, humanPlayerId)) {
                console.log(`Supply route ${route.id} invalidated - path broken`);
                route.active = false;
                
                // Try to find new path
                const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
                if (newPath) {
                    route.path = newPath;
                    route.active = true;
                    console.log(`Supply route ${route.id} rerouted`);
                } else {
                    this.supplyRoutes.splice(i, 1);
                }
            }
        }
    }
    
    isPathValid(path, ownerId) {
        for (const territory of path) {
            if (territory.ownerId !== ownerId) {
                return false;
            }
        }
        
        // Check path connectivity
        for (let i = 0; i < path.length - 1; i++) {
            const current = path[i];
            const next = path[i + 1];
            
            if (!current.neighbors.includes(next.id)) {
                return false;
            }
        }
        
        return true;
    }
    
    processSupplyRoutes(deltaTime) {
        // Throttle processing to every 90 frames
        this.routeProcessingFrame++;
        if (this.routeProcessingFrame < 90) return;
        this.routeProcessingFrame = 0;
        
        const currentTime = Date.now();
        
        for (const route of this.supplyRoutes) {
            if (!route.active) continue;
            
            // Check transfer cooldown
            if (currentTime - route.lastTransfer < route.transferCooldown) continue;
            
            const fromTerritory = this.game.gameMap.territories[route.from];
            const toTerritory = this.game.gameMap.territories[route.to];
            
            if (!fromTerritory || !toTerritory) continue;
            
            // Check if transfer is needed and beneficial
            if (this.shouldTransferArmies(fromTerritory, toTerritory)) {
                this.executeSupplyTransfer(route, fromTerritory, toTerritory);
                route.lastTransfer = currentTime;
            }
        }
    }
    
    shouldTransferArmies(fromTerritory, toTerritory) {
        // Transfer threshold - only if source has significantly more armies
        const transferThreshold = GAME_CONSTANTS.SUPPLY_ROUTE_TRANSFER_THRESHOLD;
        const armyDifference = fromTerritory.armySize - toTerritory.armySize;
        
        return armyDifference >= transferThreshold && fromTerritory.armySize > 10;
    }
    
    executeSupplyTransfer(route, fromTerritory, toTerritory) {
        const transferAmount = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.SUPPLY_ROUTE_TRANSFER_RATIO);
        
        if (transferAmount < 1) return;
        
        // Calculate delivery delay based on path length
        const hopsCount = route.path.length - 1;
        const deliveryDelay = hopsCount * GAME_CONSTANTS.SUPPLY_ROUTE_HOP_DELAY;
        
        // Immediate deduction from source
        fromTerritory.armySize -= transferAmount;
        
        // Schedule delayed delivery
        this.createDelayedSupplyTransfer(toTerritory, transferAmount, deliveryDelay, route);
        
        // Create multi-hop ship animation
        this.createSupplyRouteAnimation(route, transferAmount);
        
        console.log(`Supply transfer: ${transferAmount} armies via ${hopsCount} hop${hopsCount > 1 ? 's' : ''} (${deliveryDelay}ms delay)`);
    }
    
    createDelayedSupplyTransfer(toTerritory, amount, delay, route) {
        setTimeout(() => {
            // Verify territory still exists and is owned
            if (toTerritory && toTerritory.ownerId === this.game.humanPlayer?.id) {
                toTerritory.armySize += amount;
                
                // Visual feedback
                toTerritory.floatingText = {
                    text: `+${amount}`,
                    color: '#00ffff',
                    startTime: Date.now(),
                    duration: 2000,
                    endTime: Date.now() + 2000
                };
                
                console.log(`Supply delivery: +${amount} armies to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    createSupplyRouteAnimation(route, amount) {
        if (!route.path || route.path.length < 2) return;
        
        const player = this.game.humanPlayer;
        if (!player) return;
        
        // Create multi-segment animation following the supply route path
        const segments = [];
        for (let i = 0; i < route.path.length - 1; i++) {
            segments.push({
                from: { x: route.path[i].x, y: route.path[i].y },
                to: { x: route.path[i + 1].x, y: route.path[i + 1].y }
            });
        }
        
        const totalDuration = segments.length * 800; // 800ms per segment
        
        this.game.renderer.createShipAnimation(
            { x: route.path[0].x, y: route.path[0].y },
            { x: route.path[route.path.length - 1].x, y: route.path[route.path.length - 1].y },
            player.color,
            totalDuration,
            segments
        );
    }
    
    generateRouteId() {
        return `route_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Public interface
    getActiveSupplyRoutes() {
        return this.supplyRoutes.filter(route => route.active);
    }
    
    getSupplyRouteCount() {
        return this.supplyRoutes.length;
    }
    
    removeSupplyRoute(routeId) {
        const index = this.supplyRoutes.findIndex(route => route.id === routeId);
        if (index > -1) {
            this.supplyRoutes.splice(index, 1);
            console.log(`Supply route ${routeId} removed`);
            return true;
        }
        return false;
    }
    
    removeAllSupplyRoutes() {
        this.supplyRoutes = [];
        console.log('All supply routes cleared');
    }
    
    getSupplyRoutesBetween(territoryId1, territoryId2) {
        return this.supplyRoutes.filter(route => 
            (route.from === territoryId1 && route.to === territoryId2) ||
            (route.from === territoryId2 && route.to === territoryId1)
        );
    }
    
    // Debug and statistics
    getSupplyRouteStats() {
        const active = this.supplyRoutes.filter(r => r.active).length;
        const inactive = this.supplyRoutes.filter(r => !r.active).length;
        const totalPaths = this.supplyRoutes.reduce((sum, r) => sum + (r.path?.length || 0), 0);
        const avgPathLength = this.supplyRoutes.length > 0 ? totalPaths / this.supplyRoutes.length : 0;
        
        return {
            total: this.supplyRoutes.length,
            active,
            inactive,
            averagePathLength: Math.round(avgPathLength * 100) / 100
        };
    }
    
    logSupplyRouteDebug() {
        console.log('=== Supply Route Debug ===');
        console.log(`Total routes: ${this.supplyRoutes.length}`);
        
        for (const route of this.supplyRoutes) {
            const fromTerritory = this.game.gameMap.territories[route.from];
            const toTerritory = this.game.gameMap.territories[route.to];
            
            console.log(`Route ${route.id}: ${route.from} → ${route.to}`);
            console.log(`  Status: ${route.active ? 'Active' : 'Inactive'}`);
            console.log(`  Path length: ${route.path?.length || 0} territories`);
            console.log(`  From armies: ${fromTerritory?.armySize || 'N/A'}`);
            console.log(`  To armies: ${toTerritory?.armySize || 'N/A'}`);
            console.log(`  Last transfer: ${Date.now() - route.lastTransfer}ms ago`);
        }
    }
}

================================================================================
FILE: client/src/game/Camera.js
================================================================================
export class Camera {
    constructor(viewportWidth, viewportHeight) {
        this.x = 0;
        this.y = 0;
        this.zoom = 1;
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        
        // Strategic zoom constraints - Supreme Commander style
        this.minZoom = 0.05;  // Allow extreme zoom out to see entire galaxy
        this.maxZoom = 8.0;   // Allow tactical close-up
        
        // Smooth movement with inertial panning
        this.targetX = 0;
        this.targetY = 0;
        this.targetZoom = 1;
        this.smoothness = 0.15;
        
        // Inertial panning system
        this.velocityX = 0;
        this.velocityY = 0;
        this.friction = 0.92;
        this.panInertia = true;
        
        // Edge panning for RTS-style navigation
        this.edgePanSpeed = 300;
        this.edgePanBorder = 20;
        this.edgePanEnabled = true;
        
        // Pan constraints (map boundaries)
        this.mapWidth = 2000;
        this.mapHeight = 1500;
        this.boundaryPadding = 100;
    }
    
    updateViewport(width, height) {
        this.viewportWidth = width;
        this.viewportHeight = height;
    }
    
    update(deltaTime) {
        // Smooth camera movement
        const factor = Math.min(1, this.smoothness * deltaTime / 16.67); // Normalize to 60fps
        
        // Apply inertial movement
        if (this.panInertia) {
            this.targetX += this.velocityX * deltaTime / 1000;
            this.targetY += this.velocityY * deltaTime / 1000;
            
            // Apply friction
            this.velocityX *= this.friction;
            this.velocityY *= this.friction;
        }
        
        this.x += (this.targetX - this.x) * factor;
        this.y += (this.targetY - this.y) * factor;
        this.zoom += (this.targetZoom - this.zoom) * factor;
        
        // Apply constraints
        this.applyConstraints();
    }
    
    applyConstraints() {
        // Zoom constraints
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.targetZoom));
        
        // Calculate visible area
        const visibleWidth = this.viewportWidth / this.zoom;
        const visibleHeight = this.viewportHeight / this.zoom;
        
        // If the map is smaller than the viewport, center it
        if (visibleWidth >= this.mapWidth + 2 * this.boundaryPadding) {
            // Center horizontally when zoomed out enough to see entire width
            const mapCenterX = this.mapWidth / 2;
            this.x = mapCenterX - visibleWidth / 2;
            this.targetX = this.x;
        } else {
            // Normal pan constraints for width
            const minX = -this.boundaryPadding;
            const maxX = this.mapWidth + this.boundaryPadding - visibleWidth;
            this.x = Math.max(minX, Math.min(maxX, this.x));
            this.targetX = Math.max(minX, Math.min(maxX, this.targetX));
        }
        
        if (visibleHeight >= this.mapHeight + 2 * this.boundaryPadding) {
            // Center vertically when zoomed out enough to see entire height
            const mapCenterY = this.mapHeight / 2;
            this.y = mapCenterY - visibleHeight / 2;
            this.targetY = this.y;
        } else {
            // Normal pan constraints for height
            const minY = -this.boundaryPadding;
            const maxY = this.mapHeight + this.boundaryPadding - visibleHeight;
            this.y = Math.max(minY, Math.min(maxY, this.y));
            this.targetY = Math.max(minY, Math.min(maxY, this.targetY));
        }
    }
    
    pan(deltaX, deltaY) {
        const panSpeed = 1 / this.zoom;
        this.targetX += deltaX * panSpeed;
        this.targetY += deltaY * panSpeed;
        
        // Add inertial velocity for smooth continuation
        if (this.panInertia) {
            this.velocityX = deltaX * panSpeed * 12; // Multiply for momentum effect
            this.velocityY = deltaY * panSpeed * 12;
        }
    }
    
    // Edge panning for RTS-style navigation
    updateEdgePanning(mouseX, mouseY, deltaTime) {
        if (!this.edgePanEnabled) return;
        
        let edgePanX = 0;
        let edgePanY = 0;
        
        // Check edges and calculate pan direction
        if (mouseX < this.edgePanBorder) {
            edgePanX = -this.edgePanSpeed * (1 - mouseX / this.edgePanBorder);
        } else if (mouseX > this.viewportWidth - this.edgePanBorder) {
            edgePanX = this.edgePanSpeed * ((mouseX - (this.viewportWidth - this.edgePanBorder)) / this.edgePanBorder);
        }
        
        if (mouseY < this.edgePanBorder) {
            edgePanY = -this.edgePanSpeed * (1 - mouseY / this.edgePanBorder);
        } else if (mouseY > this.viewportHeight - this.edgePanBorder) {
            edgePanY = this.edgePanSpeed * ((mouseY - (this.viewportHeight - this.edgePanBorder)) / this.edgePanBorder);
        }
        
        if (edgePanX !== 0 || edgePanY !== 0) {
            const deltaTimeSec = deltaTime / 1000;
            this.targetX += edgePanX * deltaTimeSec / this.zoom;
            this.targetY += edgePanY * deltaTimeSec / this.zoom;
        }
    }
    
    zoomTo(newZoom, screenX, screenY) {
        const oldZoom = this.zoom;
        
        // Calculate minimum zoom to show full map
        const minZoomForWidth = this.viewportWidth / (this.mapWidth + this.boundaryPadding * 2);
        const minZoomForHeight = this.viewportHeight / (this.mapHeight + this.boundaryPadding * 2);
        const smartMinZoom = Math.max(minZoomForWidth, minZoomForHeight, 0.05);
        
        this.targetZoom = Math.max(smartMinZoom, Math.min(this.maxZoom, newZoom));
        
        if (screenX !== undefined && screenY !== undefined) {
            // Zoom towards a specific point
            const worldPoint = this.screenToWorld(screenX, screenY);
            
            // Calculate the new camera position to keep the world point under the screen point
            const zoomRatio = this.targetZoom / oldZoom;
            this.targetX = worldPoint.x - (screenX / this.targetZoom);
            this.targetY = worldPoint.y - (screenY / this.targetZoom);
        }
    }
    
    zoom(factor, screenX, screenY) {
        // Clamp zoom factor to prevent extreme zooming
        const clampedFactor = Math.max(0.5, Math.min(2.0, factor));
        this.zoomTo(this.targetZoom * clampedFactor, screenX, screenY);
    }
    
    centerOn(worldX, worldY) {
        this.targetX = worldX - this.viewportWidth / (2 * this.zoom);
        this.targetY = worldY - this.viewportHeight / (2 * this.zoom);
    }
    
    screenToWorld(screenX, screenY) {
        return {
            x: this.x + screenX / this.zoom,
            y: this.y + screenY / this.zoom
        };
    }
    
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }
    
    applyTransform(ctx) {
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.x, -this.y);
    }
    
    getViewBounds() {
        const visibleWidth = this.viewportWidth / this.zoom;
        const visibleHeight = this.viewportHeight / this.zoom;
        
        return {
            left: this.x,
            right: this.x + visibleWidth,
            top: this.y,
            bottom: this.y + visibleHeight,
            width: visibleWidth,
            height: visibleHeight
        };
    }
    
    isPointVisible(worldX, worldY, margin = 0) {
        const bounds = this.getViewBounds();
        return worldX >= bounds.left - margin &&
               worldX <= bounds.right + margin &&
               worldY >= bounds.top - margin &&
               worldY <= bounds.bottom + margin;
    }
    
    isRectVisible(worldX, worldY, width, height, margin = 0) {
        const bounds = this.getViewBounds();
        return !(worldX + width < bounds.left - margin ||
                 worldX > bounds.right + margin ||
                 worldY + height < bounds.top - margin ||
                 worldY > bounds.bottom + margin);
    }
    
    getScreenCenter() {
        return {
            x: this.viewportWidth / 2,
            y: this.viewportHeight / 2
        };
    }
    
    getWorldCenter() {
        const center = this.getScreenCenter();
        return this.screenToWorld(center.x, center.y);
    }
    
    // Enhanced animate to with easing and duration control
    animateTo(worldX, worldY, zoomLevel = null, duration = 1000) {
        this.targetX = worldX - this.viewportWidth / (2 * (zoomLevel || this.zoom));
        this.targetY = worldY - this.viewportHeight / (2 * (zoomLevel || this.zoom));
        
        if (zoomLevel !== null) {
            this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, zoomLevel));
        }
        
        // Adjust smoothness based on distance for natural movement
        const distance = Math.hypot(this.targetX - this.x, this.targetY - this.y);
        const originalSmoothness = this.smoothness;
        this.smoothness = Math.min(0.25, 0.08 + (distance / 2000) * 0.15);
        
        // Reset smoothness after animation
        setTimeout(() => {
            this.smoothness = originalSmoothness;
        }, duration);
    }
    
    // Focus on Selected - Spacebar hotkey functionality
    focusOnTerritory(territory, optimalZoom = null) {
        if (!territory) return;
        
        // Calculate optimal zoom if not provided
        if (optimalZoom === null) {
            // Choose zoom based on current zoom level for smart behavior
            if (this.zoom < 0.5) {
                optimalZoom = 1.2; // Zoom in from strategic view
            } else if (this.zoom > 3.0) {
                optimalZoom = 1.8; // Zoom out from tactical view
            } else {
                optimalZoom = this.zoom; // Keep current zoom
            }
        }
        
        this.animateTo(territory.x, territory.y, optimalZoom, 800);
    }
    
    // Strategic zoom level detection for UI adaptation
    getZoomLevel() {
        if (this.zoom <= 0.2) return 'strategic'; // Entire galaxy view
        if (this.zoom <= 0.8) return 'operational'; // Multi-system view
        return 'tactical'; // Close-up detail view
    }
    
    // Auto-zoom for optimal viewing of multiple territories
    frameRegion(territories, padding = 150) {
        if (!territories || territories.length === 0) return;
        
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        territories.forEach(territory => {
            minX = Math.min(minX, territory.x);
            maxX = Math.max(maxX, territory.x);
            minY = Math.min(minY, territory.y);
            maxY = Math.max(maxY, territory.y);
        });
        
        const regionWidth = maxX - minX + padding * 2;
        const regionHeight = maxY - minY + padding * 2;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        // Calculate zoom to fit the region
        const zoomX = this.viewportWidth / regionWidth;
        const zoomY = this.viewportHeight / regionHeight;
        const optimalZoom = Math.min(zoomX, zoomY, this.maxZoom * 0.7);
        
        this.animateTo(centerX, centerY, optimalZoom, 1200);
    }
    
    // Get camera state for saving/loading
    getState() {
        return {
            x: this.x,
            y: this.y,
            zoom: this.zoom,
            targetX: this.targetX,
            targetY: this.targetY,
            targetZoom: this.targetZoom
        };
    }
    
    // Restore camera state
    setState(state) {
        this.x = state.x || 0;
        this.y = state.y || 0;
        this.zoom = state.zoom || 1;
        this.targetX = state.targetX || this.x;
        this.targetY = state.targetY || this.y;
        this.targetZoom = state.targetZoom || this.zoom;
    }
    
    // Debug information
    getDebugInfo() {
        const bounds = this.getViewBounds();
        return {
            position: { x: this.x.toFixed(1), y: this.y.toFixed(1) },
            zoom: this.zoom.toFixed(2),
            target: { x: this.targetX.toFixed(1), y: this.targetY.toFixed(1) },
            targetZoom: this.targetZoom.toFixed(2),
            viewBounds: {
                left: bounds.left.toFixed(1),
                top: bounds.top.toFixed(1),
                right: bounds.right.toFixed(1),
                bottom: bounds.bottom.toFixed(1)
            }
        };
    }
}


================================================================================
FILE: client/src/game/Probe.js
================================================================================
export class Probe {
    constructor(id, fromTerritory, toTerritory, playerId, playerColor, gameSpeed = 1.0, gameMap = null, game = null) {
        this.id = id;
        this.fromTerritory = fromTerritory;
        this.toTerritory = toTerritory;
        this.playerId = playerId;
        this.playerColor = playerColor;
        this.gameMap = gameMap;
        this.game = game; // Reference to game for discovery bonuses
        
        // Position and movement
        this.x = fromTerritory.x;
        this.y = fromTerritory.y;
        this.targetX = toTerritory.x;
        this.targetY = toTerritory.y;
        
        // Calculate direction
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        this.directionX = dx / distance;
        this.directionY = dy / distance;
        this.totalDistance = distance;
        this.traveledDistance = 0;
        
        // Apply game speed multiplier to probe movement
        this.baseSpeed = 25 * gameSpeed;
        this.speed = this.baseSpeed;
        
        // Visual properties
        this.size = 4;
        this.trailPoints = [];
        this.maxTrailLength = 10;
    }
    
    update(deltaTime) {
        // Check if probe is in a nebula and adjust speed
        let currentSpeed = this.baseSpeed;
        
        // Apply Precursor Drive speed bonus (human player only)
        if (this.game && this.game.humanPlayer && this.playerId === this.game.humanPlayer.id && 
            this.game.discoveries && this.game.discoveries.precursorDrive > 0) {
            const driveBonus = 1 + (this.game.discoveries.precursorDrive * 0.2);
            currentSpeed *= driveBonus;
        }
        
        if (this.gameMap && this.gameMap.isInNebula(this.x, this.y)) {
            currentSpeed = currentSpeed / 3; // Slow to 1/3 speed in nebulas (after applying drive bonus)
        }
        
        // Move towards target
        const moveDistance = currentSpeed * (deltaTime / 1000);
        this.x += this.directionX * moveDistance;
        this.y += this.directionY * moveDistance;
        this.traveledDistance += moveDistance;
        
        // Add to trail
        this.trailPoints.push({ x: this.x, y: this.y });
        if (this.trailPoints.length > this.maxTrailLength) {
            this.trailPoints.shift();
        }
        
        // Check if reached destination
        return this.traveledDistance >= this.totalDistance;
    }
    
    render(ctx) {
        // Check if probe is in nebula for fade effect
        const inNebula = this.gameMap && this.gameMap.isInNebula(this.x, this.y);
        let baseOpacity = 1.0;
        
        if (inNebula) {
            // Create pulsing fade effect when in nebula
            const fadePhase = Date.now() * 0.003; // Slow pulsing
            baseOpacity = 0.3 + 0.4 * (Math.sin(fadePhase) + 1) * 0.5; // Fade between 0.3 and 0.7
        }
        
        // Draw trail
        if (this.trailPoints.length > 1) {
            ctx.strokeStyle = this.playerColor;
            ctx.lineWidth = 2;
            ctx.globalAlpha = baseOpacity * 0.5;
            
            ctx.beginPath();
            ctx.moveTo(this.trailPoints[0].x, this.trailPoints[0].y);
            for (let i = 1; i < this.trailPoints.length; i++) {
                ctx.lineTo(this.trailPoints[i].x, this.trailPoints[i].y);
            }
            ctx.stroke();
        }
        
        // Draw probe with fade effect
        ctx.globalAlpha = baseOpacity;
        ctx.fillStyle = this.playerColor;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Draw direction indicator
        const indicatorLength = 8;
        const endX = this.x + this.directionX * indicatorLength;
        const endY = this.y + this.directionY * indicatorLength;
        
        ctx.strokeStyle = this.playerColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Reset opacity
        ctx.globalAlpha = 1.0;
    }
    
    getProgress() {
        return Math.min(this.traveledDistance / this.totalDistance, 1.0);
    }
}

================================================================================
FILE: server/GameEngine.ts
================================================================================
import { GameState, PlayerState, TerritoryState, ProbeState, SupplyRoute, CommandType, ClientCommand, AttackTerritoryCommand, TransferArmiesCommand, LaunchProbeCommand, CreateSupplyRouteCommand, CombatResult, CommandError } from '../common/types/index.js';
import { GAME_CONSTANTS } from '../common/gameConstants.js';

export class GameEngine {
  private gameState: GameState;
  private lastUpdate: number;
  private tickRate: number;
  private gameSpeed: number;
  
  // Delta tracking for optimized network updates
  private changedTerritories: Set<number> = new Set();
  private changedPlayers: Set<string> = new Set();
  private changedProbes: boolean = false;
  
  // Public access to tick for delta tracking
  public get tick(): number {
    return this.gameState.tick;
  }

  constructor(config: { mapSize: number; tickRate?: number; gameSpeed?: number }) {
    this.tickRate = config.tickRate || 20; // 20 updates per second
    this.gameSpeed = config.gameSpeed || 1.0; // Normal speed default
    this.lastUpdate = Date.now();
    
    this.gameState = {
      territories: {},
      players: {},
      probes: [],
      supplyRoutes: [],
      gamePhase: 'lobby',
      winner: null,
      tick: 0,
      lastUpdate: this.lastUpdate
    };

    this.generateMap(config.mapSize);
  }

  private generateMap(territoryCount: number): void {
    // Generate territories using Poisson disk sampling
    const territories = this.poissonDiskSampling(territoryCount, 2000, 2000);
    
    territories.forEach((pos, index) => {
      const territory: TerritoryState = {
        id: index,
        ownerId: null,
        armySize: 0,
        x: pos.x,
        y: pos.y,
        radius: GAME_CONSTANTS.TERRITORY_RADIUS,
        neighbors: [],
        hiddenNeighbors: [],
        isColonizable: true,
        hiddenArmySize: Math.floor(Math.random() * 50) + 1,
        lastCombatFlash: 0
      };
      
      this.gameState.territories[index] = territory;
    });

    this.connectTerritories();
    console.log(`Generated ${territoryCount} territories with connections`);
  }

  private poissonDiskSampling(numSamples: number, width: number, height: number): { x: number; y: number }[] {
    const minDistance = 80;
    const maxAttempts = 30;
    const cellSize = minDistance / Math.sqrt(2);
    const gridWidth = Math.ceil(width / cellSize);
    const gridHeight = Math.ceil(height / cellSize);
    
    const grid: number[][] = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(-1));
    const points: { x: number; y: number }[] = [];
    const activeList: number[] = [];

    // Initial point
    const firstPoint = {
      x: Math.random() * width,
      y: Math.random() * height
    };
    
    points.push(firstPoint);
    activeList.push(0);
    
    const gridX = Math.floor(firstPoint.x / cellSize);
    const gridY = Math.floor(firstPoint.y / cellSize);
    grid[gridY][gridX] = 0;

    while (activeList.length > 0 && points.length < numSamples) {
      const randomIndex = Math.floor(Math.random() * activeList.length);
      const currentIndex = activeList[randomIndex];
      const currentPoint = points[currentIndex];
      
      let found = false;
      
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const angle = Math.random() * 2 * Math.PI;
        const distance = minDistance + Math.random() * minDistance;
        
        const newPoint = {
          x: currentPoint.x + Math.cos(angle) * distance,
          y: currentPoint.y + Math.sin(angle) * distance
        };
        
        if (newPoint.x >= 0 && newPoint.x < width && newPoint.y >= 0 && newPoint.y < height) {
          const newGridX = Math.floor(newPoint.x / cellSize);
          const newGridY = Math.floor(newPoint.y / cellSize);
          
          let valid = true;
          
          for (let dy = -2; dy <= 2 && valid; dy++) {
            for (let dx = -2; dx <= 2 && valid; dx++) {
              const checkX = newGridX + dx;
              const checkY = newGridY + dy;
              
              if (checkX >= 0 && checkX < gridWidth && checkY >= 0 && checkY < gridHeight) {
                const pointIndex = grid[checkY][checkX];
                if (pointIndex !== -1) {
                  const existingPoint = points[pointIndex];
                  const dist = Math.sqrt(
                    Math.pow(newPoint.x - existingPoint.x, 2) +
                    Math.pow(newPoint.y - existingPoint.y, 2)
                  );
                  if (dist < minDistance) {
                    valid = false;
                  }
                }
              }
            }
          }
          
          if (valid) {
            points.push(newPoint);
            activeList.push(points.length - 1);
            grid[newGridY][newGridX] = points.length - 1;
            found = true;
            break;
          }
        }
      }
      
      if (!found) {
        activeList.splice(randomIndex, 1);
      }
    }

    return points;
  }

  private connectTerritories(): void {
    const territories = Object.values(this.gameState.territories);
    
    for (let i = 0; i < territories.length; i++) {
      for (let j = i + 1; j < territories.length; j++) {
        const territory1 = territories[i];
        const territory2 = territories[j];
        
        const distance = Math.sqrt(
          Math.pow(territory2.x - territory1.x, 2) +
          Math.pow(territory2.y - territory1.y, 2)
        );
        
        if (distance <= GAME_CONSTANTS.CONNECTION_DISTANCE) {
          // All connections are hidden initially since all territories are colonizable
          territory1.hiddenNeighbors.push(territory2.id);
          territory2.hiddenNeighbors.push(territory1.id);
        }
      }
    }
  }

  public addPlayer(playerId: string, name: string, color: string, type: 'human' | 'ai'): void {
    const player: PlayerState = {
      id: playerId,
      name,
      color,
      type,
      territoriesOwned: 0,
      totalArmies: 0,
      isEliminated: false,
      territories: [],
      armyGenRate: 1
    };

    this.gameState.players[playerId] = player;
    console.log(`Player ${name} (${type}) added to game`);
  }

  public startGame(): void {
    this.gameState.gamePhase = 'playing';
    this.distributeStartingTerritories();
    console.log('Game started with server-authoritative engine');
  }

  private distributeStartingTerritories(): void {
    const players = Object.values(this.gameState.players);
    const territories = Object.values(this.gameState.territories);
    const availableTerritories = [...territories];
    
    // Shuffle territories
    for (let i = availableTerritories.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [availableTerritories[i], availableTerritories[j]] = [availableTerritories[j], availableTerritories[i]];
    }

    // Give each player exactly one starting territory
    players.forEach((player, index) => {
      if (index < availableTerritories.length) {
        const territory = availableTerritories[index];
        this.colonizeTerritory(territory.id, player.id, 50);
      }
    });

    this.updatePlayerStats();
  }

  private colonizeTerritory(territoryId: number, playerId: string, armySize: number): void {
    const territory = this.gameState.territories[territoryId];
    const player = this.gameState.players[playerId];
    
    if (!territory || !player) return;

    territory.ownerId = playerId;
    territory.armySize = armySize;
    territory.isColonizable = false;
    
    // Reveal hidden connections
    territory.neighbors = [...territory.hiddenNeighbors];
    territory.hiddenNeighbors = [];
    
    // Add to player's territories
    if (!player.territories.includes(territoryId)) {
      player.territories.push(territoryId);
    }
  }

  public update(deltaTime: number): void {
    if (this.gameState.gamePhase !== 'playing') return;

    this.gameState.tick++;
    this.gameState.lastUpdate = Date.now();

    // Update probes
    this.updateProbes(deltaTime);

    // Generate armies for owned territories
    this.generateArmies(deltaTime);

    // Process supply routes
    this.processSupplyRoutes(deltaTime);

    // Update AI players
    this.updateAI(deltaTime);

    // Check win conditions
    this.checkWinConditions();
  }

  private updateProbes(deltaTime: number): void {
    let probesChanged = false;
    
    for (let i = this.gameState.probes.length - 1; i >= 0; i--) {
      const probe = this.gameState.probes[i];
      const elapsed = Date.now() - probe.startTime;
      probe.progress = Math.min(1.0, elapsed / probe.duration);

      if (probe.progress >= 1.0) {
        this.completeProbeColonization(probe);
        this.gameState.probes.splice(i, 1);
        probesChanged = true;
      }
    }
    
    // Track probe changes for delta updates
    if (probesChanged) {
      this.changedProbes = true;
    }
  }

  private completeProbeColonization(probe: ProbeState): void {
    const territory = this.gameState.territories[probe.toTerritoryId];
    if (!territory || territory.ownerId !== null) return;

    this.colonizeTerritory(probe.toTerritoryId, probe.playerId, 1);
    // Track territory and player changes for delta updates
    this.changedTerritories.add(probe.toTerritoryId);
    this.changedPlayers.add(probe.playerId);
    console.log(`Probe colonized territory ${probe.toTerritoryId} for player ${probe.playerId}`);
  }

  private generateArmies(deltaTime: number): void {
    Object.values(this.gameState.territories).forEach(territory => {
      if (territory.ownerId) {
        const player = this.gameState.players[territory.ownerId];
        if (player && !player.isEliminated) {
          // Apply game speed multiplier to army generation
          const speedAdjustedDelta = deltaTime * this.gameSpeed;
          const generationChance = speedAdjustedDelta / GAME_CONSTANTS.ARMY_GENERATION_RATE;
          if (Math.random() < generationChance) {
            territory.armySize++;
            // Track territory change for delta updates
            this.changedTerritories.add(territory.id);
            this.changedPlayers.add(territory.ownerId);
          }
        }
      }
    });
  }

  private processSupplyRoutes(deltaTime: number): void {
    // Implementation for supply route processing
    // This would handle the delayed transfers between territories
  }

  private updateAI(deltaTime: number): void {
    const aiPlayers = Object.values(this.gameState.players).filter(p => p.type === 'ai' && !p.isEliminated);
    
    // Apply game speed to AI decision timing
    const speedAdjustedChance = 0.01 * this.gameSpeed;
    
    aiPlayers.forEach(player => {
      if (Math.random() < speedAdjustedChance) { // Speed-adjusted chance to take action
        this.makeAIDecision(player);
      }
    });
  }

  private makeAIDecision(player: PlayerState): void {
    const ownedTerritories = player.territories.map(id => this.gameState.territories[id]).filter(Boolean);
    
    if (ownedTerritories.length === 0) return;

    // Simple AI: try to launch probes or attack
    const randomTerritory = ownedTerritories[Math.floor(Math.random() * ownedTerritories.length)];
    
    if (randomTerritory.armySize >= GAME_CONSTANTS.PROBE_COST) {
      // Try to find a colonizable neighbor
      const colonizableNeighbors = randomTerritory.neighbors
        .map(id => this.gameState.territories[id])
        .filter(t => t && t.isColonizable && t.ownerId === null);
      
      if (colonizableNeighbors.length > 0) {
        const target = colonizableNeighbors[Math.floor(Math.random() * colonizableNeighbors.length)];
        this.executeCommand(player.id, {
          type: CommandType.LAUNCH_PROBE,
          payload: { fromTerritoryId: randomTerritory.id, toTerritoryId: target.id },
          timestamp: Date.now()
        });
      }
    }
  }

  private checkWinConditions(): void {
    const alivePlayers = Object.values(this.gameState.players).filter(p => !p.isEliminated && p.territories.length > 0);
    
    if (alivePlayers.length === 1) {
      this.gameState.gamePhase = 'ended';
      this.gameState.winner = alivePlayers[0].id;
      console.log(`Game ended. Winner: ${alivePlayers[0].name}`);
    }
  }

  private updatePlayerStats(): void {
    Object.values(this.gameState.players).forEach(player => {
      player.territoriesOwned = player.territories.length;
      player.totalArmies = player.territories
        .map(id => this.gameState.territories[id])
        .filter(Boolean)
        .reduce((sum, territory) => sum + territory.armySize, 0);
      
      if (player.territoriesOwned === 0 && !player.isEliminated) {
        player.isEliminated = true;
        console.log(`Player ${player.name} eliminated`);
      }
    });
  }

  public executeCommand(playerId: string, command: ClientCommand): CombatResult | CommandError | null {
    const player = this.gameState.players[playerId];
    if (!player || player.isEliminated) {
      return { command: command.type, reason: 'Player not found or eliminated', timestamp: Date.now() };
    }

    switch (command.type) {
      case CommandType.ATTACK_TERRITORY:
        return this.handleAttackCommand(playerId, command.payload as AttackTerritoryCommand);
      
      case CommandType.TRANSFER_ARMIES:
        return this.handleTransferCommand(playerId, command.payload as TransferArmiesCommand);
      
      case CommandType.LAUNCH_PROBE:
        return this.handleProbeCommand(playerId, command.payload as LaunchProbeCommand);
      
      case CommandType.CREATE_SUPPLY_ROUTE:
        return this.handleSupplyRouteCommand(playerId, command.payload as CreateSupplyRouteCommand);
      
      default:
        return { command: command.type, reason: 'Unknown command type', timestamp: Date.now() };
    }
  }

  private handleAttackCommand(playerId: string, payload: AttackTerritoryCommand): CombatResult | CommandError {
    const fromTerritory = this.gameState.territories[payload.fromTerritoryId];
    const toTerritory = this.gameState.territories[payload.toTerritoryId];

    // Validation
    if (!fromTerritory || !toTerritory) {
      return { command: CommandType.ATTACK_TERRITORY, reason: 'Invalid territory', timestamp: Date.now() };
    }

    if (fromTerritory.ownerId !== playerId) {
      return { command: CommandType.ATTACK_TERRITORY, reason: 'You do not own the source territory', timestamp: Date.now() };
    }

    if (!fromTerritory.neighbors.includes(toTerritory.id)) {
      return { command: CommandType.ATTACK_TERRITORY, reason: 'Territories are not adjacent', timestamp: Date.now() };
    }

    if (fromTerritory.armySize < GAME_CONSTANTS.MIN_ATTACK_ARMIES) {
      return { command: CommandType.ATTACK_TERRITORY, reason: 'Insufficient armies to attack', timestamp: Date.now() };
    }

    if (toTerritory.ownerId === playerId) {
      return { command: CommandType.ATTACK_TERRITORY, reason: 'Cannot attack your own territory', timestamp: Date.now() };
    }

    // Execute combat
    return this.resolveCombat(fromTerritory, toTerritory);
  }

  private resolveCombat(attackingTerritory: TerritoryState, defendingTerritory: TerritoryState): CombatResult {
    const attackingArmies = attackingTerritory.armySize - 1;
    const defendingArmies = defendingTerritory.armySize;

    const attackPower = attackingArmies * (0.8 + Math.random() * GAME_CONSTANTS.COMBAT_ATTACKER_MODIFIER);
    const defensePower = defendingArmies * (0.9 + Math.random() * GAME_CONSTANTS.COMBAT_DEFENDER_MODIFIER);

    defendingTerritory.lastCombatFlash = Date.now();

    if (attackPower > defensePower) {
      // Attacker wins
      const survivingArmies = Math.ceil(attackingArmies * 0.7);
      
      // Transfer ownership
      const previousOwner = defendingTerritory.ownerId;
      defendingTerritory.ownerId = attackingTerritory.ownerId;
      defendingTerritory.armySize = survivingArmies;
      attackingTerritory.armySize = 1;

      // Track territory changes for delta updates
      this.changedTerritories.add(attackingTerritory.id);
      this.changedTerritories.add(defendingTerritory.id);

      // Update player territories
      if (previousOwner) {
        const prevPlayer = this.gameState.players[previousOwner];
        if (prevPlayer) {
          const index = prevPlayer.territories.indexOf(defendingTerritory.id);
          if (index > -1) prevPlayer.territories.splice(index, 1);
          this.changedPlayers.add(previousOwner);
        }
      }

      const newOwner = this.gameState.players[attackingTerritory.ownerId!];
      if (newOwner && !newOwner.territories.includes(defendingTerritory.id)) {
        newOwner.territories.push(defendingTerritory.id);
        this.changedPlayers.add(attackingTerritory.ownerId!);
      }

      this.updatePlayerStats();

      return {
        attackerId: attackingTerritory.ownerId!,
        defenderId: previousOwner,
        fromTerritoryId: attackingTerritory.id,
        toTerritoryId: defendingTerritory.id,
        result: 'victory',
        survivingArmies,
        timestamp: Date.now()
      };
    } else {
      // Defender wins
      const survivingDefenders = Math.ceil(defendingArmies * 0.8);
      defendingTerritory.armySize = survivingDefenders;
      attackingTerritory.armySize = 1;

      // Track territory changes for delta updates
      this.changedTerritories.add(attackingTerritory.id);
      this.changedTerritories.add(defendingTerritory.id);

      return {
        attackerId: attackingTerritory.ownerId!,
        defenderId: defendingTerritory.ownerId,
        fromTerritoryId: attackingTerritory.id,
        toTerritoryId: defendingTerritory.id,
        result: 'defeat',
        survivingArmies: survivingDefenders,
        timestamp: Date.now()
      };
    }
  }

  private handleTransferCommand(playerId: string, payload: TransferArmiesCommand): CommandError | null {
    const fromTerritory = this.gameState.territories[payload.fromTerritoryId];
    const toTerritory = this.gameState.territories[payload.toTerritoryId];

    if (!fromTerritory || !toTerritory) {
      return { command: CommandType.TRANSFER_ARMIES, reason: 'Invalid territory', timestamp: Date.now() };
    }

    if (fromTerritory.ownerId !== playerId || toTerritory.ownerId !== playerId) {
      return { command: CommandType.TRANSFER_ARMIES, reason: 'You must own both territories', timestamp: Date.now() };
    }

    if (!fromTerritory.neighbors.includes(toTerritory.id)) {
      return { command: CommandType.TRANSFER_ARMIES, reason: 'Territories are not adjacent', timestamp: Date.now() };
    }

    if (fromTerritory.armySize <= 1) {
      return { command: CommandType.TRANSFER_ARMIES, reason: 'Insufficient armies to transfer', timestamp: Date.now() };
    }

    // Execute transfer
    const transferAmount = Math.floor(fromTerritory.armySize / 2);
    fromTerritory.armySize -= transferAmount;
    toTerritory.armySize += transferAmount;

    this.updatePlayerStats();
    return null;
  }

  private handleProbeCommand(playerId: string, payload: LaunchProbeCommand): CommandError | null {
    const fromTerritory = this.gameState.territories[payload.fromTerritoryId];
    const toTerritory = this.gameState.territories[payload.toTerritoryId];

    if (!fromTerritory || !toTerritory) {
      return { command: CommandType.LAUNCH_PROBE, reason: 'Invalid territory', timestamp: Date.now() };
    }

    if (fromTerritory.ownerId !== playerId) {
      return { command: CommandType.LAUNCH_PROBE, reason: 'You do not own the source territory', timestamp: Date.now() };
    }

    if (fromTerritory.armySize < GAME_CONSTANTS.PROBE_COST) {
      return { command: CommandType.LAUNCH_PROBE, reason: 'Insufficient armies for probe', timestamp: Date.now() };
    }

    if (!toTerritory.isColonizable || toTerritory.ownerId !== null) {
      return { command: CommandType.LAUNCH_PROBE, reason: 'Target territory is not colonizable', timestamp: Date.now() };
    }

    // Launch probe
    fromTerritory.armySize -= GAME_CONSTANTS.PROBE_COST;
    
    const distance = Math.sqrt(
      Math.pow(toTerritory.x - fromTerritory.x, 2) +
      Math.pow(toTerritory.y - fromTerritory.y, 2)
    );
    
    // Apply game speed multiplier to probe travel time (faster speed = shorter duration)
    const duration = (distance / GAME_CONSTANTS.PROBE_SPEED) * 1000 / this.gameSpeed;
    const player = this.gameState.players[playerId];

    const probe: ProbeState = {
      id: this.gameState.probes.length,
      fromTerritoryId: fromTerritory.id,
      toTerritoryId: toTerritory.id,
      playerId,
      playerColor: player?.color || '#ffffff',
      progress: 0,
      startTime: Date.now(),
      duration
    };

    this.gameState.probes.push(probe);
    
    // Track territory and probe changes for delta updates
    this.changedTerritories.add(fromTerritory.id);
    this.changedPlayers.add(playerId);
    this.changedProbes = true;
    
    return null;
  }

  private handleSupplyRouteCommand(playerId: string, payload: CreateSupplyRouteCommand): CommandError | null {
    // Implementation for supply route creation
    return null;
  }

  public getGameState(): GameState {
    return { ...this.gameState };
  }

  // Get delta state containing only changed elements since last tick
  public getDeltaSince(lastTick: number): Partial<GameState> {
    const delta: Partial<GameState> = {
      tick: this.gameState.tick,
      lastUpdate: this.gameState.lastUpdate,
      gamePhase: this.gameState.gamePhase,
      winner: this.gameState.winner
    };

    // Include changed territories
    if (this.changedTerritories.size > 0) {
      delta.territories = {};
      this.changedTerritories.forEach(territoryId => {
        const territory = this.gameState.territories[territoryId];
        if (territory) {
          delta.territories![territoryId] = territory;
        }
      });
    }

    // Include changed players
    if (this.changedPlayers.size > 0) {
      delta.players = {};
      this.changedPlayers.forEach(playerId => {
        const player = this.gameState.players[playerId];
        if (player) {
          delta.players![playerId] = player;
        }
      });
    }

    // Include all probes if any changed (probes are small array so send all)
    if (this.changedProbes) {
      delta.probes = [...this.gameState.probes];
    }

    // Always include supply routes for now (small data size)
    delta.supplyRoutes = [...this.gameState.supplyRoutes];

    // Clear change tracking for next delta
    this.changedTerritories.clear();
    this.changedPlayers.clear();
    this.changedProbes = false;

    return delta;
  }

  public getPlayerGameState(playerId: string): Partial<GameState> {
    // Return only information visible to this player
    // For now, return full state (could be restricted later for fog of war)
    return this.getGameState();
  }
}

================================================================================
FILE: server/gameServer.ts
================================================================================
import { Server as SocketServer } from 'socket.io';
import { Server } from 'http';
import { GameEngine } from './GameEngine.js';
import { PlayerState, GameConfig, ClientCommand, CommandType, GameStateUpdate, CombatResult, CommandError, GameState } from '../common/types/index.js';
import { GAME_CONSTANTS } from '../common/gameConstants.js';

interface Player {
  id: string;
  name: string;
  color: string;
  type: 'human' | 'ai';
  socketId?: string;
  territories: number[];
  armyGenRate: number;
  totalArmies: number;
  territoriesOwned: number;
  isEliminated: boolean;
}

interface GameRoom {
  id: string;
  name: string;
  players: Map<string, Player>;
  gameEngine: GameEngine | null;
  gameLoop: NodeJS.Timeout | null;
  isStarted: boolean;
  maxPlayers: number;
  aiPlayerCount: number;
  gameMode: 'single' | 'multiplayer';
  lastUpdate: number;
  tickRate: number;
  lastSentTick: number;
}

export class GameServer {
  private io: SocketServer;
  private rooms: Map<string, GameRoom> = new Map();
  private playerToRoom: Map<string, string> = new Map();

  constructor(server: Server) {
    this.io = new SocketServer(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });

    this.setupSocketHandlers();
  }

  private setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`Player connected: ${socket.id}`);

      // Handle creating a new game room
      socket.on('create-room', (data: { roomName: string, playerName: string, maxPlayers: number, aiCount: number }) => {
        const roomId = this.generateRoomId();
        const room: GameRoom = {
          id: roomId,
          name: data.roomName,
          players: new Map(),
          gameEngine: null,
          gameLoop: null,
          isStarted: false,
          maxPlayers: data.maxPlayers,
          aiPlayerCount: data.aiCount,
          gameMode: 'multiplayer',
          lastUpdate: Date.now(),
          tickRate: 20,
          lastSentTick: 0
        };

        this.rooms.set(roomId, room);
        this.joinRoom(socket, roomId, data.playerName);
        
        socket.emit('room-created', { roomId, room: this.getRoomInfo(room) });
      });

      // Handle joining existing room
      socket.on('join-room', (data: { roomId: string, playerName: string }) => {
        const room = this.rooms.get(data.roomId);
        if (!room) {
          socket.emit('error', { message: 'Room not found' });
          return;
        }

        if (room.players.size >= room.maxPlayers) {
          socket.emit('error', { message: 'Room is full' });
          return;
        }

        if (room.isStarted) {
          socket.emit('error', { message: 'Game already started' });
          return;
        }

        this.joinRoom(socket, data.roomId, data.playerName);
        socket.emit('room-joined', { room: this.getRoomInfo(room) });
      });

      // Handle starting single-player game
      socket.on('start-single-player', (data: { playerName: string, aiCount: number }) => {
        const roomId = this.generateRoomId();
        const room: GameRoom = {
          id: roomId,
          name: 'Single Player Game',
          players: new Map(),
          gameEngine: null,
          gameLoop: null,
          isStarted: false,
          maxPlayers: 1,
          aiPlayerCount: data.aiCount,
          gameMode: 'single',
          lastUpdate: Date.now(),
          tickRate: 20,
          lastSentTick: 0
        };

        this.rooms.set(roomId, room);
        this.joinRoom(socket, roomId, data.playerName);
        this.startGame(roomId);
        
        socket.emit('single-player-started', { roomId, room: this.getRoomInfo(room) });
      });

      // Handle secure player commands (server-authoritative)
      socket.on('player-command', (command: ClientCommand) => {
        const roomId = this.playerToRoom.get(socket.id);
        if (!roomId) return;

        const room = this.rooms.get(roomId);
        if (!room || !room.isStarted || !room.gameEngine) return;

        // Execute command through authoritative game engine
        const result = room.gameEngine.executeCommand(socket.id, command);
        
        if (result) {
          if ('command' in result) {
            // Command error
            socket.emit('command-error', result as CommandError);
          } else {
            // Combat result - broadcast to all players
            this.io.to(roomId).emit('combat-result', result as CombatResult);
          }
        }
      });

      // Handle player ready
      socket.on('player-ready', () => {
        const roomId = this.playerToRoom.get(socket.id);
        if (!roomId) return;

        const room = this.rooms.get(roomId);
        if (!room) return;

        // In multiplayer, check if all players are ready
        if (room.gameMode === 'multiplayer') {
          const allReady = Array.from(room.players.values())
            .filter(p => p.type === 'human')
            .every(p => p.socketId === socket.id); // Simplified ready check

          if (allReady && room.players.size > 0) {
            this.startGame(roomId);
          }
        }
      });

      // Handle disconnection
      socket.on('disconnect', () => {
        console.log(`Player disconnected: ${socket.id}`);
        this.handleDisconnect(socket);
      });
    });
  }

  private joinRoom(socket: any, roomId: string, playerName: string) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    const player: Player = {
      id: socket.id,
      name: playerName,
      color: this.generatePlayerColor(room.players.size),
      type: 'human',
      socketId: socket.id,
      territories: [],
      armyGenRate: 1,
      totalArmies: 0,
      territoriesOwned: 0,
      isEliminated: false
    };

    room.players.set(socket.id, player);
    this.playerToRoom.set(socket.id, roomId);
    
    socket.join(roomId);
    
    // Notify other players in the room
    socket.to(roomId).emit('player-joined', { player: this.getPlayerInfo(player) });
  }

  private startGame(roomId: string, mapSize: number = 200, gameSpeed: number = 1.0) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    room.isStarted = true;
    
    // Initialize server-authoritative game engine with game speed
    room.gameEngine = new GameEngine({ mapSize, tickRate: room.tickRate, gameSpeed });
    
    // Add all players to the game engine
    Array.from(room.players.values()).forEach(player => {
      room.gameEngine!.addPlayer(player.id, player.name, player.color, player.type);
    });
    
    // Add AI players
    for (let i = 0; i < room.aiPlayerCount; i++) {
      const aiId = `ai_${i}`;
      const aiName = this.generateAIName(i);
      const aiColor = this.generatePlayerColor(room.players.size + i);
      room.gameEngine!.addPlayer(aiId, aiName, aiColor, 'ai');
    }
    
    // Start the game
    room.gameEngine.startGame();
    
    // Start the server game loop
    this.startGameLoop(roomId);

    // Send initial game state to all players
    const gameState = room.gameEngine.getGameState();
    this.io.to(roomId).emit('game-started', { 
      gameState,
      players: Object.values(gameState.players)
    });

    console.log(`Server-authoritative game started in room ${roomId} with ${room.players.size} human players and ${room.aiPlayerCount} AI players`);
  }

  private startGameLoop(roomId: string) {
    const room = this.rooms.get(roomId);
    if (!room || !room.gameEngine) return;

    const tickInterval = 1000 / room.tickRate; // Convert to milliseconds
    let lastUpdate = Date.now();

    room.gameLoop = setInterval(() => {
      const now = Date.now();
      const deltaTime = now - lastUpdate;
      lastUpdate = now;

      // Update game engine
      room.gameEngine!.update(deltaTime);

      // Broadcast delta state updates to all players (only changed data)
      this.broadcastGameStateUpdate(
        roomId,
        room.gameEngine!.getDeltaSince(room.lastSentTick)
      );
      room.lastSentTick = room.gameEngine!.tick;

      // Check if game ended
      const currentGameState = room.gameEngine!.getGameState();
      if (currentGameState.gamePhase === 'ended') {
        this.endGame(roomId);
      }
    }, tickInterval);
  }

  private broadcastGameStateUpdate(roomId: string, delta: Partial<GameState>) {
    const update: GameStateUpdate = {
      type: 'DELTA_STATE',
      gameState: delta,
      timestamp: Date.now()
    };
    
    this.io.to(roomId).emit('game-state-update', update);
  }

  private endGame(roomId: string) {
    const room = this.rooms.get(roomId);
    if (!room || !room.gameLoop) return;

    clearInterval(room.gameLoop);
    room.gameLoop = null;
    
    console.log(`Game ended in room ${roomId}`);
  }

  private generateAIName(index: number): string {
    const firstNames = [
      'Alex', 'Blake', 'Casey', 'Dana', 'Emma', 'Felix', 'Grace', 'Hunter', 'Iris', 'Jack',
      'Kai', 'Luna', 'Max', 'Nova', 'Owen', 'Piper', 'Quinn', 'Riley', 'Sage', 'Tyler'
    ];
    
    const clanNames = [
      'StarForge', 'VoidHunters', 'NebulaRise', 'CosmicFury', 'SolarFlare', 'DarkMatter',
      'GalaxyCorp', 'NovaStrike', 'CelestialWar', 'SpaceRaiders', 'StellarWolves', 'OrbitClan'
    ];
    
    const firstName = firstNames[index % firstNames.length];
    const clanName = clanNames[Math.floor(index / firstNames.length) % clanNames.length];
    
    return `[${clanName}] ${firstName}`;
  }

  private handleGameAction(socket: any, room: GameRoom, action: string, payload: any) {
    const player = room.players.get(socket.id);
    if (!player) return;

    // Validate and process game actions
    switch (action) {
      case 'select-territory':
        // Handle territory selection
        this.broadcastGameUpdate(room.id, {
          type: 'territory-selected',
          playerId: player.id,
          territoryId: payload.territoryId
        });
        break;

      case 'launch-probe':
        // Handle probe launch
        this.broadcastGameUpdate(room.id, {
          type: 'probe-launched',
          playerId: player.id,
          fromTerritory: payload.fromTerritory,
          toTerritory: payload.toTerritory
        });
        break;

      case 'attack-territory':
        // Handle territory attack
        this.broadcastGameUpdate(room.id, {
          type: 'territory-attacked',
          playerId: player.id,
          attackingTerritory: payload.attackingTerritory,
          defendingTerritory: payload.defendingTerritory
        });
        break;

      case 'transfer-fleet':
        // Handle fleet transfer
        this.broadcastGameUpdate(room.id, {
          type: 'fleet-transferred',
          playerId: player.id,
          fromTerritory: payload.fromTerritory,
          toTerritory: payload.toTerritory
        });
        break;
    }
  }

  private broadcastGameUpdate(roomId: string, update: any) {
    this.io.to(roomId).emit('game-update', update);
  }

  private handleDisconnect(socket: any) {
    const roomId = this.playerToRoom.get(socket.id);
    if (!roomId) return;

    const room = this.rooms.get(roomId);
    if (!room) return;

    room.players.delete(socket.id);
    this.playerToRoom.delete(socket.id);

    // Notify other players
    socket.to(roomId).emit('player-left', { playerId: socket.id });

    // Clean up empty rooms
    if (room.players.size === 0) {
      this.rooms.delete(roomId);
      console.log(`Room ${roomId} deleted - no players remaining`);
    }
  }

  private generateRoomId(): string {
    return Math.random().toString(GAME_CONSTANTS.ROOM_ID_GENERATION_RADIX).substring(
        GAME_CONSTANTS.ROOM_ID_GENERATION_SUBSTRING_START, 
        GAME_CONSTANTS.ROOM_ID_GENERATION_SUBSTRING_END
    ).toUpperCase();
  }

  private generatePlayerColor(index: number): string {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
      '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
    ];
    return colors[index % colors.length];
  }

  private getRoomInfo(room: GameRoom) {
    return {
      id: room.id,
      name: room.name,
      playerCount: room.players.size,
      maxPlayers: room.maxPlayers,
      aiPlayerCount: room.aiPlayerCount,
      isStarted: room.isStarted,
      gameMode: room.gameMode,
      players: Array.from(room.players.values()).map(p => this.getPlayerInfo(p))
    };
  }

  private getPlayerInfo(player: Player) {
    return {
      id: player.id,
      name: player.name,
      color: player.color,
      type: player.type,
      territoriesOwned: player.territoriesOwned,
      totalArmies: player.totalArmies,
      isEliminated: player.isEliminated
    };
  }

  // Get room list for lobby
  public getRoomsList() {
    return Array.from(this.rooms.values())
      .filter(room => !room.isStarted && room.gameMode === 'multiplayer')
      .map(room => this.getRoomInfo(room));
  }
}

================================================================================
FILE: server/gameEngine.ts
================================================================================
// Server-side authoritative game engine containing all game logic
// This replaces client-side authority with proper server validation

import { GAME_CONSTANTS } from '../common/gameConstants.js';
import { PlayerState, TerritoryState, ProbeState, GameState, SupplyRoute, CommandType, ClientCommand } from '../common/types/index.js';

export class GameEngine {
    private gameState: GameState;
    private lastUpdate: number;
    private tickRate: number;
    private gameSpeed: number;
    private gameMap: any; // Territory map structure
    public players: Map<string, any> = new Map();

    constructor(config: { mapSize: number; aiCount: number; humanPlayers: Array<{name: string, id: string}> }) {
        this.tickRate = GAME_CONSTANTS.SERVER_TICK_RATE_MS;
        this.gameSpeed = 1.0;
        this.lastUpdate = Date.now();
        
        // Initialize game state
        this.gameState = {
            territories: {},
            players: {},
            probes: [],
            supplyRoutes: [],
            gamePhase: 'lobby',
            winner: null,
            tick: 0,
            lastUpdate: this.lastUpdate
        };

        this.generateMap(config.mapSize);
        this.initializePlayers(config.humanPlayers, config.aiCount);
        this.distributeStartingTerritories();
    }

    private generateMap(territoryCount: number): void {
        // Generate territories with colonizable planets
        for (let i = 0; i < territoryCount; i++) {
            const territory: TerritoryState = {
                id: i,
                ownerId: null,
                armySize: 0,
                x: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_WIDTH,
                y: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_HEIGHT,
                radius: GAME_CONSTANTS.TERRITORY_RADIUS,
                neighbors: [],
                hiddenNeighbors: [],
                isColonizable: true,
                hiddenArmySize: Math.floor(Math.random() * 50) + 1,
                lastCombatFlash: 0
            };
            this.gameState.territories[i] = territory;
        }

        // Connect territories based on distance
        this.connectTerritories();
    }

    private connectTerritories(): void {
        const territories = Object.values(this.gameState.territories);
        
        territories.forEach(territory => {
            territories.forEach(other => {
                if (territory.id !== other.id) {
                    const distance = Math.sqrt(
                        (territory.x - other.x) ** 2 + (territory.y - other.y) ** 2
                    );
                    
                    if (distance < GAME_CONSTANTS.CONNECTION_DISTANCE) {
                        if (territory.isColonizable) {
                            territory.hiddenNeighbors.push(other.id);
                        } else {
                            territory.neighbors.push(other.id);
                        }
                    }
                }
            });
        });
    }

    private initializePlayers(humanPlayers: Array<{name: string, id: string}>, aiCount: number): void {
        // Add human players
        humanPlayers.forEach(human => {
            const player: PlayerState = {
                id: human.id,
                name: human.name,
                color: '#00ffff', // Cyan for human
                type: 'human',
                territories: [],
                armyGenRate: 1,
                totalArmies: 0,
                territoriesOwned: 0,
                isEliminated: false
            };
            this.gameState.players[human.id] = player;
            this.players.set(human.id, player);
        });

        // Add AI players
        for (let i = 0; i < aiCount; i++) {
            const aiId = `${GAME_CONSTANTS.AI_PLAYER_ID_PREFIX}_${i}`;
            const player: PlayerState = {
                id: aiId,
                name: this.generateAIName(i),
                color: this.generatePlayerColor(i + humanPlayers.length),
                type: 'ai',
                territories: [],
                armyGenRate: 1,
                totalArmies: 0,
                territoriesOwned: 0,
                isEliminated: false
            };
            this.gameState.players[aiId] = player;
            this.players.set(aiId, player);
        }
    }

    private distributeStartingTerritories(): void {
        const players = Object.values(this.gameState.players);
        const territories = Object.values(this.gameState.territories);
        const usedTerritories: number[] = [];

        players.forEach(player => {
            // Find territory with maximum distance from others
            let bestTerritory = null;
            let bestDistance = 0;

            territories.forEach(territory => {
                if (usedTerritories.includes(territory.id)) return;

                let minDistanceToUsed = Infinity;
                usedTerritories.forEach(usedId => {
                    const used = this.gameState.territories[usedId];
                    const distance = Math.sqrt(
                        (territory.x - used.x) ** 2 + (territory.y - used.y) ** 2
                    );
                    minDistanceToUsed = Math.min(minDistanceToUsed, distance);
                });

                if (usedTerritories.length === 0 || minDistanceToUsed > bestDistance) {
                    bestTerritory = territory;
                    bestDistance = minDistanceToUsed;
                }
            });

            if (bestTerritory) {
                this.colonizeTerritory(bestTerritory.id, player.id, GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE);
                usedTerritories.push(bestTerritory.id);
            }
        });
    }

    private colonizeTerritory(territoryId: number, playerId: string, armySize: number): void {
        const territory = this.gameState.territories[territoryId];
        const player = this.gameState.players[playerId];
        
        if (!territory || !player) return;

        territory.ownerId = playerId;
        territory.armySize = armySize;
        territory.isColonizable = false;
        
        // Reveal hidden connections
        territory.neighbors = [...territory.hiddenNeighbors];
        territory.hiddenNeighbors = [];
        
        player.territories.push(territoryId);
        this.updatePlayerStats();
    }

    public startGame(): void {
        this.gameState.gamePhase = 'playing';
        console.log(`Server: Game started with ${Object.keys(this.gameState.players).length} players`);
    }

    public update(deltaTime: number): void {
        if (this.gameState.gamePhase !== 'playing') return;

        this.gameState.tick++;
        this.gameState.lastUpdate = Date.now();

        this.updateProbes(deltaTime);
        this.generateArmies(deltaTime);
        this.updateAI(deltaTime);
        this.checkWinConditions();
    }

    private updateProbes(deltaTime: number): void {
        for (let i = this.gameState.probes.length - 1; i >= 0; i--) {
            const probe = this.gameState.probes[i];
            probe.progress += deltaTime / probe.duration;

            if (probe.progress >= 1) {
                this.completeProbeColonization(probe);
                this.gameState.probes.splice(i, 1);
            }
        }
    }

    private completeProbeColonization(probe: ProbeState): void {
        const territory = this.gameState.territories[probe.toTerritoryId];
        if (territory && territory.isColonizable) {
            this.colonizeTerritory(probe.toTerritoryId, probe.playerId, GAME_CONSTANTS.INITIAL_COLONIZED_ARMY_SIZE);
            console.log(`Server: Probe colonized territory ${probe.toTerritoryId} for player ${probe.playerId}`);
        }
    }

    private generateArmies(deltaTime: number): void {
        Object.values(this.gameState.territories).forEach(territory => {
            if (territory.ownerId && !territory.isColonizable) {
                const player = this.gameState.players[territory.ownerId];
                if (player && !player.isEliminated) {
                    // Speed-adjusted army generation
                    const generationChance = (deltaTime * this.gameSpeed) / GAME_CONSTANTS.ARMY_GENERATION_RATE;
                    if (Math.random() < generationChance) {
                        territory.armySize++;
                    }
                }
            }
        });
    }

    private updateAI(deltaTime: number): void {
        const aiPlayers = Object.values(this.gameState.players).filter(p => p.type === 'ai' && !p.isEliminated);
        
        // Speed-adjusted AI decision making
        const decisionChance = (deltaTime * this.gameSpeed) / GAME_CONSTANTS.AI_DECISION_INTERVAL_MS;
        
        aiPlayers.forEach(player => {
            if (Math.random() < decisionChance) {
                this.makeAIDecision(player);
            }
        });
    }

    private makeAIDecision(player: PlayerState): void {
        const ownedTerritories = player.territories
            .map(id => this.gameState.territories[id])
            .filter(t => t && t.ownerId === player.id);

        if (ownedTerritories.length === 0) return;

        // Simple AI: try to expand or attack
        const actionTerritory = ownedTerritories.find(t => t.armySize >= GAME_CONSTANTS.PROBE_MIN_ARMY_TO_LAUNCH);
        if (!actionTerritory) return;

        // Try to launch probe to colonizable neighbor
        const colonizableNeighbor = actionTerritory.neighbors
            .map(id => this.gameState.territories[id])
            .find(t => t && t.isColonizable);

        if (colonizableNeighbor) {
            this.launchProbe(player.id, actionTerritory.id, colonizableNeighbor.id);
            return;
        }

        // Try to attack weak enemy neighbor
        const enemyNeighbor = actionTerritory.neighbors
            .map(id => this.gameState.territories[id])
            .find(t => t && t.ownerId && t.ownerId !== player.id && 
                  actionTerritory.armySize > t.armySize * GAME_CONSTANTS.AI_ATTACK_STRENGTH_MULTIPLIER);

        if (enemyNeighbor) {
            this.attackTerritory(player.id, actionTerritory.id, enemyNeighbor.id);
        }
    }

    public executeCommand(playerId: string, command: ClientCommand): boolean {
        const player = this.gameState.players[playerId];
        if (!player || player.isEliminated) return false;

        switch (command.type) {
            case CommandType.ATTACK_TERRITORY:
                return this.attackTerritory(playerId, command.payload.fromTerritoryId, command.payload.toTerritoryId);
            
            case CommandType.LAUNCH_PROBE:
                return this.launchProbe(playerId, command.payload.fromTerritoryId, command.payload.toTerritoryId);
            
            case CommandType.TRANSFER_ARMIES:
                return this.transferArmies(playerId, command.payload.fromTerritoryId, command.payload.toTerritoryId);
            
            default:
                return false;
        }
    }

    public attackTerritory(playerId: string, fromTerritoryId: number, toTerritoryId: number): boolean {
        const fromTerritory = this.gameState.territories[fromTerritoryId];
        const toTerritory = this.gameState.territories[toTerritoryId];
        const player = this.gameState.players[playerId];

        if (!fromTerritory || !toTerritory || !player ||
            fromTerritory.ownerId !== playerId ||
            fromTerritory.armySize < GAME_CONSTANTS.MIN_ATTACK_ARMIES ||
            !fromTerritory.neighbors.includes(toTerritoryId)) {
            return false;
        }

        // Combat calculation
        const attackingArmies = Math.floor(fromTerritory.armySize * GAME_CONSTANTS.ATTACKER_SURVIVAL_RATE);
        const defendingArmies = toTerritory.armySize;

        const attackPower = attackingArmies * (GAME_CONSTANTS.COMBAT_ATTACKER_MODIFIER + Math.random() * GAME_CONSTANTS.ATTACK_POWER_RANDOM_RANGE);
        const defensePower = defendingArmies * (GAME_CONSTANTS.COMBAT_DEFENDER_MODIFIER + Math.random() * GAME_CONSTANTS.DEFENSE_POWER_RANDOM_RANGE);

        if (attackPower > defensePower) {
            // Attacker wins
            const survivingArmies = Math.ceil(attackingArmies * GAME_CONSTANTS.ATTACKER_SURVIVAL_RATE);
            
            // Remove territory from previous owner
            if (toTerritory.ownerId) {
                const prevOwner = this.gameState.players[toTerritory.ownerId];
                if (prevOwner) {
                    const index = prevOwner.territories.indexOf(toTerritoryId);
                    if (index > -1) prevOwner.territories.splice(index, 1);
                }
            }
            
            // Transfer territory to attacker
            toTerritory.ownerId = playerId;
            toTerritory.armySize = survivingArmies;
            fromTerritory.armySize = GAME_CONSTANTS.ARMY_LEFT_AFTER_ATTACK;
            
            if (!player.territories.includes(toTerritoryId)) {
                player.territories.push(toTerritoryId);
            }
            
            console.log(`Server: Attack successful - ${playerId} captured territory ${toTerritoryId}`);
        } else {
            // Defender wins
            const survivingDefenders = Math.ceil(defendingArmies * GAME_CONSTANTS.DEFENDER_SURVIVAL_RATE);
            toTerritory.armySize = survivingDefenders;
            fromTerritory.armySize = GAME_CONSTANTS.ARMY_LEFT_AFTER_ATTACK;
            
            console.log(`Server: Attack failed - ${playerId} lost attacking territory ${toTerritoryId}`);
        }

        this.updatePlayerStats();
        return true;
    }

    public launchProbe(playerId: string, fromTerritoryId: number, toTerritoryId: number): boolean {
        const fromTerritory = this.gameState.territories[fromTerritoryId];
        const toTerritory = this.gameState.territories[toTerritoryId];
        const player = this.gameState.players[playerId];

        if (!fromTerritory || !toTerritory || !player ||
            fromTerritory.ownerId !== playerId ||
            fromTerritory.armySize < GAME_CONSTANTS.PROBE_MIN_ARMY_TO_LAUNCH ||
            !toTerritory.isColonizable) {
            return false;
        }

        // Create probe
        const probe: ProbeState = {
            id: this.gameState.probes.length,
            fromTerritoryId,
            toTerritoryId,
            playerId,
            playerColor: player.color,
            progress: 0,
            startTime: Date.now(),
            duration: this.calculateProbeTime(fromTerritory, toTerritory)
        };

        fromTerritory.armySize -= GAME_CONSTANTS.PROBE_COST;
        this.gameState.probes.push(probe);
        
        console.log(`Server: Probe launched from ${fromTerritoryId} to ${toTerritoryId} by ${playerId}`);
        return true;
    }

    public transferArmies(playerId: string, fromTerritoryId: number, toTerritoryId: number): boolean {
        const fromTerritory = this.gameState.territories[fromTerritoryId];
        const toTerritory = this.gameState.territories[toTerritoryId];

        if (!fromTerritory || !toTerritory ||
            fromTerritory.ownerId !== playerId ||
            toTerritory.ownerId !== playerId ||
            fromTerritory.armySize <= GAME_CONSTANTS.MIN_ARMY_TO_LEAVE_AFTER_TRANSFER ||
            !fromTerritory.neighbors.includes(toTerritoryId)) {
            return false;
        }

        const transferAmount = Math.floor(fromTerritory.armySize / GAME_CONSTANTS.TRANSFER_AMOUNT_DIVISOR);
        fromTerritory.armySize -= transferAmount;
        toTerritory.armySize += transferAmount;

        console.log(`Server: Transferred ${transferAmount} armies from ${fromTerritoryId} to ${toTerritoryId}`);
        return true;
    }

    private calculateProbeTime(from: TerritoryState, to: TerritoryState): number {
        const distance = Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2);
        return (distance / GAME_CONSTANTS.PROBE_SPEED) * 1000; // Convert to milliseconds
    }

    private checkWinConditions(): void {
        const activePlayers = Object.values(this.gameState.players).filter(p => !p.isEliminated && p.territories.length > 0);
        
        if (activePlayers.length === 1) {
            this.gameState.gamePhase = 'ended';
            this.gameState.winner = activePlayers[0].id;
            console.log(`Server: Game ended - Winner: ${activePlayers[0].name}`);
        } else if (activePlayers.length === 0) {
            this.gameState.gamePhase = 'ended';
            this.gameState.winner = null;
            console.log('Server: Game ended - Draw');
        }
    }

    private updatePlayerStats(): void {
        Object.values(this.gameState.players).forEach(player => {
            player.territoriesOwned = player.territories.length;
            player.totalArmies = player.territories.reduce((sum, territoryId) => {
                const territory = this.gameState.territories[territoryId];
                return sum + (territory?.armySize || 0);
            }, 0);
            
            if (player.territories.length === 0) {
                player.isEliminated = true;
            }
        });
    }

    public getFullState(): GameState {
        return { ...this.gameState };
    }

    private generateAIName(index: number): string {
        const names = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta'];
        return `AI_${names[index % names.length]}_${index}`;
    }

    private generatePlayerColor(index: number): string {
        const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ff8844', '#8844ff'];
        return colors[index % colors.length];
    }
}

================================================================================
FILE: server/index.ts
================================================================================
import express, { type Request, Response, NextFunction } from "express";
import { createServer } from "http";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { GameServer } from "./gameServer";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const httpServer = createServer(app);
  const server = await registerRoutes(app);
  
  // Initialize game server with WebSocket support
  const gameServer = new GameServer(httpServer);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client
  const port = 5000;
  httpServer.listen(port, "0.0.0.0", () => {
    log(`Server with WebSocket support running on port ${port}`);
  });
})();


================================================================================
FILE: server/routes.ts
================================================================================
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";

export async function registerRoutes(app: Express): Promise<Server> {
  // put application routes here
  // prefix all routes with /api

  // use storage to perform CRUD operations on the storage interface
  // e.g. storage.insertUser(user) or storage.getUserByUsername(username)

  const httpServer = createServer(app);

  return httpServer;
}


================================================================================
FILE: server/storage.ts
================================================================================
import { users, type User, type InsertUser } from "@shared/schema";

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  currentId: number;

  constructor() {
    this.users = new Map();
    this.currentId = 1;
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.currentId++;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
}

export const storage = new MemStorage();


================================================================================
FILE: server/vite.ts
================================================================================
import express, { type Express } from "express";
import fs from "fs";
import path, { dirname } from "path";
import { fileURLToPath } from "url";
import { createServer as createViteServer, createLogger } from "vite";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        __dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}


================================================================================
FILE: common/gameConstants.ts
================================================================================
// This file centralizes all game balance, rendering, and configuration constants.
// It is shared between the client and server to ensure a single source of truth.

export const GAME_CONSTANTS = {
    // Game Core
    DEFAULT_MAP_WIDTH: 2000,
    DEFAULT_MAP_HEIGHT: 2000,
    DEFAULT_GAME_TIMER_MINUTES: 10,
    MAX_TOTAL_PLAYERS: 100,
    HUMAN_PLAYER_ID_PREFIX: 'human',
    AI_PLAYER_ID_PREFIX: 'ai',

    // Player & AI Defaults
    DEFAULT_SINGLE_PLAYER_AI_COUNT: 19,
    DEFAULT_MULTIPLAYER_AI_COUNT: 90,
    DEFAULT_MAP_SIZE_TERRITORIES: 200,
    INITIAL_COLONIZED_ARMY_SIZE: 1,
    INITIAL_STARTING_ARMY_SIZE: 50,

    // Territory & Map Configuration
    TERRITORY_RADIUS: 25,
    CONNECTION_DISTANCE: 80,
    ARMY_GENERATION_RATE: 3000, // milliseconds per army

    // Probe System
    PROBE_LAUNCH_COST_FLEET: 10,
    PROBE_COST: 10, // Alias for compatibility
    PROBE_MIN_ARMY_TO_LAUNCH: 11, // Must have more than the cost to launch
    PROBE_UPDATE_INTERVAL_MS: 50,
    PROBE_SPEED_UNITS_PER_UPDATE: 1.25,
    PROBE_SPEED: 25, // Pixels per second

    // Fleet Transfer
    MIN_ARMY_TO_LEAVE_AFTER_TRANSFER: 1,
    TRANSFER_AMOUNT_DIVISOR: 2,

    // Supply Route System
    SUPPLY_ROUTE_MIN_ARMY_DIFFERENCE: 5,
    SUPPLY_ROUTE_TRANSFER_DIVISOR: 4,
    SUPPLY_ROUTE_DELAY_PER_HOP_MS: 2000,
    SUPPLY_ROUTE_LINE_WIDTH: 2,
    SUPPLY_ROUTE_ALPHA: 0.8,
    SUPPLY_ROUTE_DASH_PATTERN: [10, 10],
    SUPPLY_ROUTE_COLOR: '#00ffff',

    // Combat
    MIN_ARMY_TO_ATTACK: 2,
    MIN_ATTACK_ARMIES: 2, // Alias for compatibility
    ARMY_LEFT_AFTER_ATTACK: 1,
    ATTACK_POWER_BASE_MULTIPLIER: 0.8,
    ATTACK_POWER_RANDOM_RANGE: 0.4,
    DEFENSE_POWER_BASE_MULTIPLIER: 0.9,
    DEFENSE_POWER_RANDOM_RANGE: 0.2,
    ATTACKER_SURVIVAL_RATE: 0.7,
    DEFENDER_SURVIVAL_RATE: 0.8,
    COMBAT_ATTACKER_MODIFIER: 0.8,
    COMBAT_DEFENDER_MODIFIER: 0.9,

    // Rendering & UI
    BACKGROUND_COLOR: '#000011',
    CONNECTION_LINE_WIDTH: 1,
    CONNECTION_ALPHA: 0.3,
    CONNECTION_COLOR: '#444444',
    OWNED_CONNECTION_LINE_WIDTH: 3,
    OWNED_CONNECTION_ALPHA: 0.6,
    DRAG_PREVIEW_LINE_WIDTH: 2,
    DRAG_PREVIEW_ALPHA: 0.5,
    DRAG_PREVIEW_DASH_PATTERN: [5, 5],
    DRAG_PREVIEW_COLOR: '#ffffff',
    SHIP_ANIMATION_MIN_DURATION_MS: 500,
    SHIP_ANIMATION_SPEED_MS_PER_PX: 2,
    SHIP_ANIMATION_DEFAULT_COLOR: '#ffffff',
    TERRITORY_VISIBILITY_PADDING: 50,

    // Performance Throttling
    FPS_UPDATE_INTERVAL_MS: 1000,
    VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS: 100,
    AI_UPDATE_PLAYERS_PER_FRAME_DIVISOR: 3,
    SUPPLY_ROUTE_VALIDATION_FRAME_INTERVAL: 30,
    SUPPLY_ROUTE_PROCESSING_FRAME_INTERVAL: 60,

    // Input & Controls
    DRAG_THRESHOLD_PIXELS_MOUSE: 5,
    DRAG_THRESHOLD_PIXELS_TOUCH: 10,
    DOUBLE_TAP_THRESHOLD_MS: 300,
    MOUSE_LEFT_BUTTON: 0,
    KEY_RESTART_GAME: ['r', 'R'],
    KEY_TOGGLE_MINIMAP: ['m', 'M'],

    // AI Configuration
    AI_DECISION_INTERVAL_MS: 1000,
    AI_DECISION_INTERVAL_JITTER_MS: 500,
    AI_AGGRESSION_THRESHOLD_TERRITORY_PERCENT: 0.3,
    AI_CONSOLIDATION_THRESHOLD_TERRITORY_COUNT: 5,
    AI_ATTACK_STRENGTH_MULTIPLIER: 1.5,

    // Server Specific
    SERVER_PORT: 5000,
    CORS_ORIGIN: "*",
    CORS_METHODS: ["GET", "POST"],
    ROOM_ID_GENERATION_RADIX: 36,
    ROOM_ID_GENERATION_SUBSTRING_START: 2,
    ROOM_ID_GENERATION_SUBSTRING_END: 8,
    SERVER_TICK_RATE_MS: 1000 / 20, // 20 ticks per second
};

================================================================================
FILE: client/src/components/GameConfigScreen.tsx
================================================================================
import React, { useState } from 'react';
import { Button } from './ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from './ui/card';
import { Label } from './ui/label';
import { Slider } from './ui/slider';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger, DialogFooter, DialogClose } from './ui/dialog';

interface GameConfigScreenProps {
  onStartGame: (config: GameConfig) => void;
  onBack: () => void;
}

export interface GameConfig {
  mapSize: number;
  aiPlayerCount: number;
  playerName: string;
  gameSpeed: number;
  layout: string;
  warpLaneDensity: number;
  connectionRange: number;
  nebulaCount: number;
  probeSpeed: number;
  nebulaSlowdown: boolean;
  supplyRoutes: boolean;
  probeColonization: boolean;
}

export function GameConfigScreen({ onStartGame, onBack }: GameConfigScreenProps) {
  const [mapSize, setMapSize] = useState([80]); // Default 80 territories for less crowding
  const [aiPlayerCount, setAiPlayerCount] = useState([19]); // Default 19 AI players
  const [playerName, setPlayerName] = useState('Player');
  const [gameSpeed, setGameSpeed] = useState([1.0]); // Default normal speed
  const [layout, setLayout] = useState('organic'); // Default organic layout
  
  // Advanced map controls
  const [warpLaneDensity, setWarpLaneDensity] = useState(80); // Default 80% density
  const [connectionRange, setConnectionRange] = useState(140); // Default 140px range
  const [nebulaCount, setNebulaCount] = useState(10); // Default 10 nebulas
  const [probeSpeed, setProbeSpeed] = useState(100); // Default 100% speed
  
  // Special features
  const [nebulaSlowdown, setNebulaSlowdown] = useState(true);
  const [supplyRoutes, setSupplyRoutes] = useState(true);
  const [probeColonization, setProbeColonization] = useState(true);



  const handleStartGame = () => {
    onStartGame({
      mapSize: mapSize[0],
      aiPlayerCount: aiPlayerCount[0],
      playerName: playerName,
      gameSpeed: gameSpeed[0],
      layout: layout,
      warpLaneDensity: warpLaneDensity,
      connectionRange: connectionRange,
      nebulaCount: nebulaCount,
      probeSpeed: probeSpeed,
      nebulaSlowdown: nebulaSlowdown,
      supplyRoutes: supplyRoutes,
      probeColonization: probeColonization
    });
  };

  const getMapDescription = (size: number) => {
    if (size <= 50) return 'Small - Quick skirmishes';
    if (size <= 80) return 'Medium - Balanced exploration';
    if (size <= 120) return 'Large - Epic campaigns';
    return 'Massive - Ultimate challenge';
  };

  const getAIDescription = (count: number) => {
    if (count <= 10) return 'Few - Casual experience';
    if (count <= 25) return 'Normal - Standard challenge';
    if (count <= 50) return 'Many - Intense competition';
    return 'Maximum - Chaos mode';
  };

  const getSpeedDescription = (speed: number) => {
    if (speed <= 0.1) return 'Ultra Slow - Epic strategic campaigns';
    if (speed <= 0.5) return 'Slow - Deep strategic thinking';
    if (speed <= 1.0) return 'Normal - Balanced gameplay';
    if (speed <= 2.0) return 'Fast - Quick action';
    return 'Blitz - Lightning fast';
  };

  const formatSpeedValue = (speed: number) => {
    if (speed >= 1.0) return `${speed}x`;
    return `${Math.round(speed * 100)}%`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 p-4 overflow-y-auto">
      <div className="w-full max-w-md mx-auto py-8">
        <Card className="w-full bg-gray-800/90 backdrop-blur-sm border-gray-700">
          <CardHeader className="text-center">
          <CardTitle className="text-2xl font-bold text-white">
            Star Throne - Single Player
          </CardTitle>
          <CardDescription className="text-gray-300">
            Customize your galactic conquest experience
          </CardDescription>
        </CardHeader>
        
        <CardContent className="space-y-6">
          {/* Player Name */}
          <div className="space-y-2">
            <Label htmlFor="playerName" className="text-white">Player Name</Label>
            <input
              id="playerName"
              type="text"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Enter your name"
              maxLength={20}
            />
          </div>

          {/* Map Size */}
          <div className="space-y-3">
            <div className="flex justify-between items-center">
              <Label className="text-white">Map Size</Label>
              <span className="text-cyan-400 font-mono">{mapSize[0]} territories</span>
            </div>
            <Slider
              value={mapSize}
              onValueChange={setMapSize}
              max={150}
              min={30}
              step={10}
              className="w-full"
            />
            <p className="text-sm text-gray-400">{getMapDescription(mapSize[0])}</p>
          </div>

          {/* AI Player Count */}
          <div className="space-y-3">
            <div className="flex justify-between items-center">
              <Label className="text-white">AI Players</Label>
              <span className="text-cyan-400 font-mono">{aiPlayerCount[0]} opponents</span>
            </div>
            <Slider
              value={aiPlayerCount}
              onValueChange={setAiPlayerCount}
              max={99}
              min={5}
              step={1}
              className="w-full"
            />
            <p className="text-sm text-gray-400">{getAIDescription(aiPlayerCount[0])}</p>
          </div>

          {/* Game Speed */}
          <div className="space-y-3">
            <div className="flex justify-between items-center">
              <Label className="text-white">Game Speed</Label>
              <span className="text-cyan-400 font-mono">{formatSpeedValue(gameSpeed[0])}</span>
            </div>
            <Slider
              value={gameSpeed}
              onValueChange={setGameSpeed}
              max={2.0}
              min={0.01}
              step={0.01}
              className="w-full"
            />
            <p className="text-sm text-gray-400">{getSpeedDescription(gameSpeed[0])}</p>
          </div>

          {/* Galaxy Layout */}
          <div className="space-y-3">
            <Label className="text-white">Galaxy Layout</Label>
            <div className="grid grid-cols-2 gap-2">
              {[
                { value: 'organic', label: 'Organic', desc: 'Natural scattered distribution' },
                { value: 'clusters', label: 'Clusters', desc: 'Grouped stellar regions' },
                { value: 'spiral', label: 'Spiral', desc: 'Galactic arm formation' },
                { value: 'core', label: 'Core', desc: 'Dense center with shells' },
                { value: 'ring', label: 'Rings', desc: 'Concentric stellar rings' },
                { value: 'binary', label: 'Binary', desc: 'Two major systems' }
              ].map((layoutOption) => (
                <button
                  key={layoutOption.value}
                  onClick={() => setLayout(layoutOption.value)}
                  className={`p-3 rounded border text-left transition-colors ${
                    layout === layoutOption.value
                      ? 'bg-blue-600 border-blue-500 text-white'
                      : 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600'
                  }`}
                >
                  <div className="font-medium text-sm">{layoutOption.label}</div>
                  <div className="text-xs opacity-80">{layoutOption.desc}</div>
                </button>
              ))}
            </div>
          </div>



          {/* Advanced Settings */}
          <div className="space-y-4 pt-4 border-t border-gray-700">
            <h3 className="text-lg font-semibold text-white">Advanced Settings</h3>
            
            {/* AI Difficulty */}
            <div className="space-y-2">
              <Label className="text-white">AI Intelligence Level</Label>
              <Select defaultValue="normal">
                <SelectTrigger className="bg-gray-700 border-gray-600">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent className="bg-gray-700 border-gray-600">
                  <SelectItem value="easy">Easy - Passive expansion</SelectItem>
                  <SelectItem value="normal">Normal - Balanced strategy</SelectItem>
                  <SelectItem value="hard">Hard - Aggressive conquest</SelectItem>
                  <SelectItem value="expert">Expert - Advanced tactics</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Victory Conditions */}
            <div className="space-y-2">
              <Label className="text-white">Victory Condition</Label>
              <Select defaultValue="throne">
                <SelectTrigger className="bg-gray-700 border-gray-600">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent className="bg-gray-700 border-gray-600">
                  <SelectItem value="throne">Throne Star Conquest</SelectItem>
                  <SelectItem value="territory">Territory Control (75%)</SelectItem>
                  <SelectItem value="elimination">Total Elimination</SelectItem>
                  <SelectItem value="economic">Economic Domination</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Warp Lane Density */}
            <div className="space-y-2">
              <Label htmlFor="warpLaneDensity" className="text-white">
                Warp Lane Density: {warpLaneDensity}% 
                <span className="text-gray-400 ml-2">
                  ({warpLaneDensity < 60 ? 'Sparse' : warpLaneDensity < 80 ? 'Normal' : warpLaneDensity < 100 ? 'Dense' : 'Maximum'})
                </span>
              </Label>
              <Slider
                id="warpLaneDensity"
                min={30}
                max={120}
                step={10}
                value={[warpLaneDensity]}
                onValueChange={(value) => setWarpLaneDensity(value[0])}
                className="w-full"
              />
            </div>

            {/* Connection Range */}
            <div className="space-y-2">
              <Label htmlFor="connectionRange" className="text-white">
                Connection Range: {connectionRange}px
                <span className="text-gray-400 ml-2">
                  ({connectionRange < 120 ? 'Short' : connectionRange < 160 ? 'Normal' : 'Long'} range links)
                </span>
              </Label>
              <Slider
                id="connectionRange"
                min={80}
                max={200}
                step={20}
                value={[connectionRange]}
                onValueChange={(value) => setConnectionRange(value[0])}
                className="w-full"
              />
            </div>

            {/* Nebula Count */}
            <div className="space-y-2">
              <Label htmlFor="nebulaCount" className="text-white">
                Nebula Fields: {nebulaCount}
                <span className="text-gray-400 ml-2">
                  ({nebulaCount === 0 ? 'None' : nebulaCount < 8 ? 'Few' : nebulaCount < 15 ? 'Normal' : 'Many'})
                </span>
              </Label>
              <Slider
                id="nebulaCount"
                min={0}
                max={20}
                step={1}
                value={[nebulaCount]}
                onValueChange={(value) => setNebulaCount(value[0])}
                className="w-full"
              />
            </div>

            {/* Probe Speed */}
            <div className="space-y-2">
              <Label htmlFor="probeSpeed" className="text-white">
                Probe Speed: {probeSpeed}%
                <span className="text-gray-400 ml-2">
                  ({probeSpeed < 80 ? 'Slow' : probeSpeed < 120 ? 'Normal' : 'Fast'} exploration)
                </span>
              </Label>
              <Slider
                id="probeSpeed"
                min={50}
                max={200}
                step={25}
                value={[probeSpeed]}
                onValueChange={(value) => setProbeSpeed(value[0])}
                className="w-full"
              />
            </div>

            {/* Special Features */}
            <div className="space-y-2">
              <Label className="text-white">Special Features</Label>
              <div className="flex flex-wrap gap-2">
                <label className="flex items-center space-x-2">
                  <input 
                    type="checkbox" 
                    checked={nebulaSlowdown}
                    onChange={(e) => setNebulaSlowdown(e.target.checked)}
                    className="rounded" 
                  />
                  <span className="text-sm text-gray-300">Nebula Slowdown</span>
                </label>
                <label className="flex items-center space-x-2">
                  <input 
                    type="checkbox" 
                    checked={supplyRoutes}
                    onChange={(e) => setSupplyRoutes(e.target.checked)}
                    className="rounded" 
                  />
                  <span className="text-sm text-gray-300">Supply Routes</span>
                </label>
                <label className="flex items-center space-x-2">
                  <input 
                    type="checkbox" 
                    checked={probeColonization}
                    onChange={(e) => setProbeColonization(e.target.checked)}
                    className="rounded" 
                  />
                  <span className="text-sm text-gray-300">Probe Colonization</span>
                </label>
              </div>
            </div>
          </div>

        </CardContent>

        <CardFooter className="flex gap-3">
          <Button
            variant="outline"
            onClick={onBack}
            className="flex-1 border-gray-600 text-gray-300 hover:bg-gray-700"
          >
            Back
          </Button>
          <Button
            onClick={handleStartGame}
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white"
            disabled={!playerName.trim()}
          >
            Start Game
          </Button>
        </CardFooter>
        </Card>
      </div>
    </div>
  );
}

================================================================================
FILE: client/src/components/GameModeSelector.tsx
================================================================================
import { useState } from 'react';
import { Button } from './ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Badge } from './ui/badge';
import { socketClient } from '../lib/socketClient';
import { GameConfigScreen, GameConfig } from './GameConfigScreen';

interface GameModeSelectorProps {
  onModeSelected: (mode: 'single' | 'multiplayer', data?: any) => void;
}

export function GameModeSelector({ onModeSelected }: GameModeSelectorProps) {
  const [selectedMode, setSelectedMode] = useState<'single' | 'multiplayer' | null>(null);
  const [showConfigScreen, setShowConfigScreen] = useState(false);
  const [playerName, setPlayerName] = useState('');
  const [roomName, setRoomName] = useState('');
  const [roomId, setRoomId] = useState('');
  const [maxPlayers, setMaxPlayers] = useState(10);
  const [aiCount, setAiCount] = useState(90);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState('');

  const handleSinglePlayer = () => {
    // Use default name if none set
    if (!playerName.trim()) {
      setPlayerName('Player');
    }
    
    setSelectedMode('single');
    setShowConfigScreen(true);
  };

  const handleConfigStart = (config: GameConfig) => {
    onModeSelected('single', { 
      playerName: config.playerName, 
      aiCount: config.aiPlayerCount,
      mapSize: config.mapSize,
      gameSpeed: config.gameSpeed,
      layout: config.layout
    });
  };

  const handleConfigBack = () => {
    setShowConfigScreen(false);
    setSelectedMode(null);
  };

  const handleMultiplayerConnect = () => {
    // Prompt for player name if not set
    let name = playerName.trim();
    if (!name) {
      const promptResult = prompt('Enter your player name:') || '';
      if (!promptResult.trim()) {
        setError('Player name is required for multiplayer');
        return;
      }
      name = promptResult.trim();
      setPlayerName(name);
    }

    setIsConnecting(true);
    setError('');

    // Set up socket event handlers
    socketClient.onConnected(() => {
      console.log('Connected to multiplayer server');
    });

    socketClient.onError((error) => {
      setError(error.message);
      setIsConnecting(false);
    });

    socketClient.onRoomCreated((room) => {
      onModeSelected('multiplayer', { room, playerName: playerName.trim() });
    });

    socketClient.onRoomJoined((room) => {
      onModeSelected('multiplayer', { room, playerName: playerName.trim() });
    });

    // Connect to server
    socketClient.connect();
  };

  const handleCreateRoom = () => {
    if (!roomName.trim()) {
      setError('Please enter a room name');
      return;
    }

    socketClient.createRoom(roomName.trim(), playerName.trim(), maxPlayers, aiCount);
  };

  const handleJoinRoom = () => {
    if (!roomId.trim()) {
      setError('Please enter a room ID');
      return;
    }

    socketClient.joinRoom(roomId.trim().toUpperCase(), playerName.trim());
  };

  if (selectedMode === 'multiplayer' && !isConnecting) {
    return (
      <div className="min-h-screen bg-gray-900 p-4 overflow-y-auto">
        <div className="w-full max-w-2xl mx-auto py-8 space-y-6">
          <div className="text-center">
            <h1 className="text-4xl font-bold text-white mb-2">Star Throne</h1>
            <p className="text-gray-400">Multiplayer Game Lobby</p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Create Room */}
            <Card className="bg-gray-800 border-gray-700">
              <CardHeader>
                <CardTitle className="text-white">Create New Game</CardTitle>
                <CardDescription className="text-gray-400">
                  Start a new multiplayer game room
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label htmlFor="roomName" className="text-white">Room Name</Label>
                  <Input
                    id="roomName"
                    value={roomName}
                    onChange={(e) => setRoomName(e.target.value)}
                    placeholder="Enter room name"
                    className="bg-gray-700 border-gray-600 text-white"
                  />
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <Label htmlFor="maxPlayers" className="text-white">Max Players</Label>
                    <Input
                      id="maxPlayers"
                      type="number"
                      min="2"
                      max="20"
                      value={maxPlayers}
                      onChange={(e) => setMaxPlayers(parseInt(e.target.value) || 10)}
                      className="bg-gray-700 border-gray-600 text-white"
                    />
                  </div>
                  <div>
                    <Label htmlFor="aiCount" className="text-white">AI Players</Label>
                    <Input
                      id="aiCount"
                      type="number"
                      min="0"
                      max="100"
                      value={aiCount}
                      onChange={(e) => setAiCount(parseInt(e.target.value) || 90)}
                      className="bg-gray-700 border-gray-600 text-white"
                    />
                  </div>
                </div>
                <Button onClick={handleCreateRoom} className="w-full">
                  Create Room
                </Button>
              </CardContent>
            </Card>

            {/* Join Room */}
            <Card className="bg-gray-800 border-gray-700">
              <CardHeader>
                <CardTitle className="text-white">Join Existing Game</CardTitle>
                <CardDescription className="text-gray-400">
                  Enter a room ID to join a game
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label htmlFor="roomId" className="text-white">Room ID</Label>
                  <Input
                    id="roomId"
                    value={roomId}
                    onChange={(e) => setRoomId(e.target.value.toUpperCase())}
                    placeholder="Enter 6-digit room ID"
                    maxLength={6}
                    className="bg-gray-700 border-gray-600 text-white font-mono"
                  />
                </div>
                <Button onClick={handleJoinRoom} className="w-full" variant="outline">
                  Join Room
                </Button>
              </CardContent>
            </Card>
          </div>

          <div className="text-center">
            <Button 
              onClick={() => setSelectedMode(null)} 
              variant="ghost" 
              className="text-gray-400 hover:text-white"
            >
              ← Back to Mode Selection
            </Button>
          </div>
        </div>
      </div>
    );
  }

  // Show configuration screen for single player
  if (showConfigScreen) {
    return (
      <GameConfigScreen 
        onStartGame={handleConfigStart}
        onBack={handleConfigBack}
      />
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 p-4 overflow-y-auto">
      <div className="w-full max-w-md mx-auto py-8 space-y-6">
        <div className="text-center">
          <h1 className="text-3xl md:text-4xl font-bold text-white mb-2">Star Throne</h1>
          <p className="text-gray-400">Choose your game mode</p>
        </div>

        {error && (
          <div className="text-red-400 text-sm text-center bg-red-900/20 p-2 rounded">
            {error}
          </div>
        )}

        <div className="grid grid-cols-1 gap-3">
          {/* Single Player */}
          <Card className="bg-gray-800 border-gray-700 hover:border-gray-600 transition-colors cursor-pointer">
            <CardHeader className="pb-3">
              <CardTitle className="text-white flex items-center justify-between text-lg">
                Single Player
                <Badge variant="secondary" className="text-xs">Instant Play</Badge>
              </CardTitle>
              <CardDescription className="text-gray-400 text-sm">
                Play against 19 AI opponents in a private game
              </CardDescription>
            </CardHeader>
            <CardContent className="pt-0">
              <Button 
                onClick={handleSinglePlayer} 
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 text-base border-0" 
                disabled={isConnecting}
              >
                Start Single Player Game
              </Button>
            </CardContent>
          </Card>

          {/* Multiplayer */}
          <Card className="bg-gray-800 border-gray-700 hover:border-gray-600 transition-colors cursor-pointer">
            <CardHeader className="pb-3">
              <CardTitle className="text-white flex items-center justify-between text-lg">
                Multiplayer
                <Badge variant="outline" className="text-xs">Up to 100 Players</Badge>
              </CardTitle>
              <CardDescription className="text-gray-400 text-sm">
                Join or create online games with other players
              </CardDescription>
            </CardHeader>
            <CardContent className="pt-0">
              <Button 
                onClick={() => {
                  setSelectedMode('multiplayer');
                  handleMultiplayerConnect();
                }} 
                className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 text-base border-0" 
                disabled={isConnecting}
              >
                {isConnecting ? 'Connecting...' : 'Enter Multiplayer Lobby'}
              </Button>
            </CardContent>
          </Card>
        </div>

        <div className="text-center text-xs text-gray-500 space-y-1">
          <p>Single player mode preserves all current gameplay features</p>
          <p>Multiplayer adds real-time competitive play</p>
        </div>
      </div>
    </div>
  );
}

================================================================================
FILE: client/src/App.tsx
================================================================================
import React, { useEffect, useRef, useState } from 'react';
import { GameModeSelector } from './components/GameModeSelector';

type GameMode = 'single' | 'multiplayer' | null;

interface GameData {
  playerName: string;
  aiCount?: number;
  mapSize?: number;
  gameSpeed?: number;
  layout?: string;
  room?: any;
}

function App() {
  const gameRef = useRef<any>(null);
  const mountedRef = useRef(false);
  const [gameMode, setGameMode] = useState<GameMode>(null);
  const [gameData, setGameData] = useState<GameData | null>(null);

  const initSinglePlayerGame = async (data: GameData) => {
    try {
      const { default: StarThrone } = await import('./game/StarThrone.js');
      gameRef.current = new StarThrone(data);
      // Make game globally accessible for mobile zoom buttons
      (window as any).game = gameRef.current;
      console.log('Single-player Star Throne game initialized with config:', data);
    } catch (error) {
      console.error('Failed to initialize single-player game:', error);
    }
  };

  const initMultiplayerGame = async (data: GameData) => {
    try {
      // For now, we'll use the same game engine but prepare for multiplayer integration
      const { default: StarThrone } = await import('./game/StarThrone.js');
      gameRef.current = new StarThrone();
      // Make game globally accessible for mobile zoom buttons
      (window as any).game = gameRef.current;
      console.log('Multiplayer-ready Star Throne game initialized');
      console.log('Room data:', data.room);
    } catch (error) {
      console.error('Failed to initialize multiplayer game:', error);
    }
  };

  const handleModeSelected = (mode: GameMode, data?: GameData) => {
    setGameMode(mode);
    setGameData(data || null);
    
    // Add game-active class to body when game starts
    document.body.classList.add('game-active');
    
    if (mode === 'single' && data) {
      initSinglePlayerGame(data);
    } else if (mode === 'multiplayer' && data) {
      initMultiplayerGame(data);
    }
  };

  // Auto-start single player if no mode selector is needed (for development)
  useEffect(() => {
    // Check if we should auto-start in single player mode
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auto') === 'single' && !mountedRef.current) {
      mountedRef.current = true;
      handleModeSelected('single', { playerName: 'Player', aiCount: 19, layout: 'organic' });
    }
  }, []);

  useEffect(() => {
    return () => {
      if (gameRef.current) {
        gameRef.current = null;
      }
      // Remove game-active class when component unmounts
      document.body.classList.remove('game-active');
    };
  }, []);

  // Remove game-active class when showing mode selector
  useEffect(() => {
    if (!gameMode) {
      document.body.classList.remove('game-active');
    }
  }, [gameMode]);

  // Show game mode selector if no mode is selected
  if (!gameMode) {
    return <GameModeSelector onModeSelected={handleModeSelected} />;
  }

  return (
    <div className="app" id="root">
      {/* Game canvas will be inserted here by TerritorialConquest */}
      {gameMode === 'multiplayer' && gameData?.room && (
        <div className="fixed top-4 left-4 bg-black/80 text-white p-2 rounded text-sm z-50">
          Room: {gameData.room.id} | Players: {gameData.room.playerCount}/{gameData.room.maxPlayers}
        </div>
      )}
    </div>
  );
}

export default App;


================================================================================
FILE: client/src/main.tsx
================================================================================
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";
import "./styles/game.css";

createRoot(document.getElementById("root")!).render(<App />);


================================================================================
FILE: common/types/index.ts
================================================================================
// Shared types for client and server communication.

export interface PlayerState {
  id: string;
  name: string;
  color: string;
  type: 'human' | 'ai';
  socketId?: string;
  territories: number[];
  armyGenRate: number;
  totalArmies: number;
  territoriesOwned: number;
  isEliminated: boolean;
}

export interface TerritoryState {
  id: number;
  ownerId: string | null;
  armySize: number;
  x: number;
  y: number;
  radius: number;
  neighbors: number[];
  hiddenNeighbors: number[];
  isColonizable: boolean;
  hiddenArmySize: number;
  lastCombatFlash: number;
}

export interface ProbeState {
    id: number;
    fromTerritoryId: number;
    toTerritoryId: number;
    playerId: string;
    playerColor: string;
    progress: number; // 0.0 to 1.0
    startTime: number;
    duration: number;
}

export interface ShipAnimationState {
    from: { x: number; y: number };
    to: { x: number; y: number };
    progress: number; // elapsed time
    duration: number;
    color: string;
    isAttack: boolean;
}

export interface SupplyRoute {
    from: number;
    to: number;
    path: number[];
    active: boolean;
}

export interface GameState {
    territories: Record<number, TerritoryState>;
    players: Record<string, PlayerState>;
    probes: ProbeState[];
    supplyRoutes: SupplyRoute[];
    gamePhase: 'lobby' | 'playing' | 'ended';
    winner: string | null;
    tick: number;
    lastUpdate: number;
}

// Command Protocol
export enum CommandType {
    ATTACK_TERRITORY = 'ATTACK_TERRITORY',
    TRANSFER_ARMIES = 'TRANSFER_ARMIES',
    LAUNCH_PROBE = 'LAUNCH_PROBE',
    CREATE_SUPPLY_ROUTE = 'CREATE_SUPPLY_ROUTE',
    SELECT_TERRITORY = 'SELECT_TERRITORY',
}

export interface ClientCommand {
  type: CommandType;
  payload: any;
  timestamp: number;
}

export interface AttackTerritoryCommand {
  fromTerritoryId: number;
  toTerritoryId: number;
}

export interface TransferArmiesCommand {
  fromTerritoryId: number;
  toTerritoryId: number;
}

export interface LaunchProbeCommand {
  fromTerritoryId: number;
  toTerritoryId: number;
}

export interface CreateSupplyRouteCommand {
  fromTerritoryId: number;
  toTerritoryId: number;
}

export interface SelectTerritoryCommand {
  territoryId: number;
}

export interface GameStateUpdate {
  type: 'FULL_STATE' | 'DELTA_STATE';
  gameState: Partial<GameState>;
  timestamp: number;
}

export interface CombatResult {
  attackerId: string;
  defenderId: string | null;
  fromTerritoryId: number;
  toTerritoryId: number;
  result: 'victory' | 'defeat';
  survivingArmies: number;
  timestamp: number;
}

export interface CommandError {
  command: CommandType;
  reason: string;
  timestamp: number;
}

export interface GameConfig {
  mapSize: number;
  aiPlayerCount: number;
  playerName: string;
  maxPlayers: number;
  tickRate: number; // Server updates per second
  gameSpeed: number; // Speed multiplier for all game actions (0.01-2.0)
}

================================================================================
FILE: shared/schema.ts
================================================================================
import { pgTable, text, serial, integer, boolean } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;


================================================================================
FILE: package.json
================================================================================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@fontsource/inter": "^5.2.5",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@tanstack/react-query": "^5.60.5",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pixi.js": "^8.8.1",
    "postprocessing": "^6.36.0",
    "r3f-perf": "^7.2.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-helmet-async": "^2.0.5",
    "react-hook-form": "^7.53.1",
    "react-resizable-panels": "^2.1.4",
    "react-router-dom": "^6.26.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.4",
    "tailwind-scrollbar": "^3.1.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.0",
    "vite-plugin-glsl": "^1.3.1",
    "wouter": "^3.3.5",
    "ws": "^8.18.2",
    "zod": "^3.23.8",
    "zod-validation-error": "^3.4.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.18.1",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}


================================================================================
FILE: vite.config.ts
================================================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
import glsl from "vite-plugin-glsl";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    glsl(), // Add GLSL shader support
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
    },
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true,
  },
  // Add support for large models and audio files
  assetsInclude: ["**/*.gltf", "**/*.glb", "**/*.mp3", "**/*.ogg", "**/*.wav"],
});


================================================================================
FILE: tsconfig.json
================================================================================
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}


================================================================================
FILE: tailwind.config.ts
================================================================================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;


================================================================================
FILE: postcss.config.js
================================================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================================================
SUMMARY AND FILE LISTING
================================================================================

Complete Star Throne Source Code Documentation

FRONTEND GAME ENGINE (JavaScript):
- StarThrone.js (3,405 lines) - Main game controller and loop
- GameMap.js (1,032 lines) - Territory generation and galaxy layouts  
- GameUI.js (1,044 lines) - UI rendering and interface management
- Renderer.js (700 lines) - Modular rendering system with LOD
- Player.js (649 lines) - Player state and AI behavior
- Territory.js (539 lines) - Individual territory logic and rendering
- InputHandler.js (514 lines) - Input processing with FSM
- InputStateMachine.js (458 lines) - Finite state machine for inputs
- CombatSystem.js (423 lines) - Combat resolution and throne mechanics
- SupplySystem.js (352 lines) - Supply route management
- Camera.js (343 lines) - Viewport controls and smooth movement
- Probe.js (122 lines) - Probe colonization system

BACKEND SERVER (TypeScript):
- GameEngine.ts (645 lines) - Server-authoritative game engine
- gameServer.ts (423 lines) - WebSocket multiplayer server
- gameEngine.ts (439 lines) - Legacy server engine
- vite.ts (88 lines) - Development server setup
- index.ts (71 lines) - Express server initialization
- storage.ts (39 lines) - In-memory data storage
- routes.ts (15 lines) - API route definitions

FRONTEND COMPONENTS (React/TypeScript):
- GameConfigScreen.tsx (370 lines) - Single-player configuration
- GameModeSelector.tsx (287 lines) - Game mode selection UI
- App.tsx - Main React application component
- main.tsx - React application entry point

SHARED/COMMON:
- gameConstants.ts (104 lines) - Centralized game configuration
- types/index.ts - Shared TypeScript type definitions
- schema.ts - Database schema definitions

CONFIGURATION FILES:
- package.json - Node.js dependencies and scripts
- vite.config.ts - Vite build configuration
- tsconfig.json - TypeScript configuration
- tailwind.config.ts - Tailwind CSS configuration
- postcss.config.js - PostCSS configuration

TOTAL LINES OF CODE: 12,062

================================================================================
END OF COMPLETE SOURCE CODE DOCUMENTATION
================================================================================
