STAR THRONE - COMPLETE CODEBASE FOR NEBULA BUG ANALYSIS
=======================================================

ISSUE: Nebula fog of war tooltips showing exact fleet counts instead of "??? Fleets (nebula)"
ISSUE: Supply route indicators (green "+" symbols) not appearing under territories

KEY FILES: GameUI.js (tooltip), GameMap.js (nebula detection), Renderer.js (supply indicators), StarThrone.js (main game)

===============================================================================
CLIENT/SRC/GAME/GAMEUI.JS - TOOLTIP GENERATION (MAIN BUG LOCATION)
===============================================================================export class GameUI {
    constructor(canvas, camera) {
        this.canvas = canvas;
        this.camera = camera;
        
        // UI state
        this.showLeaderboard = true;
        this.showMinimap = false;
        this.showStats = true;
        this.showHelp = false;
        
        // Animation
        this.animationPhase = 0;
        
        // Colors with better contrast
        this.bgColor = 'rgba(0, 0, 0, 0.85)';
        this.textColor = '#ffffff';
        this.accentColor = '#00ddff';
        this.warningColor = '#ff4444';
        this.successColor = '#44ff44';
        this.shadowColor = 'rgba(0, 0, 0, 0.8)';
    }

    // Helper function to render text with shadow for better readability
    renderTextWithShadow(ctx, text, x, y, fillColor = this.textColor, shadowOffset = 2) {
        // Draw shadow
        ctx.fillStyle = this.shadowColor;
        ctx.fillText(text, x + shadowOffset, y + shadowOffset);
        
        // Draw main text
        ctx.fillStyle = fillColor;
        ctx.fillText(text, x, y);
    }
    
    // Method for FSM to update UI state
    setInputState(state, data = {}) {
        this.inputState = state;
        this.inputStateData = data;
        
        // Update cursor based on FSM state
        if (this.canvas) {
            const cursorModes = {
                'Default': 'default',
                'TerritorySelected': 'pointer',
                'ProbeTargeting': 'crosshair',
                'EnemySelected': 'help'
            };
            this.canvas.style.cursor = cursorModes[state] || 'default';
        }
    }
    
    render(ctx, gameData) {
        this.animationPhase += 0.02;
        
        // Render different UI elements based on game state
        switch (gameData.gameState) {
            case 'lobby':
                this.renderLobbyUI(ctx, gameData);
                break;
            case 'playing':
                this.renderGameUI(ctx, gameData);
                break;
            case 'ended':
                this.renderEndGameUI(ctx, gameData);
                break;
        }
    }
    
    renderLobbyUI(ctx, gameData) {
        // Title screen
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Star Throne', this.canvas.width / 2, this.canvas.height / 2 - 100);
        
        ctx.font = '24px Arial';
        ctx.fillText('Massive Multiplayer Strategy Game', this.canvas.width / 2, this.canvas.height / 2 - 50);
        
        ctx.font = '18px Arial';
        ctx.fillText('Click anywhere to start', this.canvas.width / 2, this.canvas.height / 2 + 50);
        
        // Animated dots
        const dots = '...'.substring(0, Math.floor(this.animationPhase * 3) % 4);
        ctx.fillText(`Loading${dots}`, this.canvas.width / 2, this.canvas.height / 2 + 100);
    }
    
    renderGameUI(ctx, gameData) {
        // Top bar with timer and game info
        this.renderTopBar(ctx, gameData);
        
        // Leaderboard
        if (this.showLeaderboard) {
            this.renderLeaderboard(ctx, gameData);
        }
        
        // All UI panels removed for minimal clean interface
        
        // Minimap (minimizable)
        if (this.showMinimap) {
            this.renderMinimap(ctx, gameData);
        }
        
        // Discovery panel showing empire bonuses
        this.renderDiscoveryPanel(ctx, gameData);
        
        // Performance panel (togglable with P key)
        this.renderPerformanceInfo(ctx, gameData);
        
        // Zoom controls removed - using mousewheel only
        
        // Tooltip for hovered territory
        this.renderTooltip(ctx, gameData);
        
        // Render notifications
        this.renderNotifications(ctx, gameData);
        
        // Floating discovery announcements at top center
        this.renderFloatingAnnouncements(ctx, gameData);
        
        // Game over screen for human player
        const humanPlayer = gameData.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            this.renderGameOverScreen(ctx, gameData);
        }
    }
    
    renderEndGameUI(ctx, gameData) {
        // Full opaque overlay for maximum readability
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title with dramatic shadow effect
        ctx.font = 'bold 64px Arial';
        ctx.textAlign = 'center';
        
        // Title shadow
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.fillText('Game Over!', this.canvas.width / 2 + 4, this.canvas.height / 2 - 146);
        
        // Main title
        ctx.fillStyle = '#ffffff';
        ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 150);
        
        // Final leaderboard
        this.renderFinalLeaderboard(ctx, gameData);
        
        // Larger, more prominent restart button
        const buttonWidth = 280;
        const buttonHeight = 60;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height - 120;
        
        // Button shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(buttonX + 4, buttonY + 4, buttonWidth, buttonHeight);
        
        // Restart button background
        ctx.fillStyle = '#00ddff';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border with glow effect
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Inner glow
        ctx.strokeStyle = '#00ddff';
        ctx.lineWidth = 1;
        ctx.strokeRect(buttonX + 2, buttonY + 2, buttonWidth - 4, buttonHeight - 4);
        
        // Button text with shadow
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        
        // Text shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText('PLAY AGAIN', this.canvas.width / 2 + 2, buttonY + 40);
        
        // Main text
        ctx.fillStyle = '#000000';
        ctx.fillText('PLAY AGAIN', this.canvas.width / 2, buttonY + 38);
        
        // Store button area for touch detection
        this.restartButton = {
            x: buttonX,
            y: buttonY,
            width: buttonWidth,
            height: buttonHeight
        };
    }
    
    renderTopBar(ctx, gameData) {
        const barHeight = 60;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, barHeight);
        
        // Timer
        const timeLeft = Math.max(0, gameData.gameTimer);
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        ctx.fillStyle = timeLeft < 60000 ? this.warningColor : this.textColor;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(timeString, this.canvas.width / 2, 35);
        
        // Player count
        ctx.fillStyle = this.textColor;
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Players: ${gameData.currentPlayers}/${gameData.maxPlayers}`, 20, 25);
        
        // Game title
        ctx.textAlign = 'left';
        ctx.fillText('Star Throne', 20, 45);
        
        // Camera info
        ctx.textAlign = 'right';
        const zoom = (this.camera.zoom * 100).toFixed(0);
        ctx.fillText(`Zoom: ${zoom}%`, this.canvas.width - 20, 25);
    }
    
    renderLeaderboard(ctx, gameData) {
        const startX = this.canvas.width - 250;
        const startY = 80;
        const width = 230;
        const itemHeight = 25;
        
        if (gameData.leaderboardMinimized) {
            // Minimized leaderboard - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY, width, 35);
            
            ctx.fillStyle = this.accentColor;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Leaderboard (tap to expand)', startX + width / 2, startY + 22);
            
            // Add minimize indicator
            ctx.fillStyle = this.textColor;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('‚ñº', startX + width - 10, startY + 22);
            return;
        }
        
        // Sort players by territories controlled (stars)
        const sortedPlayers = gameData.players
            .filter(p => !p.isEliminated)
            .sort((a, b) => {
                const aCount = a.territories ? a.territories.length : 0;
                const bCount = b.territories ? b.territories.length : 0;
                return bCount - aCount;
            })
            .slice(0, 10); // Top 10
            
        // Debug: Log top 3 players occasionally
        if (Math.random() < 0.1) {
            console.log('üèÜ Top 3 players:', sortedPlayers.slice(0, 3).map(p => `${p.name}: ${p.territories ? p.territories.length : 0} territories`));
        }
        
        const height = 40 + sortedPlayers.length * itemHeight;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title with minimize indicator
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Leaderboard', startX + width / 2, startY + 20, this.accentColor);
        
        // Add minimize indicator
        ctx.font = '16px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '‚ñ≤', startX + width - 10, startY + 20, this.textColor);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 40 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            
            // Rank
            ctx.fillStyle = this.textColor;
            ctx.font = isHuman ? 'bold 14px Arial' : '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${index + 1}.`, startX + 10, y);
            
            // Player color indicator
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 35, y - 8, 12, 12);
            
            // Player name
            ctx.fillStyle = isHuman ? this.accentColor : this.textColor;
            ctx.textAlign = 'left';
            const name = player.name.length > 10 ? player.name.substring(0, 10) + '...' : player.name;
            ctx.fillText(name, startX + 55, y);
            
            // Territory count with safety check
            ctx.fillStyle = this.textColor;
            ctx.textAlign = 'right';
            const territoryCount = player.territories ? player.territories.length : 0;
            ctx.fillText(territoryCount.toString(), startX + width - 10, y);
        });
        
        // Eliminated count
        const eliminatedCount = gameData.players.filter(p => p.isEliminated).length;
        if (eliminatedCount > 0) {
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${eliminatedCount} eliminated`, startX + width / 2, startY + height + 15);
        }
    }
    
    renderTerritoryInfo(ctx, gameData) {
        const territory = gameData.selectedTerritory;
        const startX = 20;
        const startY = this.canvas.height - 150;
        const width = 200;
        const height = 120;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Territory ${territory.id}`, startX + 10, startY + 20);
        
        // Owner info
        if (territory.ownerId !== null) {
            const owner = gameData.players[territory.ownerId];
            if (owner) {
                ctx.fillStyle = owner.color;
                ctx.fillRect(startX + 10, startY + 30, 12, 12);
                
                ctx.fillStyle = this.textColor;
                ctx.font = '14px Arial';
                ctx.fillText(`Owner: ${owner.name}`, startX + 30, startY + 40);
            }
        } else {
            ctx.fillStyle = this.textColor;
            ctx.font = '14px Arial';
            ctx.fillText('Neutral Territory', startX + 10, startY + 40);
        }
        
        // Army count
        ctx.fillText(`Armies: ${territory.armySize}`, startX + 10, startY + 60);
        
        // Neighbors
        ctx.font = '12px Arial';
        ctx.fillText(`Neighbors: ${territory.neighbors.length}`, startX + 10, startY + 80);
        
        // Action hint
        if (territory.ownerId === gameData.humanPlayer.id) {
            ctx.fillStyle = this.successColor;
            ctx.fillText('Click neighbor to attack', startX + 10, startY + 100);
        } else if (gameData.selectedTerritory && 
                   gameData.selectedTerritory.ownerId === gameData.humanPlayer.id &&
                   gameData.selectedTerritory.neighbors.includes(territory.id)) {
            ctx.fillStyle = this.warningColor;
            ctx.fillText('Click to attack', startX + 10, startY + 100);
        }
    }
    
    renderPlayerStats(ctx, gameData) {
        const player = gameData.humanPlayer;
        const startX = 250;
        const startY = this.canvas.height - 100;
        const width = 200;
        const height = 80;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Player name
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(player.name, startX + 10, startY + 20);
        
        // Stats
        ctx.fillStyle = this.textColor;
        ctx.font = '14px Arial';
        ctx.fillText(`Territories: ${player.territories.length}`, startX + 10, startY + 40);
        ctx.fillText(`Total Armies: ${player.totalArmies}`, startX + 10, startY + 55);
        ctx.fillText(`Score: ${player.score}`, startX + 10, startY + 70);
    }
    
    renderSpectatorMessage(ctx) {
        const startX = this.canvas.width / 2 - 150;
        const startY = 100;
        const width = 300;
        const height = 60;
        
        // Background
        ctx.fillStyle = 'rgba(255, 68, 68, 0.9)';
        ctx.fillRect(startX, startY, width, height);
        
        // Message
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('You have been eliminated!', startX + width / 2, startY + 25);
        
        ctx.font = '14px Arial';
        ctx.fillText('Spectator Mode', startX + width / 2, startY + 45);
    }
    
    renderHelpPanel(ctx) {
        const startX = 20;
        const startY = 80;
        const width = 200;
        const height = 140;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Controls', startX + 10, startY + 18);
        
        // Help text - mobile-friendly
        ctx.fillStyle = this.textColor;
        ctx.font = '12px Arial';
        const helpLines = [
            'Tap: Select/Attack',
            'Drag: Pan camera',
            'Pinch: Zoom in/out',
            'Two finger: Pan & zoom',
            'ESC: Deselect',
            'R: Restart (when ended)'
        ];
        
        helpLines.forEach((line, index) => {
            ctx.fillText(line, startX + 10, startY + 35 + index * 15);
        });
    }
    
    renderPerformanceInfo(ctx, gameData) {
        // Show detailed performance panel if enabled
        if (gameData.showPerformancePanel) {
            const x = this.canvas.width - 250;
            const y = 50;
            const width = 240;
            const height = 160;
            
            // Background with transparency
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - 10, y - 10, width, height);
            
            // Border
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 10, width, height);
            
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            
            // Performance metrics with color coding
            const fps = gameData.fps || 0;
            const fpsColor = fps > 50 ? '#00ff00' : fps > 30 ? '#ffff00' : '#ff0000';
            this.renderTextWithShadow(ctx, `FPS: ${fps}`, x, y, fpsColor);
            
            this.renderTextWithShadow(ctx, `Frame: ${(gameData.frameTime || 0).toFixed(1)}ms`, x, y + 20, this.textColor);
            this.renderTextWithShadow(ctx, `Render: ${(gameData.renderTime || 0).toFixed(1)}ms`, x, y + 40, this.textColor);
            this.renderTextWithShadow(ctx, `Update: ${(gameData.updateTime || 0).toFixed(1)}ms`, x, y + 60, this.textColor);
            
            // Game-specific metrics
            this.renderTextWithShadow(ctx, `Territories: ${gameData.territoryCount || 0}`, x, y + 80, this.textColor);
            this.renderTextWithShadow(ctx, `Rendered: ${gameData.visibleTerritories || 0}`, x, y + 100, this.textColor);
            this.renderTextWithShadow(ctx, `Probes: ${gameData.probeCount || 0}`, x, y + 120, this.textColor);
            
            // Toggle hint
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, 'Press P to toggle', x + width - 15, y + height - 15, '#888888');
        } else {
            // Simple FPS counter
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`FPS: ${gameData.fps}`, this.canvas.width - 20, this.canvas.height - 10);
        }
        
        // Mobile touch debug info
        if (gameData.touchDebugInfo && gameData.showTouchDebug) {
            ctx.fillStyle = this.accentColor;
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            const lines = gameData.touchDebugInfo.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, 10, this.canvas.height - 60 + (index * 16));
            });
        }
    }
    
    // Removed probe notification UI (probe functionality disabled)
    
    renderDiscoveryPanel(ctx, gameData) {
        // Only show human player's discoveries
        if (!gameData.playerDiscoveries || !gameData.humanPlayer) {
            console.log('üîç DEBUG: No playerDiscoveries or humanPlayer', {
                playerDiscoveries: !!gameData.playerDiscoveries,
                humanPlayer: !!gameData.humanPlayer
            });
            return;
        }
        
        const discoveries = gameData.playerDiscoveries.get(gameData.humanPlayer.id);
        if (!discoveries) {
            console.log('üîç DEBUG: No discoveries for human player', {
                humanPlayerId: gameData.humanPlayer.id,
                playerDiscoveriesKeys: Array.from(gameData.playerDiscoveries.keys())
            });
            return;
        }
        
        console.log('üîç DEBUG: Human player discoveries found:', discoveries);
        
        // Count active discoveries (with safety checks)
        let discoveryCount = 0;
        if (discoveries && discoveries.precursorWeapons > 0) discoveryCount++;
        if (discoveries && discoveries.precursorDrive > 0) discoveryCount++;
        if (discoveries && discoveries.precursorShield > 0) discoveryCount++;
        if (discoveries && discoveries.precursorNanotech > 0) discoveryCount++;
        if (discoveries && discoveries.ancientRuins > 0) discoveryCount++;
        if (discoveries && discoveries.friendlyAliens > 0) discoveryCount++;
        if (discoveries && discoveries.richMinerals > 0) discoveryCount++;
        
        // Always show panel if player has any discoveries
        if (discoveryCount === 0) {
            // Show empty panel if human player has made any probe attempts
            const humanPlayer = gameData.humanPlayer;
            if (!humanPlayer || humanPlayer.territories.length === 0) return;
        }
        
        const x = 20;
        const width = 280;
        const lineHeight = 20;
        const padding = 10;
        const discoveryHeight = discoveryCount * lineHeight;
        const titleHeight = 25;
        const height = Math.max(80, titleHeight + discoveryHeight + padding * 2);
        const y = this.canvas.height - height - 20; // Bottom left positioning
        
        // Background with transparency
        ctx.fillStyle = 'rgba(0, 20, 40, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery theme color
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Title
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        this.renderTextWithShadow(ctx, 'üî¨ Empire Discoveries', x + padding, y + 20, '#4CAF50');
        
        let currentY = y + 40; // Start showing permanent bonuses
        
        // Show empire-wide bonuses only (no temporary notifications)
        ctx.font = '12px Arial';
        
        // Show empire-wide bonuses (with safety checks)
        if (discoveries && discoveries.precursorWeapons > 0) {
            this.renderTextWithShadow(ctx, `‚öîÔ∏è Weapons Lvl ${discoveries.precursorWeapons}: +${discoveries.precursorWeapons * 10}% Attack`, x + padding, currentY, '#FF6B6B');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorDrive > 0) {
            this.renderTextWithShadow(ctx, `üöÄ Drive Lvl ${discoveries.precursorDrive}: +${discoveries.precursorDrive * 20}% Speed`, x + padding, currentY, '#4ECDC4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorShield > 0) {
            this.renderTextWithShadow(ctx, `üõ°Ô∏è Shield Lvl ${discoveries.precursorShield}: +${discoveries.precursorShield * 10}% Defense`, x + padding, currentY, '#45B7D1');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorNanotech > 0) {
            this.renderTextWithShadow(ctx, `üî¨ Nanotech Lvl ${discoveries.precursorNanotech}: +${discoveries.precursorNanotech * 10}% Generation`, x + padding, currentY, '#96CEB4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.factoryPlanets && discoveries.factoryPlanets.size > 0) {
            this.renderTextWithShadow(ctx, `üè≠ Factory Worlds: ${discoveries.factoryPlanets.size} (+100% each)`, x + padding, currentY, '#FECA57');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.friendlyAliens > 0) {
            this.renderTextWithShadow(ctx, `üëΩ Friendly Aliens: +${discoveries.friendlyAliens * 50} Fleet Strength`, x + padding, currentY, '#9B59B6');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.richMinerals > 0) {
            this.renderTextWithShadow(ctx, `üíé Rich Minerals: ${discoveries.richMinerals} Worlds (+50% each)`, x + padding, currentY, '#F39C12');
            currentY += lineHeight;
        }
        
        // Discovery count summary
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, `Total: ${discoveryCount} discoveries`, x + width - padding, y + height - 5, '#888888');
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 255, g: 255, b: 255};
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': 'üíÄ',
            'extra_fleet': 'üëΩ',
            'precursor_weapons': '‚öîÔ∏è',
            'precursor_drive': 'üöÄ',
            'precursor_shield': 'üõ°Ô∏è',
            'precursor_nanotech': 'üî¨',
            'factory_complex': 'üè≠',
            'mineral_deposits': 'üíé',
            'void_storm': '‚ö°',
            'ancient_ruins': 'üèõÔ∏è'
        };
        return icons[effect] || 'üîç';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    renderFloatingAnnouncements(ctx, gameData) {
        if (!gameData.discoveryLog || !gameData.humanPlayer) return;
        
        const now = Date.now();
        const humanPlayerId = gameData.humanPlayer.id;
        const announcements = gameData.discoveryLog.filter(entry => {
            const age = (now - entry.timestamp) / 1000;
            return age <= 3 && entry.playerId === humanPlayerId; // Only show human player discoveries for 3 seconds
        });
        
        // Show only the most recent announcement at top center
        if (announcements.length === 0) return;
        
        const latestAnnouncement = announcements.sort((a, b) => b.timestamp - a.timestamp)[0];
        const age = (now - latestAnnouncement.timestamp) / 1000;
        const fadeProgress = age / 3; // Fade over 3 seconds
        const opacity = Math.max(0, 1 - fadeProgress);
        
        // Get discovery info
        const icon = this.getDiscoveryIcon(latestAnnouncement.discovery.effect);
        const color = this.getDiscoveryColor(latestAnnouncement.discovery.effect);
        
        // Apply opacity
        const rgb = this.hexToRgb(color);
        const fadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
        
        // Top center positioning
        const width = 400;
        const height = 50;
        const x = (this.canvas.width - width) / 2;
        const y = 20;
        
        // Background with transparency
        ctx.fillStyle = `rgba(0, 0, 0, ${0.9 * opacity})`;
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery color
        ctx.strokeStyle = fadeColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Discovery text
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        const text = `${icon} ${latestAnnouncement.discovery.name}`;
        this.renderTextWithShadow(ctx, text, x + width/2, y + height/2 + 5, fadeColor);
    }
    
    renderMinimap(ctx, gameData) {
        const size = 150;
        const startX = this.canvas.width - size - 20;
        const startY = this.canvas.height - size - 20;
        
        if (gameData.minimapMinimized) {
            // Minimized minimap - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY + size - 30, size, 30);
            
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            this.renderTextWithShadow(ctx, 'Map (tap to expand)', startX + size / 2, startY + size - 12, this.accentColor);
            
            // Add expand indicator
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, '‚ñ≤', startX + size - 10, startY + size - 12, this.textColor);
            return;
        }
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(startX, startY, size, size);
        
        // Border
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, size, size);
        
        // Calculate scale
        const mapWidth = 2000; // From GameMap
        const mapHeight = 1500;
        const scaleX = size / mapWidth;
        const scaleY = size / mapHeight;
        
        // Draw territories on minimap
        Object.values(gameData.players).forEach(player => {
            if (player.isEliminated) return;
            
            ctx.fillStyle = player.color;
            player.territories.forEach(territoryId => {
                const territory = gameData.selectedTerritory ? 
                    (gameData.selectedTerritory.id === territoryId ? gameData.selectedTerritory : null) : null;
                // This is a simplified version - in real implementation we'd access territories from gameMap
                
                if (territory) {
                    const x = startX + territory.x * scaleX;
                    const y = startY + territory.y * scaleY;
                    const radius = Math.max(1, territory.radius * scaleX * 0.5);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });
        
        // Draw camera viewport
        if (this.camera) {
            const viewBounds = this.camera.getViewBounds();
            const viewX = startX + viewBounds.left * scaleX;
            const viewY = startY + viewBounds.top * scaleY;
            const viewWidth = (viewBounds.right - viewBounds.left) * scaleX;
            const viewHeight = (viewBounds.bottom - viewBounds.top) * scaleY;
            
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(viewX, viewY, viewWidth, viewHeight);
        }
        
        // Minimap title with minimize indicator
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Map', startX + size / 2, startY - 5, this.textColor);
        
        // Add minimize indicator
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '‚ñº', startX + size - 5, startY - 5, this.textColor);
    }
    
    renderTooltip(ctx, gameData) {
        if (!gameData.hoveredTerritory || !gameData.mousePos) {
            return;
        }
        

        
        const territory = gameData.hoveredTerritory;
        const mouseX = gameData.mousePos.x;
        const mouseY = gameData.mousePos.y;
        
        // Get territory information
        let ownerName = 'Neutral';
        let territoryColor = '#666666';
        
        if (territory.ownerId !== null && gameData.players[territory.ownerId]) {
            const owner = gameData.players[territory.ownerId];
            ownerName = owner.name;
            territoryColor = owner.color;
        }
        
        // Prepare tooltip text
        let tooltipLines = [];
        if (territory.isColonizable) {
            tooltipLines.push(`Unexplored System`);
            
            // Only show "Click to probe" if player has a valid selected territory that can reach it
            const canProbe = gameData.selectedTerritory && 
                            gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id &&
                            gameData.selectedTerritory.armySize >= 10; // Need 10 fleets for probe
            
            if (canProbe) {
                tooltipLines.push(`Click to probe (10 fleets)`);
            } else if (gameData.selectedTerritory && gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id) {
                tooltipLines.push(`Need 10 fleets to probe`);
            } else {
                tooltipLines.push(`Select owned territory first`);
            }
        } else {
            // FOG OF WAR: Check if this is a mysterious territory
            const humanPlayerId = gameData.humanPlayer?.id;
            const isNeutralMystery = territory.ownerId === null && !territory.neighbors.some(neighborId => {
                const neighbor = gameData.territories?.[neighborId];
                return neighbor && neighbor.ownerId === humanPlayerId;
            });
            
            const isEnemyMystery = territory.ownerId !== null && territory.ownerId !== humanPlayerId && !territory.neighbors.some(neighborId => {
                const neighbor = gameData.territories?.[neighborId];
                return neighbor && neighbor.ownerId === humanPlayerId;
            });
            
            const isMysteriousTerritory = isNeutralMystery || isEnemyMystery;
            
            // NEBULA FOG OF WAR: Check if territory is inside a nebula (applies to ALL territories)
            const isInNebula = gameData?.gameMap?.isInNebula?.(territory.x, territory.y) || false;
            const isPlayerOwned = territory.ownerId === humanPlayerId;
            const isNeutral = territory.ownerId === null;
            
            // Debug: Always log for neutral territories to debug nebula detection
            if (isNeutral && territory.armySize && (territory.armySize === 11 || territory.armySize === 5)) {
                console.log(`üîç NEBULA DEBUG - Territory ${territory.id} at (${territory.x}, ${territory.y}): inNebula=${isInNebula}, armies=${territory.armySize}`);
                console.log(`üîç GameMap exists: ${!!gameData?.gameMap}, isInNebula function exists: ${!!gameData?.gameMap?.isInNebula}`);
                console.log(`üîç GameData keys:`, Object.keys(gameData || {}));
                
                if (gameData?.gameMap?.nebulas) {
                    console.log(`üîç Total nebulas: ${gameData.gameMap.nebulas.length}`);
                    gameData.gameMap.nebulas.forEach((nebula, i) => {
                        const dist = Math.sqrt((territory.x - nebula.x) ** 2 + (territory.y - nebula.y) ** 2);
                        console.log(`üîç Nebula ${i}: center (${nebula.x}, ${nebula.y}), radius ${nebula.radius}, distance to territory: ${dist.toFixed(1)}, INSIDE: ${dist <= nebula.radius}`);
                    });
                } else {
                    console.log(`üîç No nebulas found in gameData.gameMap`);
                }
            }
            
            if (isMysteriousTerritory && territory.ownerId !== null) {
                // Mysterious enemy territory - only show player name
                tooltipLines.push(`${ownerName}`);
                // Apply nebula fog even to mysterious territories
                if (isInNebula) {
                    tooltipLines.push(`Unknown forces (nebula)`);
                } else {
                    tooltipLines.push(`Unknown forces`);
                }
            } else if (isNeutralMystery) {
                // Mysterious neutral territory - show as unexplored
                tooltipLines.push(`Unexplored System`);
                // Apply nebula fog even to mysterious territories
                if (isInNebula) {
                    tooltipLines.push(`Unknown garrison (nebula)`);
                } else {
                    tooltipLines.push(`Unknown garrison`);
                }
            } else {
                // Visible territory - show owner name first
                tooltipLines.push(`${ownerName}`);
                
                // NEBULA FOG OF WAR: Apply to ALL visible territories that aren't player-owned
                if (isInNebula && !isPlayerOwned) {
                    console.log(`üå´Ô∏è NEBULA TOOLTIP: Territory ${territory.id} in nebula - hiding fleet count (neutral: ${isNeutral})`);
                    if (isNeutral) {
                        // Neutral territory in nebula - show question marks
                        tooltipLines.push(`??? Fleets (nebula)`);
                    } else {
                        // Enemy territory in nebula - hide fleet count
                        tooltipLines.push(`Unknown forces (nebula)`);
                    }
                } else {
                    // Show full fleet information only for player territories OR non-nebula territories
                    // Calculate generation rate including supply bonuses
                    let generationRate = 0;
                    let fleetDisplay = `${territory.armySize} Fleets`;
                    
                    if (territory.ownerId !== null) {
                        // Check if this territory is a supply route source (redirects armies elsewhere)
                        const isSupplySource = gameData.supplySystem && gameData.supplySystem.supplyRoutes && 
                            gameData.supplySystem.supplyRoutes.some(route => route.from === territory.id);
                        
                        if (isSupplySource) {
                            // Supply source territories redirect all armies, so they show +0/s generation
                            generationRate = 0;
                        } else {
                            // Base generation rate (1 fleet per 3 seconds = 0.33/s)
                            generationRate = 1000 / (territory.armyGenerationRate || 3000);
                            
                            // Add supply route bonuses for destinations
                            if (gameData.supplySystem && gameData.supplySystem.supplyRoutes) {
                                const incomingRoutes = gameData.supplySystem.supplyRoutes.filter(route => route.to === territory.id);
                                generationRate += incomingRoutes.length * (1000 / 3000); // Each supply route adds base rate
                            }
                        }
                        
                        // Format generation rate with proper precision
                        if (generationRate > 0) {
                            const rateText = generationRate >= 1 ? 
                                `+${generationRate.toFixed(1)}/s` : 
                                `+${generationRate.toFixed(2)}/s`;
                            fleetDisplay += ` (${rateText})`;
                        }
                    }
                    
                    tooltipLines.push(fleetDisplay);
                }
                
                if (territory.isThronestar) {
                    tooltipLines.push(`üëë Throne Star`);
                }
                
                // Show supply route information if this territory is supplying another
                if (gameData.supplySystem && gameData.supplySystem.supplyRoutes) {
                    const outgoingRoutes = gameData.supplySystem.supplyRoutes.filter(route => route.from === territory.id);
                    if (outgoingRoutes.length > 0) {
                        outgoingRoutes.forEach(route => {
                            const targetTerritory = gameData.territories[route.to];
                            if (targetTerritory) {
                                tooltipLines.push(`Reinforcing star ${route.to}`);
                            }
                        });
                    }
                }
            }
            
            // Show battle odds if player has selected territory and this is an enemy
            if (gameData.selectedTerritory && 
                gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id &&
                territory.ownerId !== gameData.humanPlayer?.id &&
                territory.ownerId !== null) {
                

                
                // Check if territories are connected by star lane
                const isAdjacent = gameData.selectedTerritory.neighbors && 
                                 gameData.selectedTerritory.neighbors.includes(territory.id);
                

                
                if (isAdjacent && gameData.combatSystem) {
                    const attacker = gameData.humanPlayer;
                    const defender = gameData.players[territory.ownerId];
                    

                    
                    if (attacker && defender) {
                        const winChance = gameData.combatSystem.calculateBattleOdds(attacker, defender);

                        tooltipLines.push(`Battle Odds: ${winChance}% win`);
                    }
                }
            }
        }
        
        // Tooltip dimensions
        const padding = 8;
        const lineHeight = 16;
        const fontSize = 12;
        ctx.font = `${fontSize}px Arial`;
        
        const maxWidth = Math.max(...tooltipLines.map(line => ctx.measureText(line).width));
        const tooltipWidth = maxWidth + padding * 2;
        const tooltipHeight = tooltipLines.length * lineHeight + padding * 2;
        
        // Position tooltip near mouse but keep it on screen
        let tooltipX = mouseX + 15;
        let tooltipY = mouseY - tooltipHeight - 10;
        
        if (tooltipX + tooltipWidth > this.canvas.width) {
            tooltipX = mouseX - tooltipWidth - 15;
        }
        if (tooltipY < 0) {
            tooltipY = mouseY + 15;
        }
        
        // Draw tooltip background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip border
        ctx.strokeStyle = territoryColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip text
        ctx.fillStyle = '#ffffff';
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'left';
        
        tooltipLines.forEach((line, index) => {
            ctx.fillText(
                line,
                tooltipX + padding,
                tooltipY + padding + (index + 1) * lineHeight - 4
            );
        });
    }
    
    renderZoomControls(ctx, gameData) {
        const buttonSize = 50;
        const margin = 20;
        const spacing = 5;
        
        // Position in bottom left
        const zoomInX = margin;
        const zoomInY = this.canvas.height - margin - buttonSize;
        const zoomOutX = margin;
        const zoomOutY = this.canvas.height - margin - (buttonSize * 2) - spacing;
        
        // Current zoom percentage
        const zoomPercent = Math.round(gameData.camera?.zoom * 100) || 40;
        
        // Zoom Out button (-)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '-', zoomOutX + buttonSize/2, zoomOutY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom In button (+)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomInX, zoomInY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomInX, zoomInY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '+', zoomInX + buttonSize/2, zoomInY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom level display
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, `${zoomPercent}%`, zoomOutX + buttonSize/2, zoomOutY - 8, this.textColor);
    }
    
    renderGameOverScreen(ctx, gameData) {
        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 100, '#ff4444');
        
        // Subtitle
        ctx.font = '24px Arial';
        this.renderTextWithShadow(ctx, 'All your territories have been conquered!', this.canvas.width / 2, this.canvas.height / 2 - 50, this.textColor);
        
        // Spectator message
        ctx.font = '18px Arial';
        this.renderTextWithShadow(ctx, 'You can continue watching the game...', this.canvas.width / 2, this.canvas.height / 2, this.textColor);
        
        // Play Again button
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height / 2 + 50;
        
        // Button background
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button text
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'PLAY AGAIN', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2 + 7, '#ffffff');
    }
    
    renderFinalLeaderboard(ctx, gameData) {
        const startX = this.canvas.width / 2 - 250;
        const startY = this.canvas.height / 2 - 50;
        const width = 500;
        const itemHeight = 35;
        
        // Sort all players by territories controlled and show only top 10 for better readability
        const sortedPlayers = [...gameData.players]
            .sort((a, b) => b.territories.length - a.territories.length)
            .slice(0, 10);
        const height = 80 + sortedPlayers.length * itemHeight;
        
        // Background with shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(startX + 4, startY + 4, width, height);
        
        // Main background
        ctx.fillStyle = 'rgba(0, 20, 40, 0.95)';
        ctx.fillRect(startX, startY, width, height);
        
        // Border
        ctx.strokeStyle = '#00ddff';
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, width, height);
        
        // Title with shadow
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        
        // Title shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText('Final Results', startX + width / 2 + 2, startY + 42);
        
        // Main title
        ctx.fillStyle = '#00ddff';
        ctx.fillText('Final Results', startX + width / 2, startY + 40);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 80 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            const isWinner = index === 0 && !player.isEliminated;
            
            // Background for winner or human player
            if (isWinner) {
                ctx.fillStyle = 'rgba(68, 255, 68, 0.15)';
                ctx.fillRect(startX + 5, y - 22, width - 10, itemHeight - 2);
            } else if (isHuman) {
                ctx.fillStyle = 'rgba(0, 221, 255, 0.1)';
                ctx.fillRect(startX + 5, y - 22, width - 10, itemHeight - 2);
            }
            
            // Rank with shadow
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            
            // Rank shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(`${index + 1}.`, startX + 22, y + 2);
            
            // Main rank
            ctx.fillStyle = isWinner ? '#44ff44' : '#ffffff';
            ctx.fillText(`${index + 1}.`, startX + 20, y);
            
            // Player color indicator (larger)
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 60, y - 12, 20, 20);
            
            // Player name with shadow
            ctx.font = isHuman ? 'bold 18px Arial' : '18px Arial';
            
            // Name shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(player.name, startX + 92, y + 2);
            
            // Main name
            ctx.fillStyle = isHuman ? '#00ddff' : (isWinner ? '#44ff44' : '#ffffff');
            ctx.fillText(player.name, startX + 90, y);
            
            // Stats with shadow
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            
            // Stats shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(`${player.territories.length} territories`, startX + width - 102, y - 3);
            ctx.fillText(`${player.score} points`, startX + width - 102, y + 15);
            
            // Main stats
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`${player.territories.length} territories`, startX + width - 100, y - 5);
            ctx.fillText(`${player.score} points`, startX + width - 100, y + 13);
            
            // Status
            if (player.isEliminated) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillText('Eliminated', startX + width - 22, y + 2);
                ctx.fillStyle = '#ff4444';
                ctx.fillText('Eliminated', startX + width - 20, y);
            } else if (isWinner) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillText('Winner!', startX + width - 22, y + 2);
                ctx.fillStyle = '#44ff44';
                ctx.fillText('Winner!', startX + width - 20, y);
            }
        });
    }
    
    // Render notification messages for discoveries
    renderNotifications(ctx, gameData) {
        if (!gameData.notifications || gameData.notifications.length === 0) return;
        
        const notifications = gameData.notifications;
        const startY = 150; // Start below top UI elements
        const lineHeight = 40;
        const padding = 15;
        const maxWidth = 400;
        
        notifications.forEach((notification, index) => {
            const y = startY + index * lineHeight;
            const x = this.canvas.width - maxWidth - 20; // Right side of screen
            
            // Background with fade
            ctx.globalAlpha = notification.opacity;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Border based on notification type
            ctx.strokeStyle = notification.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Text
            ctx.fillStyle = notification.color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(notification.text, x, y);
            
            ctx.globalAlpha = 1.0; // Reset opacity
        });
    }
}


===============================================================================
CLIENT/SRC/GAME/GAMEMAP.JS - NEBULA DETECTION FUNCTION
===============================================================================

import { Territory } from './Territory.js';
import MapGenerator from './MapGenerator.js';

export class GameMap {
    constructor(width, height, config = {}) {
        this.width = width * 1.4; // Expand width by 40%
        this.height = height * 1.6; // Expand height by 60% for more vertical space
        this.territories = {};
        this.nebulas = []; // Purple nebula clouds
        this.gridSize = 150; // Increased space between territory centers for less crowding
        
        // Spatial indexing for O(1) territory lookups instead of O(n)
        this.spatialGridSize = 100; // Grid cell size in pixels
        this.spatialGrid = new Map(); // Map of "x,y" -> Territory[]
        this.spatialIndexEnabled = true;
        
        // Advanced configuration options
        this.layout = config.layout || 'organic'; // Layout type: organic, clusters, spiral, core, ring, binary
        this.connectionDistance = config.connectionRange || 60; // Max distance for territory connections - prevent long-distance warp lanes
        this.warpLaneDensity = config.warpLaneDensity || 80; // Percentage density for connections
        this.nebulaCount = config.nebulaCount !== undefined ? config.nebulaCount : 10; // Number of nebula fields
        this.nebulaSlowdown = config.nebulaSlowdown !== undefined ? config.nebulaSlowdown : true;
        this.supplyRoutes = config.supplyRoutes !== undefined ? config.supplyRoutes : true;
        this.probeColonization = config.probeColonization !== undefined ? config.probeColonization : true;
    }
    
    // Helper function to check if a point is within organic galaxy boundaries
    isWithinGalaxyBounds(x, y) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Calculate normalized position (0 to 1 from center)
        const normalizedX = (x - centerX) / (this.width / 2);
        const normalizedY = (y - centerY) / (this.height / 2);
        
        // Create organic galaxy shape using multiple sine waves for irregular edges
        const baseRadius = 0.75; // Base galaxy size (75% of max) for more padding
        
        // Use angle from center for perlin-like noise effect
        const angle = Math.atan2(normalizedY, normalizedX);
        
        // Create multiple frequency sine waves for organic edge variation
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        // Calculate distance from center
        const distanceFromCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        
        // Organic boundary with variation
        const maxDistance = baseRadius + edgeVariation;
        
        return distanceFromCenter <= maxDistance;
    }

    // Helper function to get max radius at a specific angle for organic boundary
    getMaxRadiusAtAngle(angle) {
        const baseRadius = 0.75; // Base galaxy size (75% of max) for more padding
        
        // Create organic edge variation using the same formula as boundary check
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        return baseRadius + edgeVariation;
    }

    // Helper function to check if a point is too close to existing points
    isValidPosition(x, y, existingPoints, minDistance = this.gridSize) {
        // First check if within organic galaxy boundaries
        if (!this.isWithinGalaxyBounds(x, y)) return false;
        
        // Then check minimum distance from other territories
        for (const point of existingPoints) {
            const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
            if (dist < minDistance) return false;
        }
        return true;
    }

    generateTerritories(count) {
        console.log(`üåå Generating ${count} territories using advanced ${this.layout} layout...`);
        
        // Use the advanced MapGenerator for sophisticated galaxy layouts
        const generatedTerritories = MapGenerator.generateMap(count, this.layout, 20); // Assume 20 players for cluster generation
        
        // Update map dimensions from MapGenerator
        this.width = MapGenerator.mapWidth;
        this.height = MapGenerator.mapHeight;
        
        // Convert generated territories to our game format - ALL have neutral garrisons
        generatedTerritories.forEach((territory, index) => {
            // Set up neutral garrison (1-30 armies visible)
            territory.isColonizable = false;
            territory.armySize = Math.floor(Math.random() * 30) + 1; // Visible garrison size
            territory.ownerId = null; // Neutral until captured
            
            // All connections are visible from the start (no hidden neighbors)
            // territory.neighbors already set by MapGenerator - keep them visible
            territory.hiddenNeighbors = []; // No hidden connections with new visibility system
            
            this.territories[index] = territory;
            
            // Spatial indexing for performance
            this.addToSpatialIndex(territory);
        });
        
        console.log(`‚ú® Generated ${count} territories with advanced ${this.layout} galaxy layout`);
        console.log(`üìê Map dimensions: ${this.width} x ${this.height}`);
        console.log(`üîó Sophisticated warp lane network with planar connectivity`);
        
        // Generate nebula fields AFTER territories to avoid overlaps
        this.generateNebulas();
    }
    
    /**
     * Fast map generation using simple algorithms to eliminate startup delay
     */
    generateTerritoriesFast(count) {
        console.log(`‚ö° Fast generating ${count} territories using simplified ${this.layout} layout...`);
        
        const territories = [];
        const points = [];
        
        // Simple Poisson disk sampling without expensive algorithms
        let attempts = 0;
        const maxAttempts = count * 10; // Limit attempts to prevent infinite loops
        
        while (territories.length < count && attempts < maxAttempts) {
            const x = Math.random() * this.width;
            const y = Math.random() * this.height;
            
            // Check if position is valid (within bounds and min distance from others)
            if (this.isValidPosition(x, y, points, this.gridSize * 0.8)) {
                const territory = new Territory({
                    id: territories.length,
                    x: x,
                    y: y,
                    armySize: Math.floor(Math.random() * 30) + 1, // Neutral garrison
                    ownerId: null,
                    neighbors: [],
                    hiddenNeighbors: []
                });
                
                territories.push(territory);
                points.push({ x, y });
                this.territories[territory.id] = territory;
                this.addToSpatialIndex(territory);
            }
            attempts++;
        }
        
        // Simple connection algorithm - connect nearby territories
        territories.forEach(territory => {
            const nearbyTerritories = territories.filter(other => {
                if (other.id === territory.id) return false;
                const distance = Math.hypot(other.x - territory.x, other.y - territory.y);
                return distance <= this.connectionDistance;
            });
            
            // Connect to 2-4 nearest neighbors to ensure connectivity
            nearbyTerritories
                .sort((a, b) => {
                    const distA = Math.hypot(a.x - territory.x, a.y - territory.y);
                    const distB = Math.hypot(b.x - territory.x, b.y - territory.y);
                    return distA - distB;
                })
                .slice(0, 3) // Connect to 3 closest neighbors
                .forEach(neighbor => {
                    if (!territory.neighbors.includes(neighbor.id)) {
                        territory.neighbors.push(neighbor.id);
                    }
                    if (!neighbor.neighbors.includes(territory.id)) {
                        neighbor.neighbors.push(territory.id);
                    }
                });
        });
        
        console.log(`‚ö° Fast generated ${territories.length} territories in simplified layout`);
        console.log(`üìê Map dimensions: ${this.width} x ${this.height}`);
        
        // Generate fewer nebulas for faster startup
        this.generateNebulas();
    }
    
    generateNebulas() {
        // Use configurable nebula count (0-20)
        const nebulaCount = this.nebulaCount;
        
        for (let i = 0; i < nebulaCount; i++) {
            let attempts = 0;
            let x, y;
            
            // Find positions within organic galaxy boundaries
            do {
                x = Math.random() * this.width;
                y = Math.random() * this.height;
                attempts++;
            } while (!this.isWithinGalaxyBounds(x, y) && attempts < 50);
            
            // If we couldn't find a valid position after many attempts, skip this nebula
            if (attempts >= 50) continue;
            
            const nebula = {
                x: x,
                y: y,
                radius: 80 + Math.random() * 120, // Size varies from 80 to 200
                opacity: 0.3 + Math.random() * 0.4, // Opacity varies from 0.3 to 0.7
                color: `rgba(147, 51, 234, ${0.3 + Math.random() * 0.4})` // Purple with varying opacity
            };
            this.nebulas.push(nebula);
        }
        
        console.log(`Generated ${nebulaCount} nebula fields (configured: ${this.nebulaCount})`);
    }
    


    // ===== OBSOLETE METHODS REMOVED =====
    // The following legacy layout generation methods have been replaced by the advanced MapGenerator class:
    // - poissonDiskSampling() - replaced by MapGenerator.generateMap() with organic layout
    // - generateClusterLayout() - replaced by MapGenerator cluster algorithm with Delaunay triangulation
    // - generateSpiralLayout() - replaced by MapGenerator spiral algorithm with force-directed relaxation
    // - generateCoreLayout() - replaced by MapGenerator core algorithm with MST connectivity
    // - generateRingLayout() - replaced by MapGenerator ring algorithm with optimal spacing
    // - generateBinaryLayout() - replaced by MapGenerator binary algorithm with planar connections
    // - connectTerritoriesForLayout() - replaced by MapGenerator's sophisticated warp lane networks
    //
    // All map generation now uses the advanced MapGenerator class which provides:
    // ‚úÖ Delaunay triangulation for planar connectivity (no crossing warp lanes)
    // ‚úÖ Minimum Spanning Tree algorithms for optimal path networks
    // ‚úÖ Force-directed relaxation for natural territory spacing
    // ‚úÖ Collision detection preventing lanes from cutting through territories
    // ‚úÖ Six distinct galaxy layouts with unique characteristics
    

    

    
    generateRingLayout(count) {
        const points = [];
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const rings = 4 + Math.floor(Math.random() * 3); // 4-6 rings
        const planetsPerRing = Math.floor(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = 60 + ring * 70; // Rings spaced 70 units apart
            const ringPlanets = ring === rings - 1 ? 
                count - (planetsPerRing * ring) : planetsPerRing;
            
            for (let i = 0; i < ringPlanets; i++) {
                let attempts = 0;
                let validPoint = false;
                
                while (!validPoint && attempts < 100) {
                    const angle = (i / ringPlanets) * 2 * Math.PI + (Math.random() - 0.5) * 0.3;
                    const ringRadius = radius + (Math.random() - 0.5) * 30; // Slight radius variation
                    
                    const x = centerX + Math.cos(angle) * ringRadius;
                    const y = centerY + Math.sin(angle) * ringRadius;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        validPoint = true;
                    }
                    attempts++;
                }
                
                // Fallback: random placement if ring placement fails
                if (!validPoint) {
                    for (let j = 0; j < 50; j++) {
                        const x = Math.random() * (this.width - 60) + 30;
                        const y = Math.random() * (this.height - 60) + 30;
                        
                        if (this.isValidPosition(x, y, points)) {
                            points.push({ x, y });
                            break;
                        }
                    }
                }
            }
        }
        
        return points;
    }
    
    generateBinaryLayout(count) {
        const points = [];
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        const systemRadius = Math.min(this.width, this.height) * 0.25;
        
        // Split planets between two major systems
        const leftCount = Math.floor(count / 2);
        const rightCount = count - leftCount;
        
        // Left system
        for (let i = 0; i < leftCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = leftCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        // Right system
        for (let i = 0; i < rightCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = rightCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        return points;
    }
    
    connectTerritoriesForLayout() {
        // Different connection strategies based on layout
        switch (this.layout) {
            case 'clusters':
                this.connectClusters();
                break;
            case 'spiral':
                this.connectSpiral();
                break;
            case 'core':
                this.connectCore();
                break;
            case 'ring':
                this.connectRings();
                break;
            case 'binary':
                this.connectBinary();
                break;
            case 'organic':
            default:
                this.connectTerritories();
                break;
        }
    }
    
    connectClusters() {
        const territoryList = Object.values(this.territories);
        
        // First connect within clusters (short distance connections)
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const closeNeighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) { // Close cluster connections
                    closeNeighbors.push({ territory: other, distance });
                }
            }
            
            closeNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, closeNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = closeNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Then add bridge connections between clusters
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const bridgeTargets = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance > this.connectionDistance * 0.8 && distance <= this.connectionDistance * 1.5) { // Bridge connections
                    bridgeTargets.push({ territory: other, distance });
                }
            }
            
            if (bridgeTargets.length > 0) {
                bridgeTargets.sort((a, b) => a.distance - b.distance);
                const neighbor = bridgeTargets[0].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectSpiral() {
        const territoryList = Object.values(this.territories);
        
        // Connect along spiral arms and between nearby arms
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, neighbors.length); // Fewer connections for spiral
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectCore() {
        const territoryList = Object.values(this.territories);
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Identify core territories (close to center)
        const coreTerritories = territoryList.filter(t => {
            const distToCenter = Math.sqrt((t.x - centerX) ** 2 + (t.y - centerY) ** 2);
            return distToCenter <= 100;
        });
        
        // Dense connections in core
        for (const territory of coreTerritories) {
            const coreNeighbors = [];
            
            for (const other of coreTerritories) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    coreNeighbors.push({ territory: other, distance });
                }
            }
            
            coreNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(5, coreNeighbors.length); // Dense core
            
            for (let k = 0; k < connections; k++) {
                const neighbor = coreNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Radial connections from core to shells
        for (const territory of territoryList) {
            if (coreTerritories.includes(territory)) continue;
            
            const radialNeighbors = [];
            for (const other of territoryList) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    radialNeighbors.push({ territory: other, distance });
                }
            }
            
            radialNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, radialNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = radialNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectRings() {
        const territoryList = Object.values(this.territories);
        
        // Connect within rings and between adjacent rings
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, neighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectBinary() {
        const territoryList = Object.values(this.territories);
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        
        // Identify left and right system territories
        const leftSystem = territoryList.filter(t => t.x < this.width / 2);
        const rightSystem = territoryList.filter(t => t.x >= this.width / 2);
        
        // Connect within each system
        [leftSystem, rightSystem].forEach(system => {
            for (const territory of system) {
                const systemNeighbors = [];
                
                for (const other of system) {
                    if (territory.id === other.id) continue;
                    const distance = territory.getDistanceTo(other);
                    
                    if (distance <= this.connectionDistance) {
                        systemNeighbors.push({ territory: other, distance });
                    }
                }
                
                systemNeighbors.sort((a, b) => a.distance - b.distance);
                const connections = Math.min(4, systemNeighbors.length);
                
                for (let k = 0; k < connections; k++) {
                    const neighbor = systemNeighbors[k].territory;
                    territory.addNeighbor(neighbor.id);
                    neighbor.addNeighbor(territory.id);
                }
            }
        });
        
        // Add bridge connections between systems
        const bridgeConnections = Math.min(3, Math.min(leftSystem.length, rightSystem.length));
        for (let i = 0; i < bridgeConnections; i++) {
            const leftTerr = leftSystem[Math.floor(Math.random() * leftSystem.length)];
            const rightTerr = rightSystem[Math.floor(Math.random() * rightSystem.length)];
            
            leftTerr.addNeighbor(rightTerr.id);
            rightTerr.addNeighbor(leftTerr.id);
        }
    }
    
    // Check if a line between two territories passes through any other territory or existing warp lanes
    linePassesThroughTerritory(from, to, allTerritories, existingConnections = []) {
        // Check collision with other territories
        for (const territory of allTerritories) {
            if (territory.id === from.id || territory.id === to.id) continue;
            
            // Calculate distance from territory center to line segment
            const A = from.x;
            const B = from.y;
            const C = to.x;
            const D = to.y;
            const E = territory.x;
            const F = territory.y;
            
            // Vector from from to to
            const dx = C - A;
            const dy = D - B;
            
            // Vector from from to territory
            const ex = E - A;
            const ey = F - B;
            
            // Project territory onto line
            const dot = ex * dx + ey * dy;
            const lenSquared = dx * dx + dy * dy;
            
            if (lenSquared === 0) continue; // Line has no length
            
            const t = Math.max(0, Math.min(1, dot / lenSquared));
            
            // Closest point on line segment
            const closestX = A + t * dx;
            const closestY = B + t * dy;
            
            // Distance from territory to closest point on line
            const distToLine = Math.sqrt((E - closestX) ** 2 + (F - closestY) ** 2);
            
            // If line passes too close to territory (within its radius + larger margin)
            if (distToLine < territory.radius + 30) { // Increased margin from 15 to 30
                return true;
            }
        }
        
        // Check collision with existing warp lanes
        for (const connection of existingConnections) {
            if (this.linesIntersect(from, to, connection.from, connection.to)) {
                return true;
            }
        }
        
        return false;
    }
    
    // Check if two line segments intersect
    linesIntersect(line1Start, line1End, line2Start, line2End) {
        const x1 = line1Start.x, y1 = line1Start.y;
        const x2 = line1End.x, y2 = line1End.y;
        const x3 = line2Start.x, y3 = line2Start.y;
        const x4 = line2End.x, y4 = line2End.y;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return false; // Lines are parallel
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        // Check if intersection point is within both line segments
        if (t >= 0.1 && t <= 0.9 && u >= 0.1 && u <= 0.9) { // Added small margin to avoid endpoint intersections
            return true;
        }
        
        return false;
    }

    connectTerritories() {
        const territoryList = Object.values(this.territories);
        const existingConnections = []; // Track existing warp lanes to prevent intersections
        
        // Use Delaunay triangulation approximation for natural connections
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const nearbyTerritories = [];
            
            // Find all territories within connection distance
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance && !this.linePassesThroughTerritory(territory, other, territoryList, existingConnections)) {
                    nearbyTerritories.push({ territory: other, distance });
                }
            }
            
            // Sort by distance and connect to closest neighbors
            nearbyTerritories.sort((a, b) => a.distance - b.distance);
            
            // Connect to 2-6 closest neighbors, influenced by warp lane density
            const baseDensity = this.warpLaneDensity / 100; // Convert percentage to decimal
            const maxConnections = Math.min(6, Math.max(2, nearbyTerritories.length));
            const adjustedConnections = Math.max(1, Math.floor(maxConnections * baseDensity));
            const numConnections = Math.min(adjustedConnections, 2 + Math.floor(Math.random() * 3));
            
            for (let k = 0; k < numConnections && k < nearbyTerritories.length; k++) {
                const neighbor = nearbyTerritories[k].territory;
                
                // Additional density check - some connections may be skipped based on density
                if (Math.random() * 100 > this.warpLaneDensity) continue;
                
                // Track this connection to prevent future intersections
                existingConnections.push({
                    from: territory,
                    to: neighbor
                });
                
                // All connections are now regular neighbors (no hidden connections)
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Ensure connectivity by connecting isolated territories
        this.ensureConnectivity();
    }
    
    ensureConnectivity() {
        const visited = new Set();
        const territoryIds = Object.keys(this.territories);
        
        if (territoryIds.length === 0) return;
        
        // BFS to find connected components
        const bfs = (startId) => {
            const queue = [startId];
            const component = [];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                if (visited.has(currentId)) continue;
                
                visited.add(currentId);
                component.push(currentId);
                
                const territory = this.territories[currentId];
                territory.neighbors.forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        queue.push(neighborId);
                    }
                });
            }
            
            return component;
        };
        
        const components = [];
        
        // Find all connected components
        territoryIds.forEach(id => {
            if (!visited.has(id)) {
                components.push(bfs(id));
            }
        });
        
        // Connect isolated components
        while (components.length > 1) {
            const comp1 = components[0];
            const comp2 = components[1];
            
            // Find closest territories between components
            let minDistance = Infinity;
            let bestConnection = null;
            
            comp1.forEach(id1 => {
                const territory1 = this.territories[id1];
                comp2.forEach(id2 => {
                    const territory2 = this.territories[id2];
                    const distance = territory1.getDistanceTo(territory2);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestConnection = { territory1, territory2 };
                    }
                });
            });
            
            // Connect the closest territories
            if (bestConnection) {
                bestConnection.territory1.addNeighbor(bestConnection.territory2.id);
                bestConnection.territory2.addNeighbor(bestConnection.territory1.id);
            }
            
            // Merge components
            components[0] = comp1.concat(comp2);
            components.splice(1, 1);
        }
    }
    
    // Get territories within a rectangular area (for culling)
    getTerritoriesInBounds(bounds) {
        const result = [];
        
        Object.values(this.territories).forEach(territory => {
            if (territory.x + territory.radius >= bounds.left &&
                territory.x - territory.radius <= bounds.right &&
                territory.y + territory.radius >= bounds.top &&
                territory.y - territory.radius <= bounds.bottom) {
                result.push(territory);
            }
        });
        
        return result;
    }
    
    // Find nearest territory to a point
    findNearestTerritory(x, y) {
        let nearest = null;
        let minDistance = Infinity;
        
        Object.values(this.territories).forEach(territory => {
            const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = territory;
            }
        });
        
        return nearest;
    }
    
    // Get map statistics
    getMapStats() {
        const territoryCount = Object.keys(this.territories).length;
        let totalConnections = 0;
        let neutralTerritories = 0;
        
        Object.values(this.territories).forEach(territory => {
            totalConnections += territory.neighbors.length;
            if (territory.ownerId === null) {
                neutralTerritories++;
            }
        });
        
        return {
            territories: territoryCount,
            connections: totalConnections / 2, // Each connection counted twice
            averageConnections: totalConnections / territoryCount,
            neutralTerritories: neutralTerritories,
            width: this.width,
            height: this.height
        };
    }
    
    // Serialize map data for network transmission (future multiplayer)
    serialize() {
        const serializedTerritories = {};
        
        Object.keys(this.territories).forEach(id => {
            serializedTerritories[id] = this.territories[id].serialize();
        });
        
        return {
            width: this.width,
            height: this.height,
            territories: serializedTerritories
        };
    }
    
    // Deserialize map data from network (future multiplayer)
    static deserialize(data) {
        const map = new GameMap(data.width, data.height);
        
        Object.keys(data.territories).forEach(id => {
            map.territories[id] = Territory.deserialize(data.territories[id]);
        });
        
        return map;
    }
    
    isInNebula(x, y) {
        // Check if a point is inside any nebula
        for (const nebula of this.nebulas) {
            const distance = Math.sqrt((x - nebula.x) ** 2 + (y - nebula.y) ** 2);
            if (distance <= nebula.radius) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Add territory to spatial index for O(1) lookups
     */
    addToSpatialIndex(territory) {
        if (!this.spatialIndexEnabled) return;
        
        const gridX = Math.floor(territory.x / this.spatialGridSize);
        const gridY = Math.floor(territory.y / this.spatialGridSize);
        const key = `${gridX},${gridY}`;
        
        if (!this.spatialGrid.has(key)) {
            this.spatialGrid.set(key, []);
        }
        this.spatialGrid.get(key).push(territory);
    }
    
    /**
     * Find territory at coordinates using spatial indexing (O(1) vs O(n))
     */
    findTerritoryAt(x, y) {
        if (!this.spatialIndexEnabled) {
            // Fallback to linear search
            return Object.values(this.territories).find(territory => {
                const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                return distance <= territory.radius;
            });
        }
        
        // Spatial index lookup - check only nearby cells
        const gridX = Math.floor(x / this.spatialGridSize);
        const gridY = Math.floor(y / this.spatialGridSize);
        
        // Check current cell and adjacent cells (3x3 grid)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${gridX + dx},${gridY + dy}`;
                const cellTerritories = this.spatialGrid.get(key);
                
                if (cellTerritories) {
                    for (const territory of cellTerritories) {
                        const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                        if (distance <= territory.radius) {
                            return territory;
                        }
                    }
                }
            }
        }
        return null;
    }
    
    /**
     * Build spatial index for all territories
     */
    buildSpatialIndex() {
        if (!this.spatialIndexEnabled) return;
        
        this.spatialGrid.clear();
        Object.values(this.territories).forEach(territory => {
            this.addToSpatialIndex(territory);
        });
    }
}


===============================================================================
CLIENT/SRC/GAME/RENDERER.JS - SUPPLY ROUTE INDICATOR RENDERING
===============================================================================

/**
 * Renderer.js - Dedicated rendering module
 * 
 * Exclusively responsible for all drawing operations on the HTML5 Canvas.
 * Receives game state and renders it without modifying the state.
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants';

export class Renderer {
    constructor(canvas, camera, game = null) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.camera = camera;
        this.game = game;
        
        // Performance tracking
        this.visibleTerritories = 0;
        this.lastVisibilityUpdate = 0;
        
        // Object pooling for ship animations
        this.shipAnimationPool = [];
        this.activeShipAnimations = [];
        
        // Parallax starfield layers
        this.starLayers = {
            far: [],
            mid: [],
            near: []
        };
        
        this.setupCanvas();
        this.initializeStarfield();
    }
    
    setupCanvas() {
        // Set canvas size
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        
        // Configure context settings
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.camera.updateViewport(this.canvas.width, this.canvas.height);
        });
    }
    
    initializeStarfield() {
        // Generate three layers of parallax stars
        const generateStars = (count, minSize, maxSize, minOpacity, maxOpacity) => {
            const stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_WIDTH * 1.5,
                    y: Math.random() * GAME_CONSTANTS.DEFAULT_MAP_HEIGHT * 1.5,
                    size: Math.random() * (maxSize - minSize) + minSize,
                    opacity: Math.random() * (maxOpacity - minOpacity) + minOpacity,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            return stars;
        };
        
        this.starLayers.far = generateStars(300, 0.5, 1.0, 0.2, 0.4);
        this.starLayers.mid = generateStars(150, 1.0, 1.5, 0.3, 0.6);
        this.starLayers.near = generateStars(80, 1.5, 2.5, 0.4, 0.8);
    }
    
    render(gameData) {
        const startTime = performance.now();
        
        // Clear canvas
        this.ctx.fillStyle = GAME_CONSTANTS.BACKGROUND_COLOR;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Apply camera transform
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render parallax starfield
        this.renderStarfield();
        
        // Render nebulas (behind territories)
        this.renderNebulas(gameData.gameMap);
        
        // Update visible territories for performance
        this.updateVisibleTerritories(gameData.gameMap);
        
        // Render game objects
        this.renderConnections(gameData.gameMap);
        this.renderSupplyRoutes(gameData.supplyRoutes);
        this.renderTerritories(gameData.gameMap, gameData.humanPlayer, gameData.discoveries);
        this.renderProbes(gameData.probes, gameData.gameMap);
        this.renderShipAnimations();
        
        // Render selection and drag preview
        if (gameData.inputState?.selectedTerritory) {
            this.renderSelection(gameData.inputState.selectedTerritory);
        }
        this.renderDragPreview(gameData);
        
        this.ctx.restore();
        
        // Render UI (screen coordinates)
        this.renderUI(gameData);
        
        const renderTime = performance.now() - startTime;
        return { renderTime, visibleTerritories: this.visibleTerritories };
    }
    
    renderStarfield() {
        const viewBounds = this.camera.getViewBounds();
        const cameraPos = this.camera.getWorldCenter();
        
        // Render each layer with different parallax factors
        this.renderStarLayer(this.starLayers.far, 0.05, viewBounds, cameraPos);
        this.renderStarLayer(this.starLayers.mid, 0.15, viewBounds, cameraPos);
        this.renderStarLayer(this.starLayers.near, 0.30, viewBounds, cameraPos);
    }
    
    renderStarLayer(stars, parallaxFactor, viewBounds, cameraPos) {
        this.ctx.save();
        
        for (const star of stars) {
            // Apply parallax offset
            const parallaxX = star.x - cameraPos.x * parallaxFactor;
            const parallaxY = star.y - cameraPos.y * parallaxFactor;
            
            // Viewport culling
            if (parallaxX < viewBounds.left - 50 || parallaxX > viewBounds.right + 50 ||
                parallaxY < viewBounds.top - 50 || parallaxY > viewBounds.bottom + 50) {
                continue;
            }
            
            // Twinkling animation
            star.twinklePhase += star.twinkleSpeed;
            const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
            const opacity = star.opacity * twinkle;
            
            this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.restore();
    }
    
    renderNebulas(gameMap) {
        if (!gameMap.nebulas) return;
        
        const viewBounds = this.camera.getViewBounds();
        
        for (const nebula of gameMap.nebulas) {
            // Viewport culling
            if (nebula.x + nebula.radius < viewBounds.left || nebula.x - nebula.radius > viewBounds.right ||
                nebula.y + nebula.radius < viewBounds.top || nebula.y - nebula.radius > viewBounds.bottom) {
                continue;
            }
            
            // Create radial gradient
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, 'rgba(128, 0, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(64, 0, 128, 0.2)');
            gradient.addColorStop(1, 'rgba(32, 0, 64, 0.1)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    updateVisibleTerritories(gameMap) {
        const now = Date.now();
        if (now - this.lastVisibilityUpdate < 100) return; // Throttle to 10fps
        
        this.lastVisibilityUpdate = now;
        this.visibleTerritories = 0;
        
        const viewBounds = this.camera.getViewBounds();
        const margin = 50;
        
        for (const territory of Object.values(gameMap.territories)) {
            if (this.camera.isRectVisible(
                territory.x - territory.radius, territory.y - territory.radius,
                territory.radius * 2, territory.radius * 2, margin
            )) {
                territory.isVisible = true;
                this.visibleTerritories++;
            } else {
                territory.isVisible = false;
            }
        }
    }
    
    renderConnections(gameMap, players = []) {
        this.ctx.save();
        this.ctx.strokeStyle = GAME_CONSTANTS.CONNECTION_COLOR;
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.6;
        
        const renderedConnections = new Set();
        
        for (const territory of Object.values(gameMap.territories)) {
            if (!territory.isVisible) continue;
            
            for (const neighborId of territory.neighbors) {
                const neighbor = gameMap.territories[neighborId];
                if (!neighbor || !neighbor.isVisible) continue;
                
                // Avoid duplicate rendering
                const connectionKey = territory.id < neighborId ? 
                    `${territory.id}-${neighborId}` : `${neighborId}-${territory.id}`;
                
                if (renderedConnections.has(connectionKey)) continue;
                renderedConnections.add(connectionKey);
                
                // FOG OF WAR: Show star lanes if either:
                // 1. At least one end is owned by the human player (current visibility)
                // 2. The lane was previously discovered (permanent knowledge)
                const humanPlayerId = this.game?.humanPlayer?.id;
                const territoryOwnedByPlayer = territory.ownerId === humanPlayerId;
                const neighborOwnedByPlayer = neighbor.ownerId === humanPlayerId;
                const laneDiscovered = this.game?.discoveredLanes?.has(connectionKey);
                
                if (!territoryOwnedByPlayer && !neighborOwnedByPlayer && !laneDiscovered) {
                    // Neither territory is owned by player AND lane not previously discovered
                    continue;
                }
                
                // Add newly visible lanes to permanent discovery
                if ((territoryOwnedByPlayer || neighborOwnedByPlayer) && !laneDiscovered && this.game?.discoveredLanes) {
                    this.game.discoveredLanes.add(connectionKey);
                    console.log(`üó∫Ô∏è Star lane discovered: ${territory.id} ‚Üî ${neighborId}`);
                }
                
                // Color connections between same-owned territories
                if (territory.ownerId && territory.ownerId === neighbor.ownerId) {
                    const player = this.findPlayerById(territory.ownerId);
                    this.ctx.strokeStyle = player?.color || GAME_CONSTANTS.CONNECTION_COLOR;
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.8;
                } else {
                    this.ctx.strokeStyle = GAME_CONSTANTS.CONNECTION_COLOR;
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.6;
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            }
        }
        
        this.ctx.restore();
    }
    
    renderSupplyRoutes(supplyRoutes) {
        if (!supplyRoutes || supplyRoutes.length === 0) return;
        
        this.ctx.save();
        this.ctx.strokeStyle = GAME_CONSTANTS.SUPPLY_ROUTE_COLOR;
        this.ctx.lineWidth = 3;
        this.ctx.globalAlpha = 0.8;
        
        const currentTime = Date.now();
        const dashOffset = (currentTime * GAME_CONSTANTS.SUPPLY_ROUTE_DASH_ANIMATION_SPEED) % 20;
        this.ctx.setLineDash([10, 10]);
        this.ctx.lineDashOffset = dashOffset;
        
        for (const route of supplyRoutes) {
            if (!route.active || !route.path || route.path.length < 2) continue;
            
            this.ctx.beginPath();
            const firstTerritory = route.path[0];
            this.ctx.moveTo(firstTerritory.x, firstTerritory.y);
            
            for (let i = 1; i < route.path.length; i++) {
                const territory = route.path[i];
                this.ctx.lineTo(territory.x, territory.y);
            }
            
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
    
    renderTerritories(gameMap, humanPlayer, discoveries = []) {
        const currentTime = Date.now();
        const zoomLevel = this.camera.getZoomLevel();
        
        // Level of Detail rendering
        const showDetails = zoomLevel > 0.5;
        const showNumbers = zoomLevel > 0.3;
        
        for (const territory of Object.values(gameMap.territories)) {
            if (!territory.isVisible) continue;
            
            this.ctx.save();
            
            // Render territory circle
            this.renderTerritoryCircle(territory, currentTime, humanPlayer);
            
            // Render throne star crown
            if (territory.isThronestar) {
                this.renderThroneStarCrown(territory);
            }
            
            // Render army count for all territories (no more colonizable planets)
            if (showNumbers) {
                this.renderArmyCount(territory);
            }
            
            // Always render supply route indicators regardless of zoom level
            this.renderSupplyRouteIndicators(territory);
            
            // Render floating text
            if (territory.floatingText && showDetails) {
                this.renderFloatingText(territory);
            }
            
            // Render human player flag
            if (territory.ownerId === humanPlayer?.id && showDetails) {
                this.renderHumanPlayerFlag(territory);
            }
            
            this.ctx.restore();
        }
    }
    
    renderTerritoryCircle(territory, currentTime, humanPlayer) {
        // Flash effects
        let flashAlpha = 1.0;
        if (territory.combatFlashTime && currentTime - territory.combatFlashTime < territory.combatFlashDuration) {
            flashAlpha = 0.3 + 0.7 * Math.sin((currentTime - territory.combatFlashTime) * 0.02);
        }
        
        // Base color
        let fillColor = territory.baseColor;
        if (territory.ownerId) {
            const player = this.findPlayerById(territory.ownerId);
            fillColor = player?.color || territory.baseColor;
        }
        
        // Human player pulsing effect
        if (territory.ownerId === humanPlayer?.id) {
            const pulseIntensity = 0.3 + 0.2 * Math.sin(currentTime * 0.005);
            this.ctx.globalAlpha = pulseIntensity;
            this.ctx.fillStyle = '#00ffff';
            this.ctx.beginPath();
            this.ctx.arc(territory.x, territory.y, territory.radius + 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Main territory circle
        this.ctx.globalAlpha = flashAlpha;
        this.ctx.fillStyle = fillColor;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Border
        this.ctx.strokeStyle = territory.strokeColor;
        this.ctx.lineWidth = territory.ownerId === humanPlayer?.id ? 3 : 2;
        this.ctx.stroke();
    }
    
    renderThroneStarCrown(territory) {
        const crownSize = 8;
        const crownY = territory.y - territory.radius - 10;
        
        this.ctx.fillStyle = '#FFD700';
        this.ctx.strokeStyle = '#FFA500';
        this.ctx.lineWidth = 1;
        
        // Crown base
        this.ctx.fillRect(territory.x - crownSize, crownY, crownSize * 2, crownSize * 0.6);
        
        // Crown spikes
        this.ctx.beginPath();
        this.ctx.moveTo(territory.x - crownSize, crownY);
        this.ctx.lineTo(territory.x - crownSize * 0.5, crownY - crownSize * 0.8);
        this.ctx.lineTo(territory.x, crownY - crownSize);
        this.ctx.lineTo(territory.x + crownSize * 0.5, crownY - crownSize * 0.8);
        this.ctx.lineTo(territory.x + crownSize, crownY);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    }
    
    renderColonizableIndicator(territory) {
        const pulsePhase = territory.pulsePhase || 0;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(pulsePhase * 0.05);
        
        this.ctx.fillStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
        this.ctx.font = 'bold 16px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // Text shadow
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.lineWidth = 3;
        this.ctx.strokeText('?', territory.x, territory.y);
        this.ctx.fillText('?', territory.x, territory.y);
    }
    
    renderArmyCount(territory) {
        this.ctx.fillStyle = 'black';
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 2;
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // Check if this star is reinforcing another star
        const isReinforcingSource = this.game?.supplySystem?.isSupplySource(territory.id);
        
        let text = territory.armySize.toString();
        if (isReinforcingSource) {
            text = `‚óè ${text}`; // Add black dot indicator for reinforcing stars
        }
        
        this.ctx.strokeText(text, territory.x, territory.y);
        this.ctx.fillText(text, territory.x, territory.y);
    }
    
    renderSupplyRouteIndicators(territory) {
        if (!this.game?.supplySystem?.supplyRoutes) {
            // Debug: Only log when needed
            if (!this.lastSupplySystemLog || Date.now() - this.lastSupplySystemLog > 15000) {
                console.log('üìä Supply debug: routes exist?', !!this.game?.supplySystem?.supplyRoutes, 'count:', this.game?.supplySystem?.supplyRoutes?.length || 0);
                this.lastSupplySystemLog = Date.now();
            }
            return;
        }
        
        // Count incoming supply routes to this territory
        const incomingRoutes = this.game.supplySystem.supplyRoutes.filter(route => route.to === territory.id);
        const reinforcementCount = incomingRoutes.length;
        
        // Debug: Log supply route indicators being rendered
        if (reinforcementCount > 0) {
            console.log(`üîß Rendering ${reinforcementCount} supply indicators for territory ${territory.id}`);
        }
        
        // TEMP TEST: Force render supply indicators on human player territories for testing
        const humanPlayerId = this.game?.humanPlayer?.id;
        if (territory.ownerId === humanPlayerId && territory.id % 3 === 0) { // Every 3rd human territory gets test indicator
            console.log(`üß™ TEST: Adding fake supply indicator to territory ${territory.id}, humanPlayerId=${humanPlayerId}`);
            const yOffset = territory.radius + 15;
            this.ctx.fillStyle = '#00ff00'; // Green color
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 1;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.strokeText('+', territory.x, territory.y + yOffset);
            this.ctx.fillText('+', territory.x, territory.y + yOffset);
        }
        
        if (reinforcementCount > 0) {
            // Create + symbols underneath the territory
            const plusSymbols = '+'.repeat(reinforcementCount);
            
            // Position below the territory circle
            const yOffset = territory.radius + 15;
            
            this.ctx.fillStyle = '#00ff00'; // Green color for reinforcement indicators
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 1;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // Draw text with outline for visibility
            this.ctx.strokeText(plusSymbols, territory.x, territory.y + yOffset);
            this.ctx.fillText(plusSymbols, territory.x, territory.y + yOffset);
        }
    }
    
    renderFloatingText(territory) {
        if (!territory.floatingText || Date.now() > territory.floatingText.endTime) {
            territory.floatingText = null;
            return;
        }
        
        const elapsed = Date.now() - territory.floatingText.startTime;
        const progress = elapsed / territory.floatingText.duration;
        const yOffset = -progress * 30;
        const alpha = 1.0 - progress;
        
        this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        this.ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
        this.ctx.lineWidth = 2;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        const text = territory.floatingText.text;
        const textY = territory.y + yOffset - territory.radius - 10;
        
        this.ctx.strokeText(text, territory.x, textY);
        this.ctx.fillText(text, territory.x, textY);
    }
    
    renderHumanPlayerFlag(territory) {
        const flagSize = 6;
        const flagX = territory.x + territory.radius - flagSize;
        const flagY = territory.y - territory.radius + flagSize;
        
        // Flag pole
        this.ctx.strokeStyle = '#888888';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(flagX, flagY);
        this.ctx.lineTo(flagX, flagY + flagSize * 2);
        this.ctx.stroke();
        
        // Flag
        this.ctx.fillStyle = '#00ffff';
        this.ctx.fillRect(flagX, flagY, flagSize, flagSize);
        
        // Star on flag
        this.ctx.fillStyle = 'white';
        this.ctx.font = '8px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('‚òÖ', flagX + flagSize/2, flagY + flagSize/2);
    }
    
    renderProbes(probes, gameMap) {
        const currentTime = Date.now();
        
        for (const probe of probes) {
            if (!probe.isVisible) continue;
            
            const fromTerritory = gameMap.territories[probe.fromTerritoryId];
            const toTerritory = gameMap.territories[probe.toTerritoryId];
            
            if (!fromTerritory || !toTerritory) continue;
            
            // Calculate current position
            const progress = probe.progress;
            const x = fromTerritory.x + (toTerritory.x - fromTerritory.x) * progress;
            const y = fromTerritory.y + (toTerritory.y - fromTerritory.y) * progress;
            
            // Check if probe is in nebula
            let inNebula = false;
            if (gameMap.nebulas) {
                for (const nebula of gameMap.nebulas) {
                    const distance = Math.sqrt((x - nebula.x) ** 2 + (y - nebula.y) ** 2);
                    if (distance < nebula.radius) {
                        inNebula = true;
                        break;
                    }
                }
            }
            
            this.ctx.save();
            
            // Probe visual effects
            if (inNebula) {
                const fadeAlpha = 0.3 + 0.4 * Math.sin(currentTime * 0.01);
                this.ctx.globalAlpha = fadeAlpha;
            }
            
            // Probe circle
            this.ctx.fillStyle = probe.playerColor;
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
            
            // Probe trail
            this.ctx.strokeStyle = probe.playerColor;
            this.ctx.lineWidth = 2;
            this.ctx.globalAlpha = 0.5;
            this.ctx.beginPath();
            
            const trailLength = 20;
            const trailStartProgress = Math.max(0, progress - 0.1);
            const trailStartX = fromTerritory.x + (toTerritory.x - fromTerritory.x) * trailStartProgress;
            const trailStartY = fromTerritory.y + (toTerritory.y - fromTerritory.y) * trailStartProgress;
            
            this.ctx.moveTo(trailStartX, trailStartY);
            this.ctx.lineTo(x, y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }
    }
    
    renderShipAnimations() {
        const currentTime = Date.now();
        
        for (let i = this.activeShipAnimations.length - 1; i >= 0; i--) {
            const animation = this.activeShipAnimations[i];
            
            if (currentTime >= animation.endTime) {
                // Return to pool
                this.shipAnimationPool.push(animation);
                this.activeShipAnimations.splice(i, 1);
                continue;
            }
            
            this.renderShipAnimation(animation, currentTime);
        }
    }
    
    renderShipAnimation(animation, currentTime) {
        const elapsed = currentTime - animation.startTime;
        const progress = elapsed / animation.duration;
        
        // Multi-hop animation
        if (animation.segments && animation.segments.length > 1) {
            this.renderMultiHopShipAnimation(animation, progress);
        } else {
            this.renderSingleShipAnimation(animation, progress);
        }
    }
    
    renderSingleShipAnimation(animation, progress) {
        const x = animation.from.x + (animation.to.x - animation.from.x) * progress;
        const y = animation.from.y + (animation.to.y - animation.from.y) * progress;
        
        this.ctx.save();
        this.ctx.fillStyle = animation.color;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.8;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderMultiHopShipAnimation(animation, totalProgress) {
        const segmentProgress = totalProgress * animation.segments.length;
        const currentSegmentIndex = Math.floor(segmentProgress);
        const segmentLocalProgress = segmentProgress - currentSegmentIndex;
        
        if (currentSegmentIndex >= animation.segments.length) return;
        
        const segment = animation.segments[currentSegmentIndex];
        const x = segment.from.x + (segment.to.x - segment.from.x) * segmentLocalProgress;
        const y = segment.from.y + (segment.to.y - segment.from.y) * segmentLocalProgress;
        
        this.ctx.save();
        this.ctx.fillStyle = animation.color;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.8;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderSelection(selectedTerritory) {
        if (!selectedTerritory) return;
        
        this.ctx.save();
        this.ctx.strokeStyle = '#00ffff';
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([5, 5]);
        this.ctx.lineDashOffset = Date.now() * 0.01;
        
        this.ctx.beginPath();
        this.ctx.arc(selectedTerritory.x, selectedTerritory.y, selectedTerritory.radius + 5, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    renderDragPreview(gameData) {
        // Render proportional drag preview
        if (gameData.isProportionalDrag && gameData.proportionalDragStart && gameData.dragEnd) {
            this.renderProportionalDragPreview(gameData);
        }
    }
    
    renderProportionalDragPreview(gameData) {
        const from = gameData.proportionalDragStart.territory;
        const to = gameData.dragEnd;
        const percentage = gameData.fleetPercentage;
        
        if (!from || !to) return;
        
        this.ctx.save();
        
        // Drag line
        const lineColor = to.isColonizable ? '#ffff00' : 
                         (to.ownerId === gameData.humanPlayer?.id ? '#00ff00' : '#ff0000');
        
        this.ctx.strokeStyle = lineColor;
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([10, 5]);
        
        this.ctx.beginPath();
        this.ctx.moveTo(from.x, from.y);
        this.ctx.lineTo(to.x, to.y);
        this.ctx.stroke();
        
        // Percentage indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(midX - 30, midY - 10, 60, 20);
        
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(`${Math.round(percentage * 100)}%`, midX, midY);
        
        this.ctx.restore();
    }
    
    renderUI(gameData) {
        // UI rendering is handled by the GameUI class
        // This method exists for extensibility
    }
    
    // Helper methods
    findPlayerById(playerId, players = []) {
        return players.find(p => p.id === playerId);
    }
    
    // Object pooling for ship animations
    createShipAnimation(from, to, color, duration, segments = null) {
        let animation;
        
        if (this.shipAnimationPool.length > 0) {
            animation = this.shipAnimationPool.pop();
        } else {
            animation = {};
        }
        
        animation.from = from;
        animation.to = to;
        animation.color = color;
        animation.duration = duration;
        animation.startTime = Date.now();
        animation.endTime = animation.startTime + duration;
        animation.segments = segments;
        
        this.activeShipAnimations.push(animation);
        return animation;
    }
    
    // Performance monitoring
    getPerformanceStats() {
        return {
            visibleTerritories: this.visibleTerritories,
            activeShipAnimations: this.activeShipAnimations.length,
            pooledAnimations: this.shipAnimationPool.length
        };
    }
}

===============================================================================
CLIENT/SRC/GAME/STARTHRONE.JS - MAIN GAME ENGINE
===============================================================================

import { GameMap } from './GameMap.js';
import { Player } from './Player.js';
import { GameUI } from './GameUI.js';
import { Camera } from './Camera.js';
// import { Probe } from './Probe.js'; // Disabled probe system (legacy)
import { InputHandler } from './InputHandler.js';
import { Renderer } from './Renderer.js';
import { CombatSystem } from './CombatSystem.js';
import { SupplySystem } from './SupplySystem.js';
import { PathfindingService } from './PathfindingService.js';
import { GameUtils } from './utils.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants';
import { gameEvents, GAME_EVENTS, EVENT_PRIORITY, EventHelpers } from './EventSystem.js';
import { PerformanceManager } from './PerformanceManager.js';
import { PerformanceOverlay } from './PerformanceOverlay.js';
import { DiscoverySystem } from './DiscoverySystem.js';
import { AnimationSystem } from './AnimationSystem.js';
import { UIManager } from './UIManager.js';
import { AIManager } from './AIManager.js';
import Controls from './Controls.js';

export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        this.gameInitialized = false; // Prevent early win condition checks
        
        // Persistent star lane discovery system
        this.discoveredLanes = new Set(); // Stores "id1-id2" strings for permanently visible lanes
        
        // Throne star validation timer
        this.throneStarValidationTimer = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        this.pathfindingService = null;
        this.performanceManager = null;
        this.discoverySystem = null;
        this.animationSystem = null;
        this.uiManager = null;
        this.controls = null;
        
        // Legacy properties for backward compatibility
        this.hoveredTerritory = null;
        
        // Performance
        this.lastFrameTime = 0;
        this.fps = 0;
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        
        // Performance optimizations
        this.visibleTerritories = new Set();
        this.lastVisibilityUpdate = 0;
        this.cullingBatchIndex = 0; // For incremental visibility processing
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        this.showPerformancePanel = false; // Toggle with P key
        
        // Ship movement animations
        this.shipAnimations = [];
        this.shipAnimationPool = []; // Reuse objects to reduce garbage collection
        
        // Pre-populate animation pool with multi-hop support
        for (let i = 0; i < 20; i++) {
            this.shipAnimationPool.push({
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            });
        }
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Default minimap to off
        
        // Probe system
        // this.probes = []; // Probe system disabled (legacy)
        // this.nextProbeId = 0; // Probe ID tracking disabled
        
        // Discovery announcements
        this.floatingDiscoveryTexts = [];
        this.discoveryLog = []; // Recent discovery announcements for panel display
        
        // Discovery system - Map of playerId -> discovery object
        this.playerDiscoveries = new Map();
        
        // Legacy drag variables (kept for compatibility)
        this.dragStart = null;
        this.dragEnd = null;
        this.isDraggingForSupplyRoute = false;
        
        // Background image system
        this.backgroundImage = null;
        this.backgroundLoaded = false;
        this.backgroundScale = 1.0;
        
        // Parallax starfield system
        this.starfield = {
            farStars: [],      // Slowest moving, smallest stars
            midStars: [],      // Medium speed, medium stars  
            nearStars: [],     // Fastest moving, larger stars
            initialized: false
        };
        
        // Static background optimization
        this.staticBg = document.createElement('canvas');
        this.staticBgCtx = this.staticBg.getContext('2d');
        
        // Discovery system for planet colonization - per player tracking
        this.playerDiscoveries = new Map(); // Map of playerId -> discoveries
        
        // Initialize event system for decoupled component communication
        this.eventProcessingEnabled = true;
        
        // Global discovery log for all players
        this.discoveryLog = [];
        
        // Recent probe results for UI announcements
        // this.recentProbeResults = []; // Probe results tracking disabled
        
        // Notification system
        this.notifications = [];
        
        // Bonus panel state
        this.showBonusPanel = true;
        
        // Message display system
        this.messageText = '';
        this.messageTimer = 0;
        
        // Performance optimization: Throttled logging system
        this.debugMode = false; // Set to true for development, false for production
        this.logThrottles = new Map(); // Track throttled log messages
        this.lastLogTimes = new Map(); // Track last log timestamp per message type
        
        // DOM optimization: Cache layout measurements
        this.cachedCanvasRect = null;
        this.canvasRectUpdateTime = 0;
        this.canvasRectCacheDuration = 1000; // Cache for 1 second
        
        // Input throttling for performance
        this.lastMouseMoveTime = 0;
        this.mouseMoveThrottleMs = 16; // ~60 FPS, one event per frame
        this.pendingMouseEvent = null;
        
        this.init();
        this.loadBackgroundImage();
    }
    
    /**
     * Performance-optimized logging with throttling
     * @param {string} message - Log message
     * @param {string} type - Log type (info, warn, error)
     * @param {number} throttleMs - Minimum time between identical messages
     */
    log(message, type = 'info', throttleMs = 1000) {
        if (!this.debugMode && type === 'info') return; // Skip info logs in production
        
        const key = `${type}:${message}`;
        const now = Date.now();
        const lastTime = this.lastLogTimes.get(key) || 0;
        
        if (now - lastTime >= throttleMs) {
            this.lastLogTimes.set(key, now);
            if (type === 'error') {
                console.error(message);
            } else if (type === 'warn') {
                console.warn(message);
            } else {
                console.log(message);
            }
        }
    }
    
    /**
     * Get cached canvas bounding rectangle with automatic cache invalidation
     * Prevents expensive getBoundingClientRect() calls on every mouse event
     */
    getCachedCanvasRect() {
        const now = Date.now();
        
        // Return cached rect if still valid
        if (this.cachedCanvasRect && (now - this.canvasRectUpdateTime) < this.canvasRectCacheDuration) {
            return this.cachedCanvasRect;
        }
        
        // Update cache with fresh measurement
        if (this.canvas) {
            this.cachedCanvasRect = this.canvas.getBoundingClientRect();
            this.canvasRectUpdateTime = now;
        }
        
        return this.cachedCanvasRect;
    }
    
    /**
     * Invalidate canvas rect cache on window resize or scroll
     */
    invalidateCanvasRectCache() {
        this.cachedCanvasRect = null;
        this.canvasRectUpdateTime = 0;
    }
    
    /**
     * Throttled mouse event processing - limits to one event per frame
     * @param {MouseEvent} event - Raw mouse event
     * @param {Function} handler - Event handler function
     */
    handleThrottledMouseEvent(event, handler) {
        const now = Date.now();
        
        // Store the latest event for processing
        this.pendingMouseEvent = { event, handler, timestamp: now };
        
        // Only process if enough time has passed (throttle to ~60 FPS)
        if (now - this.lastMouseMoveTime >= this.mouseMoveThrottleMs) {
            this.processPendingMouseEvent();
        }
    }
    
    /**
     * Process the most recent pending mouse event
     */
    processPendingMouseEvent() {
        if (!this.pendingMouseEvent) return;
        
        const { event, handler } = this.pendingMouseEvent;
        this.lastMouseMoveTime = Date.now();
        
        // Get cached canvas rect to avoid expensive DOM measurement
        const rect = this.getCachedCanvasRect();
        if (rect) {
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handler(x, y, event);
        }
        
        this.pendingMouseEvent = null;
    }
    
    loadBackgroundImage() {
        // Load the background galaxy image
        this.backgroundImage = new Image();
        this.backgroundImage.onload = () => {
            this.backgroundLoaded = true;
            console.log('Background galaxy image loaded');
        };
        this.backgroundImage.onerror = () => {
            console.log('Background image failed to load, using default starfield');
            this.backgroundLoaded = false;
        };
        // Set the image path
        this.backgroundImage.src = '/galaxy-background.jpg';
    }
    
    renderBackgroundImage() {
        if (!this.backgroundImage || !this.backgroundLoaded) return;
        
        this.ctx.save();
        
        // Calculate parallax offset (background moves slower than camera)
        const parallaxFactor = 0.2; // Background moves at 20% of camera speed
        const offsetX = -this.camera.x * parallaxFactor;
        const offsetY = -this.camera.y * parallaxFactor;
        
        // Calculate scale to ensure image covers the entire viewport
        const imageAspect = this.backgroundImage.width / this.backgroundImage.height;
        const canvasAspect = this.canvas.width / this.canvas.height;
        
        let drawWidth, drawHeight;
        if (imageAspect > canvasAspect) {
            // Image is wider - fit to height
            drawHeight = this.canvas.height * 1.5; // Scale up for parallax coverage
            drawWidth = drawHeight * imageAspect;
        } else {
            // Image is taller - fit to width
            drawWidth = this.canvas.width * 1.5; // Scale up for parallax coverage
            drawHeight = drawWidth / imageAspect;
        }
        
        // Center the image with parallax offset
        const drawX = (this.canvas.width - drawWidth) / 2 + offsetX;
        const drawY = (this.canvas.height - drawHeight) / 2 + offsetY;
        
        // Draw the background image with very low opacity
        this.ctx.globalAlpha = 0.15; // Even more transparent for very subtle background effect
        this.ctx.drawImage(this.backgroundImage, drawX, drawY, drawWidth, drawHeight);
        
        // Add dark overlay to further dim the background
        this.ctx.globalAlpha = 0.6;
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.globalAlpha = 1.0;
        
        this.ctx.restore();
    }
    
    /**
     * Setup event listeners for event-driven architecture
     */
    setupEventListeners() {
        // Listen for territory capture events to update UI
        gameEvents.on(GAME_EVENTS.TERRITORY_CAPTURED, (event) => {
            this.handleTerritoryCapture(event.data);
        }, EVENT_PRIORITY.HIGH);
        
        // Listen for throne capture events for game ending
        gameEvents.on(GAME_EVENTS.THRONE_CAPTURED, (event) => {
            this.handleThroneCapture(event.data);
        }, EVENT_PRIORITY.CRITICAL);
        
        // Listen for discovery events to update UI
        gameEvents.on(GAME_EVENTS.DISCOVERY_MADE, (event) => {
            this.handleDiscoveryEvent(event.data);
        }, EVENT_PRIORITY.MEDIUM);
        
        // Listen for combat events for animations
        gameEvents.on(GAME_EVENTS.COMBAT_STARTED, (event) => {
            this.handleCombatStart(event.data);
        }, EVENT_PRIORITY.HIGH);
        
        // Process event queue each frame
        this.eventProcessingEnabled = true;
    }
    
    /**
     * Handle territory capture events
     */
    handleTerritoryCapture(data) {
        if (data.player && data.player.id === this.humanPlayer?.id) {
            this.addNotification(`Territory ${data.territory.id} captured!`, '#44ff44');
        }
    }
    
    /**
     * Handle throne capture events
     */
    handleThroneCapture(data) {
        if (data.gameEnded) {
            if (data.attacker.id === this.humanPlayer?.id) {
                this.addNotification(`Victory! You captured ${data.defender.name}'s throne!`, '#ffff44', 8000);
            } else if (data.defender.id === this.humanPlayer?.id) {
                this.addNotification(`Defeat! Your throne was captured by ${data.attacker.name}!`, '#ff4444', 8000);
                this.endGame();
            }
        }
    }
    
    /**
     * Handle discovery events
     */
    handleDiscoveryEvent(data) {
        if (data.player.id === this.humanPlayer?.id) {
            this.addNotification(`Discovery: ${data.discovery.name}`, '#44ffff', 5000);
        }
    }
    
    /**
     * Handle combat start events
     */
    handleCombatStart(data) {
        // Could trigger special effects, sounds, etc.
        if (data.attacker.id === this.humanPlayer?.id || data.defender?.id === this.humanPlayer?.id) {
            // Human player is involved in combat - maybe add special visual effects
        }
    }

    // Add notification to display queue
    addNotification(text, color = '#44ff44', duration = 4000) {
        this.notifications.push({
            text: text,
            color: color,
            createdAt: Date.now(),
            duration: duration,
            opacity: 1.0
        });
    }
    
    // Update and clean up notifications
    updateNotifications() {
        const now = Date.now();
        this.notifications = this.notifications.filter(notification => {
            const age = now - notification.createdAt;
            if (age > notification.duration) {
                return false; // Remove expired notifications
            }
            
            // Fade out in the last 500ms
            if (age > notification.duration - 500) {
                notification.opacity = (notification.duration - age) / 500;
            }
            
            return true;
        });
    }
    
    // Message display system for FSM feedback
    showMessage(text, duration = 3000) {
        this.messageText = text;
        this.messageTimer = duration;
        console.log(`Message: ${text}`);
    }
    
    hideMessage() {
        this.messageText = '';
        this.messageTimer = 0;
    }
    
    showError(text) {
        this.showMessage(`‚ùå ${text}`, 2000);
    }
    
    updateMessage(deltaTime) {
        if (this.messageTimer > 0) {
            this.messageTimer -= deltaTime;
            if (this.messageTimer <= 0) {
                this.hideMessage();
            }
        }
    }
    
    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.gameMap = new GameMap(2000, 1500, this.config); // Large map with advanced configuration
        this.gameMap.game = this; // Reference for AI animations
        
        // Use logical dimensions for camera, not physical canvas dimensions
        const logicalWidth = this.canvas.style.width ? parseInt(this.canvas.style.width) : window.innerWidth;
        const logicalHeight = this.canvas.style.height ? parseInt(this.canvas.style.height) : window.innerHeight;
        this.camera = new Camera(logicalWidth, logicalHeight);
        
        // Update camera map boundaries to match actual expanded map size
        this.camera.mapWidth = this.gameMap.width;
        this.camera.mapHeight = this.gameMap.height;
        
        // Center camera on map and set appropriate zoom
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2); // Center of expanded map
        this.camera.targetZoom = 0.25; // Zoom out further to see more territories
        this.camera.zoom = 0.25;
        
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Initialize modular systems
        this.inputHandler = new InputHandler(this);
        this.renderer = new Renderer(this.canvas, this.camera, this);
        this.combatSystem = new CombatSystem(this);
        this.supplySystem = new SupplySystem(this);
        this.pathfindingService = new PathfindingService(this);
        this.performanceManager = new PerformanceManager(this);
        this.performanceOverlay = new PerformanceOverlay(this.canvas, this.performanceManager);
        this.discoverySystem = new DiscoverySystem(this);
        this.animationSystem = new AnimationSystem(this);
        this.uiManager = new UIManager(this);
        this.aiManager = new AIManager(this);
        this.controls = new Controls(this);
        
        // TODO: Remove global reference (use dependency injection instead)
        // window.game = this;  // (global game reference deprecated)
        window.game = this; // Temporary global access - to be replaced with dependency injection
        
        // Auto-detect optimal performance profile
        this.performanceManager.detectOptimalProfile();
        
        this.gameStartTime = Date.now(); // Track when game actually starts
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            {
                id: 'hostile_aliens',
                name: 'Hostile Aliens',
                description: 'Hostile alien life destroys your probe!',
                probability: 0.15,
                type: 'negative',
                effect: 'probe_lost'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.12,
                type: 'positive',
                effect: 'extra_fleet',
                bonus: 50
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons Cache',
                description: 'Ancient weapon technology discovered!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'attack_bonus',
                bonus: 10 // +10% attack
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'speed_bonus',
                bonus: 20 // +20% speed
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology enhances your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'defense_bonus',
                bonus: 10 // +10% defense
            },
            {
                id: 'precursor_factory',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facility still operational!',
                probability: 0.06,
                type: 'planet_bonus',
                effect: 'factory_planet',
                bonus: 100 // +100% generation (200% total)
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating technology spreads across your empire!',
                probability: 0.05,
                type: 'empire_bonus',
                effect: 'generation_bonus',
                bonus: 10 // +10% empire-wide generation
            },
            {
                id: 'mineral_deposits',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.10,
                type: 'planet_bonus',
                effect: 'mineral_planet',
                bonus: 50 // +50% generation
            },
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                description: 'Mysterious structures provide no immediate benefit.',
                probability: 0.08,
                type: 'neutral',
                effect: 'cosmetic'
            },
            {
                id: 'void_storm',
                name: 'Void Storm Remnants',
                description: 'Dangerous energy storms reduce planet effectiveness.',
                probability: 0.06,
                type: 'negative',
                effect: 'reduced_generation',
                bonus: -25 // -25% generation
            },
            {
                id: 'no_discovery',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.14,
                type: 'neutral',
                effect: 'none'
            }
        ];
    }
    
    // Initialize parallax starfield layers
    initializeStarfield() {
        if (this.starfield.initialized) return;
        
        // Expand starfield area beyond visible map for smooth parallax
        const starfieldWidth = this.gameMap.width * 2;
        const starfieldHeight = this.gameMap.height * 2;
        const offsetX = -this.gameMap.width * 0.5;
        const offsetY = -this.gameMap.height * 0.5;
        
        // Far layer: Many small, dim stars that barely move
        for (let i = 0; i < 300; i++) {
            this.starfield.farStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1 + 0.5,
                brightness: Math.random() * 0.3 + 0.1,
                twinkle: Math.random() * 0.2 + 0.8
            });
        }
        
        // Mid layer: Medium stars with moderate movement
        for (let i = 0; i < 150; i++) {
            this.starfield.midStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1.5 + 1,
                brightness: Math.random() * 0.4 + 0.2,
                twinkle: Math.random() * 0.3 + 0.7
            });
        }
        
        // Near layer: Fewer large stars with most movement
        for (let i = 0; i < 80; i++) {
            this.starfield.nearStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 2 + 1.5,
                brightness: Math.random() * 0.5 + 0.3,
                twinkle: Math.random() * 0.4 + 0.6
            });
        }
        
        this.starfield.initialized = true;
        console.log('Parallax starfield initialized with 530 stars across 3 layers');
    }
    
    // Pre-render static background elements once for performance optimization
    preRenderStaticBackground() {
        // Set static canvas to game map size
        this.staticBg.width = this.gameMap.width;
        this.staticBg.height = this.gameMap.height;
        
        // Clear the static background
        this.staticBgCtx.fillStyle = '#0a0a1a';
        this.staticBgCtx.fillRect(0, 0, this.staticBg.width, this.staticBg.height);
        
        // Render starfield to static background (once only)
        this.renderStarfieldStatic(this.staticBgCtx);
        
        // Render nebulas to static background (once only)
        this.renderNebulasStatic(this.staticBgCtx);
        
        console.log('Static background pre-rendered for performance optimization');
    }
    
    // Render starfield without parallax for static background
    renderStarfieldStatic(ctx) {
        if (!this.starfield.initialized) return;
        
        ctx.save();
        
        // Render all star layers at base positions (no parallax)
        const renderLayer = (stars, baseOpacity) => {
            stars.forEach(star => {
                // Simple twinkling effect for static background
                const twinkle = 0.8; // Static brightness
                const opacity = star.brightness * baseOpacity * twinkle;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        };
        
        // Render all layers
        renderLayer(this.starfield.farStars, 0.7);
        renderLayer(this.starfield.midStars, 0.8);
        renderLayer(this.starfield.nearStars, 1.0);
        
        ctx.restore();
    }
    
    // Render nebulas for static background
    renderNebulasStatic(ctx) {
        if (!this.gameMap.nebulas) return;
        
        this.gameMap.nebulas.forEach(nebula => {
            const gradient = ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Log discovery for UI display (called for both successful and failed probes)
    logDiscoveryForUI(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log for UI display
        this.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`üîç Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Add floating discovery text above the planet
        this.addFloatingDiscoveryText(territory, discovery, playerId);
        
        // Probe result tracking disabled (probe system inactive)
        // this.recentProbeResults.push({ ... }); // No longer tracking probe results
    }
    
    // Process discovery when a planet is successfully colonized - MOVED TO UTILS.JS
    
    addFloatingDiscoveryText(territory, discovery, playerId) {
        // Create floating text object
        const floatingText = {
            x: territory.x,
            y: territory.y - 40, // Start above the planet
            text: discovery.name,
            icon: this.getDiscoveryIcon(discovery.effect),
            color: this.getDiscoveryColor(discovery.effect),
            startTime: Date.now(),
            duration: 4000, // 4 seconds
            fadeOutDuration: 1000, // Last 1 second fades out
            playerId: playerId
        };
        
        this.floatingDiscoveryTexts.push(floatingText);
        
        // Limit to 10 floating texts to prevent clutter
        if (this.floatingDiscoveryTexts.length > 10) {
            this.floatingDiscoveryTexts.shift();
        }
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': 'üíÄ',
            'extra_fleet': 'üëΩ',
            'precursor_weapons': '‚öîÔ∏è',
            'precursor_drive': 'üöÄ',
            'precursor_shield': 'üõ°Ô∏è',
            'precursor_nanotech': 'üî¨',
            'factory_complex': 'üè≠',
            'mineral_deposits': 'üíé',
            'void_storm': '‚ö°',
            'ancient_ruins': 'üèõÔ∏è'
        };
        return icons[effect] || 'üîç';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    updateFloatingDiscoveryTexts(deltaTime) {
        const now = Date.now();
        
        // Update and remove expired floating texts
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            
            if (age > text.duration) {
                return false; // Remove expired text
            }
            
            // Animate the text (float upward)
            text.y -= 20 * (deltaTime / 1000); // Move up 20 pixels per second
            
            return true;
        });
    }
    
    // REMOVED: Second duplicate processDiscovery function - logic moved to GameUtils.js
    
    // Create ship movement animation
    createShipAnimation(fromTerritory, toTerritory, isAttack = false, fleetSize = 0) {
        // Use object pooling to reduce garbage collection
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false,
                fleetSize: 0
            };
        }
        
        const player = this.players[fromTerritory.ownerId];
        const playerColor = player ? player.color : '#ffffff';
        
        // Reset animation properties
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 1000 / this.config.gameSpeed;
        animation.startTime = Date.now();
        animation.isAttack = isAttack;
        animation.playerColor = playerColor;
        animation.id = Math.random();
        animation.path = null;
        animation.currentSegment = 0;
        animation.isMultiHop = false;
        animation.fleetSize = fleetSize;
        
        this.shipAnimations.push(animation);
    }

    // Create multi-hop ship animation following supply route path
    createSupplyRouteAnimation(path, playerColor) {
        if (!path || path.length < 2) return;
        
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            };
        }
        
        // Set up multi-hop animation
        animation.path = path;
        animation.currentSegment = 0;
        animation.isMultiHop = true;
        animation.playerColor = playerColor;
        animation.isAttack = false;
        animation.id = Math.random();
        
        // Start with first segment
        this.initializeAnimationSegment(animation);
        
        this.shipAnimations.push(animation);
    }

    // Initialize animation segment for multi-hop
    initializeAnimationSegment(animation) {
        if (!animation.path || animation.currentSegment >= animation.path.length - 1) {
            return false;
        }
        
        const fromTerritory = animation.path[animation.currentSegment];
        const toTerritory = animation.path[animation.currentSegment + 1];
        
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 800 / this.config.gameSpeed; // Faster per-segment animation
        animation.startTime = Date.now();
        
        return true;
    }
    
    // Update ship animations
    updateShipAnimations(deltaTime) {
        const currentTime = Date.now();
        
        // Optimize with object pooling and manual iteration
        for (let i = this.shipAnimations.length - 1; i >= 0; i--) {
            const animation = this.shipAnimations[i];
            animation.progress = (currentTime - animation.startTime) / animation.duration;
            
            if (animation.progress >= 1) {
                if (animation.isMultiHop && animation.path) {
                    // Move to next segment in multi-hop animation
                    animation.currentSegment++;
                    
                    if (this.initializeAnimationSegment(animation)) {
                        // Continue to next segment
                        continue;
                    }
                }
                
                // Return completed animation to pool for reuse
                this.shipAnimationPool.push(animation);
                this.shipAnimations.splice(i, 1);
            }
        }
    }
    
    // Update probes (disabled - probe system inactive)
    updateProbes(deltaTime) {
        // Probe update logic disabled (no active probes)
        // for (let i = this.probes.length - 1; i >= 0; i--) { ... }
    }
    
    // Colonize planet when probe arrives
    colonizePlanet(probe) {
        const planet = probe.toTerritory;
        const player = this.players.find(p => p.id === probe.playerId);
        
        if (!planet || !player) return;
        
        // Check if planet is already colonized by another player
        if (planet.ownerId !== null && planet.ownerId !== player.id) {
            console.log(`Probe from ${player.name} destroyed! Planet ${planet.id} already colonized by another player.`);
            return;
        }
        
        console.log(`Probe colonizing planet ${planet.id} for player ${player.name}`);
        
        // Set ownership - discovery might have already set army size
        planet.ownerId = player.id;
        if (planet.armySize === 0 || planet.armySize === planet.hiddenArmySize) {
            planet.armySize = 1; // Default if not set by discovery
        }
        
        // Mark as no longer colonizable
        planet.isColonizable = false;
        
        // Add to player's territories
        player.territories.push(planet.id);
        
        // Reveal hidden connections
        planet.revealConnections();
        
        // Update neighboring territories' connections
        Object.values(this.gameMap.territories).forEach(territory => {
            if (territory.hiddenNeighbors.includes(planet.id)) {
                territory.hiddenNeighbors = territory.hiddenNeighbors.filter(id => id !== planet.id);
                territory.neighbors.push(planet.id);
            }
        });
        
        // Update player stats
        player.updateStats();
        
        console.log(`Planet ${planet.id} colonized successfully! Discovery: ${discovery.name}`);
    }
    
    // Render ship animations
    renderShipAnimations() {
        this.shipAnimations.forEach(animation => {
            const progress = Math.min(1, animation.progress);
            const eased = this.easeInOutQuad(progress);
            
            const x = animation.fromX + (animation.toX - animation.fromX) * eased;
            const y = animation.fromY + (animation.toY - animation.fromY) * eased;
            
            // Draw ship using player's color
            this.ctx.save();
            this.ctx.fillStyle = animation.playerColor;
            this.ctx.shadowColor = animation.playerColor;
            this.ctx.shadowBlur = 8;
            
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Add trail effect
            const trailLength = 5;
            for (let i = 1; i <= trailLength; i++) {
                const trailProgress = Math.max(0, eased - (i * 0.1));
                const trailX = animation.fromX + (animation.toX - animation.fromX) * trailProgress;
                const trailY = animation.fromY + (animation.toY - animation.fromY) * trailProgress;
                
                this.ctx.globalAlpha = (trailLength - i) / trailLength * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(trailX, trailY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
        });
    }
    
    // Render probes
    renderProbes() {
        // Probe rendering disabled (no active probes)
        // this.probes.forEach(probe => { probe.render(this.ctx); });
    }
    
    renderFloatingDiscoveryTexts() {
        if (this.floatingDiscoveryTexts.length === 0) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        this.floatingDiscoveryTexts.forEach(text => {
            const now = Date.now();
            const age = now - text.startTime;
            const progress = age / text.duration;
            
            // Calculate opacity (fade out in the last 25% of duration)
            let opacity = 1;
            if (progress > 0.75) {
                opacity = 1 - ((progress - 0.75) / 0.25);
            }
            
            // Only render if text is within camera view
            const screenPos = this.camera.worldToScreen(text.x, text.y);
            if (screenPos.x >= -100 && screenPos.x <= this.canvas.width + 100 &&
                screenPos.y >= -100 && screenPos.y <= this.canvas.height + 100) {
                
                // Draw background
                this.ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.8})`;
                const textWidth = this.ctx.measureText(text.text).width;
                this.ctx.fillRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw border
                this.ctx.strokeStyle = text.color;
                this.ctx.globalAlpha = opacity;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw icon
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.icon, screenPos.x - textWidth/2 - 5, screenPos.y - 2);
                
                // Draw text
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.text, screenPos.x + 10, screenPos.y - 2);
            }
        });
        
        this.ctx.restore();
    }
    
    // Easing function for smooth animation
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    setupCanvas() {
        // Create canvas element
        const canvasElement = document.createElement('canvas');
        canvasElement.id = 'gameCanvas';
        
        // Get device pixel ratio for crisp rendering on high-DPI displays
        const dpr = window.devicePixelRatio || 1;
        const rect = { width: window.innerWidth, height: window.innerHeight };
        
        // Set canvas size with DPI scaling
        canvasElement.width = rect.width * dpr;
        canvasElement.height = rect.height * dpr;
        canvasElement.style.width = rect.width + 'px';
        canvasElement.style.height = rect.height + 'px';
        canvasElement.style.display = 'block';
        canvasElement.style.background = '#1a1a2e';
        canvasElement.style.position = 'fixed';
        canvasElement.style.top = '0';
        canvasElement.style.left = '0';
        canvasElement.style.zIndex = '1';
        
        console.log(`Creating canvas: ${rect.width}x${rect.height} (${canvasElement.width}x${canvasElement.height} with DPR ${dpr})`);
        
        // Append to root without destroying React content
        const root = document.getElementById('root');
        if (root) {
            // Check if canvas already exists
            const existingCanvas = document.getElementById('gameCanvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }
            root.appendChild(canvasElement);
            console.log('Canvas appended to root');
        } else {
            console.error('Root element not found!');
            return;
        }
        
        this.canvas = canvasElement;
        this.ctx = canvasElement.getContext('2d');
        
        if (!this.ctx) {
            console.error('Failed to get 2D context!');
            return;
        }
        
        // Scale context to match device pixel ratio for crisp rendering
        this.ctx.scale(dpr, dpr);
        
        // Store DPI ratio for resize handling
        this.devicePixelRatio = dpr;
        
        console.log('Canvas setup complete');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera) {
                this.camera.updateViewport(this.canvas.width, this.canvas.height);
            }
        });
    }
    
    setupEventListeners() {
        // Safety check to ensure canvas exists
        if (!this.canvas) {
            console.error('Canvas not available for event listeners');
            return;
        }
        
        // Mouse events now handled by InputHandler.js - removed to prevent conflicts
        // Wheel events handled by InputHandler
        
        // Touch events for mobile - with better event handling
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: false });
        
        // Window events for DOM optimization
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('scroll', this.invalidateCanvasRectCache.bind(this));
        
        // Initialize canvas rect cache
        this.getCachedCanvasRect();
        
        // Also add document-level listeners to catch events outside canvas
        document.addEventListener('touchmove', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Enhanced touch state tracking for better pinch-to-zoom
        this.touchStartTime = 0;
        this.touchStartDistance = null;
        this.lastPinchDistance = null;
        this.isMultiTouch = false;
        this.touchDebugInfo = '';
        this.showTouchDebug = true;
        this.leaderboardMinimized = false;
        this.lastZoomTime = 0;
        this.pinchCenter = null;
        this.initialZoom = 1.0;
        
        // Long press functionality
        this.longPressTimer = null;
        this.longPressThreshold = 800; // 800ms for long press
        this.longPressTarget = null;
        this.longPressStartPos = null;
        
        // Keyboard events now handled by InputHandler
        
        // Prevent context menu
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    /**
     * Handle window resize events with DOM cache invalidation
     */
    handleResize() {
        if (!this.canvas) return;
        
        // Get device pixel ratio for crisp rendering on high-DPI displays
        const dpr = this.devicePixelRatio || window.devicePixelRatio || 1;
        const rect = { width: window.innerWidth, height: window.innerHeight };
        
        // Set canvas size with DPI scaling
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        // Re-scale context after resize
        this.ctx.scale(dpr, dpr);
        
        if (this.camera) {
            // Camera uses logical pixels, not physical pixels
            this.camera.updateViewport(rect.width, rect.height);
        }
        
        // Invalidate canvas rect cache after resize
        this.invalidateCanvasRectCache();
        
        console.log(`Resized canvas: ${rect.width}x${rect.height} (${this.canvas.width}x${this.canvas.height} with DPR ${dpr})`);
    }
    
    /**
     * Throttled mouse move handler - called via the throttling system
     * @param {number} x - Canvas-relative X coordinate
     * @param {number} y - Canvas-relative Y coordinate
     * @param {MouseEvent} event - Original mouse event
     */
    handleMouseMoveThrottled(x, y, event) {
        // Update mouse position for other systems
        this.mousePos = { x, y };
        
        // Update hovered territory without expensive DOM operations
        const worldPos = this.camera.screenToWorld(x, y);
        this.updateHoveredTerritory(worldPos.x, worldPos.y);
        
        // Handle camera edge panning for desktop
        if (!this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(x, y, 16); // 16ms frame time approximation
        }
    }
    
    startGame() {
        console.log('Starting Star Throne game with config:', this.config);
        
        // Initialize background systems immediately
        this.animationSystem.initializeStarfield();
        this.animationSystem.preRenderStaticBackground();
        this.uiManager.loadBackgroundImage();
        this.showMessage('Generating galaxy map, please wait...', 15000);
        
        try {
            // Generate map using the sophisticated algorithm
            this.gameMap.generateTerritories(this.config.mapSize);
            this.gameMap.buildSpatialIndex();
            this.log('Spatial index built for optimized territory lookups', 'info');
            
            // Update camera bounds after map generation
            this.camera.mapWidth = this.gameMap.width;
            this.camera.mapHeight = this.gameMap.height;
            console.log(`üé• Camera bounds updated: ${this.camera.mapWidth} x ${this.camera.mapHeight} with ${this.camera.boundaryPadding}px padding`);

            // Create players: 1 human + configured AI count
            const requestedAI = this.config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT;
            const totalPlayers = 1 + requestedAI;
            console.log(`üîç PLAYER COUNT DEBUG: config.aiCount = ${this.config.aiCount}, requestedAI = ${requestedAI}, totalPlayers = ${totalPlayers}`);
            this.createPlayers(totalPlayers);
            
            // Update human player name from config
            if (this.humanPlayer) {
                this.humanPlayer.name = this.config.playerName;
            }
            
            // Distribute initial territories to give each player a throne star
            this.distributeStartingTerritories();

            // Center camera on the human player's starting system
            if (this.humanPlayer && this.humanPlayer.territories.length > 0) {
                const startId = this.humanPlayer.territories[0];
                const startTerritory = this.gameMap.territories[startId];
                this.camera.centerOn(startTerritory.x, startTerritory.y);
            }

            this.gameState = 'playing';
            
            // Re-initialize starfield with final map size
            if (this.animationSystem && this.animationSystem.starfield) {
                this.animationSystem.starfield.initialized = false;
                this.animationSystem.initializeStarfield();
                this.animationSystem.preRenderStaticBackground();
            }
            
            // Start home system flashing for player identification
            this.homeSystemFlashStart = Date.now();
            
            this.gameInitialized = true;
            console.log('üïê Running initial throne star validation...');
            this.validateThroneStars();
            console.log(`Game started with ${this.players.length} players (${this.config.playerName} + ${this.config.aiCount} AI) and ${Object.keys(this.gameMap.territories).length} territories`);
            
            // Hide loading message
            this.hideMessage();
        } catch (error) {
            console.error('Failed to generate galaxy map:', error);
            this.showMessage('Map generation failed. Please try again.', 5000);
        }
    }
    

    
    generateAIName(index) {
        const firstNames = [
            'Alex', 'Blake', 'Casey', 'Dana', 'Emma', 'Felix', 'Grace', 'Hunter', 'Iris', 'Jack',
            'Kai', 'Luna', 'Max', 'Nova', 'Owen', 'Piper', 'Quinn', 'Riley', 'Sage', 'Tyler',
            'Uma', 'Victor', 'Wade', 'Xara', 'Yuki', 'Zara', 'Ash', 'Beck', 'Cole', 'Drew',
            'Echo', 'Finn', 'Gale', 'Hope', 'Ivan', 'Jade', 'Kane', 'Lexi', 'Mika', 'Nora',
            'Orion', 'Phoenix', 'Raven', 'Storm', 'Tara', 'Vale', 'Wren', 'Zane', 'Aria', 'Brix',
            'Coda', 'Dex', 'Eden', 'Fox', 'Gray', 'Hawk', 'Juno', 'Kira', 'Lux', 'Moss',
            'Neo', 'Oslo', 'Pike', 'Rain', 'Sky', 'Tex', 'Vex', 'Wolf', 'Zed', 'Atlas',
            'Bear', 'Cruz', 'Dash', 'Enzo', 'Flint', 'Ghost', 'Haze', 'Jett', 'Knox', 'Link'
        ];
        
        const clanNames = [
            'StarForge', 'VoidHunters', 'NebulaRise', 'CosmicFury', 'SolarFlare', 'DarkMatter',
            'GalaxyCorp', 'NovaStrike', 'CelestialWar', 'SpaceRaiders', 'StellarWolves', 'OrbitClan',
            'AstroElite', 'CubClan', 'ZenithForce', 'PlasmaBorn', 'StarDust', 'VoidWalkers',
            'QuantumLeap', 'PhotonStorm', 'EtherGuard', 'CosmoKnights', 'StarVeins', 'NebulaCrest',
            'VortexClan', 'AstralFire', 'MeteoRiders', 'IonStorm', 'PulsarWave', 'GravityWell',
            'SolarWind', 'BlackHole', 'RedGiant', 'WhiteDwarf', 'SuperNova', 'Constellation',
            'MilkyWay', 'Andromeda', 'Centauri', 'Proxima', 'Kepler', 'Hubble', 'Armstrong',
            'Gagarin', 'Apollo', 'Artemis', 'Orion', 'Pegasus', 'Phoenix', 'Dragon', 'Falcon'
        ];
        
        const additionalNames = [
            'Admiral Voss', 'Captain Zara', 'Commander Rex', 'Colonel Stone', 'General Mars',
            'Chief Khan', 'Major Swift', 'Lieutenant Nova', 'Sergeant Blade', 'Marshal Iron',
            'Dr. Quantum', 'Professor Void', 'Scientist Echo', 'Engineer Prime', 'Architect Zero',
            'The Shadow', 'The Phoenix', 'The Storm', 'The Hunter', 'The Ghost',
            'Cyber Wolf', 'Steel Eagle', 'Iron Hawk', 'Gold Tiger', 'Silver Fox',
            'Red Baron', 'Blue Devil', 'Green Arrow', 'Black Knight', 'White Falcon',
            'Star Runner', 'Moon Walker', 'Sun Rider', 'Sky Dancer', 'Wind Chaser',
            'Fire Brand', 'Ice Queen', 'Thunder Lord', 'Lightning Strike', 'Storm Bringer'
        ];
        
        // Only 25% chance of clan name, 75% for varied names
        if (index % 4 === 0) {
            // Clan name format
            const firstName = firstNames[index % firstNames.length];
            const clanName = clanNames[Math.floor(index / firstNames.length) % clanNames.length];
            return `[${clanName}] ${firstName}`;
        } else {
            // Varied name format - mix of first names and additional names
            const namePool = [...firstNames, ...additionalNames];
            return namePool[index % namePool.length];
        }
    }

    createPlayers(numPlayers) {
        console.log(`üîç CREATE PLAYERS DEBUG: Creating ${numPlayers} total players (1 human + ${numPlayers-1} AI)`);
        
        // Clear any existing players to prevent duplicates
        this.players = [];
        this.humanPlayer = null;
        
        // Expanded unique color palette - no duplicates
        const baseColors = [
            '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', 
            '#ff8844', '#88ff44', '#4488ff', '#ff4488', '#88ff88', '#8844ff',
            '#ffaa44', '#aaff44', '#44aaff', '#ff44aa', '#aaff88', '#aa44ff',
            '#ff6644', '#66ff44', '#4466ff', '#ff4466', '#66ff88', '#6644ff',
            '#ff9944', '#99ff44', '#4499ff', '#ff4499', '#99ff88', '#9944ff',
            '#ffcc44', '#ccff44', '#44ccff', '#ff44cc', '#ccff88', '#cc44ff',
            '#ff7744', '#77ff44', '#4477ff', '#ff4477', '#77ff88', '#7744ff',
            '#ffdd44', '#ddff44', '#44ddff', '#ff44dd', '#ddff88', '#dd44ff'
        ];
        
        // Create exactly one human player with distinctive bright cyan color
        this.humanPlayer = new Player(0, 'You', '#00ffff', 'human');
        this.players.push(this.humanPlayer);
        console.log(`üîç HUMAN PLAYER CREATED: ID=${this.humanPlayer.id}, type=${this.humanPlayer.type}, total players now: ${this.players.length}`);
        this.initializePlayerDiscoveries(this.humanPlayer.id);
        
        // Create AI players with unique colors and human-like names
        const usedColors = new Set(['#00ffff']); // Reserve human color
        
        for (let i = 1; i < numPlayers && i < this.maxPlayers; i++) {
            let playerColor;
            let attempts = 0;
            
            // Find a unique color
            do {
                const colorIndex = (i - 1) % baseColors.length;
                playerColor = baseColors[colorIndex];
                
                // If we've used this color, generate a slight variation
                if (usedColors.has(playerColor)) {
                    const variation = Math.floor(attempts / baseColors.length) * 0.1 + 0.1;
                    playerColor = this.adjustColorBrightness(playerColor, variation);
                }
                attempts++;
            } while (usedColors.has(playerColor) && attempts < 100);
            
            usedColors.add(playerColor);
            
            // Generate human-like name with clan designation
            const aiName = AIManager.generateAIName(i - 1);
            const aiPlayer = new Player(i, aiName, playerColor, 'ai');
            this.players.push(aiPlayer);
            this.initializePlayerDiscoveries(aiPlayer.id);
        }
        
        this.currentPlayers = this.players.length;
        console.log(`üîç CREATED PLAYERS: Total ${this.players.length} players`);
        console.log(`üîç PLAYER BREAKDOWN: Human: ${this.players.filter(p => p.type === 'human').length}, AI: ${this.players.filter(p => p.type === 'ai').length}`);
    }
    
    initializePlayerDiscoveries(playerId) {
        this.playerDiscoveries.set(playerId, {
            // Empire-wide bonuses (levels stack)
            precursorWeapons: 0,    // +10% attack per level
            precursorDrive: 0,      // +20% probe/ship speed per level
            precursorShield: 0,     // +10% defense per level
            precursorNanotech: 0,   // +10% empire-wide generation per level
            
            // Planet-specific bonuses
            factoryPlanets: new Set(), // Planets with 200% generation
            friendlyAliens: 0,      // Count of friendly alien encounters
            richMinerals: 0,        // Count of rich mineral discoveries
            voidStorms: 0,          // Count of void storm discoveries
            ancientRuins: 0,        // Count of ancient ruin discoveries
            hostileAliens: 0        // Count of hostile alien encounters
        });
    }
    
    adjustColorBrightness(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent * 100);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    distributeStartingTerritories() {
        // Since all territories are now colonizable, manually colonize starting territories
        const allTerritories = Object.values(this.gameMap.territories);
        const usedTerritories = [];
        const minDistance = 200; // Minimum distance between starting territories
        
        console.log(`Available territories for distribution: ${allTerritories.length} (all have neutral garrisons)`);
        
        // Give each player exactly one starting territory with spacing
        for (let i = 0; i < this.players.length; i++) {
            const player = this.players[i];
            let bestTerritory = null;
            let bestMinDistance = 0;
            
            // Find territory with maximum distance from all previously assigned territories
            for (const territory of allTerritories) {
                if (usedTerritories.includes(territory.id)) continue;
                
                let minDistanceToUsed = Infinity;
                for (const usedId of usedTerritories) {
                    const usedTerritory = this.gameMap.territories[usedId];
                    const distance = Math.sqrt(
                        (territory.x - usedTerritory.x) ** 2 + 
                        (territory.y - usedTerritory.y) ** 2
                    );
                    minDistanceToUsed = Math.min(minDistanceToUsed, distance);
                }
                
                // If first player or this territory is far enough from others
                if (usedTerritories.length === 0 || minDistanceToUsed > bestMinDistance) {
                    bestTerritory = territory;
                    bestMinDistance = minDistanceToUsed;
                }
            }
            
            if (bestTerritory) {
                // Colonize this territory for the player (defeating the neutral garrison)
                bestTerritory.ownerId = player.id;
                bestTerritory.armySize = GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE;
                bestTerritory.isThronestar = true; // Mark as throne star
                
                console.log(`üè† Starting territory ${bestTerritory.id} for ${player.name}: ${GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE} armies`);
                
                // Debug: Track army changes for human player
                if (player.id === 0) { // Human player ID
                    console.log(`üë§ HUMAN PLAYER starting territory ${bestTerritory.id} initialized with ${bestTerritory.armySize} armies`);
                }
                
                player.territories.push(bestTerritory.id);
                player.totalArmies += bestTerritory.armySize;
                player.throneStarId = bestTerritory.id; // Assign throne star ID
                
                usedTerritories.push(bestTerritory.id);
                
                console.log(`üëë Player ${player.name} assigned throne star: Territory ${bestTerritory.id} (distance from others: ${bestMinDistance.toFixed(1)})`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    gameLoop(currentTime = 0) {
        try {
            const frameStart = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            // Update FPS counter
            this.updateFPS(currentTime);
            
            if (this.gameState === 'playing') {
                this.update(deltaTime);
            }
            
            this.render();
            
            // Track overall frame performance
            this.performanceStats.frameTime = performance.now() - frameStart;
        } catch (error) {
            console.error('Game loop error:', error);
            console.error('Error message:', error.message);
            console.error('Error stack:', error.stack);
            console.error('Game state:', this.gameState);
            // Continue running to prevent complete game halt
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    updateFPS(currentTime) {
        this.frameCount++;
        if (currentTime - this.lastFpsUpdate >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
            this.frameCount = 0;
            this.lastFpsUpdate = currentTime;
        }
    }
    
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update game timer
        this.gameTimer -= deltaTime;
        
        if (this.gameTimer <= 0) {
            this.endGame();
            return;
        }
        
        // Always update human player every frame for responsiveness
        const humanPlayer = this.players.find(p => p.type === 'human');
        if (humanPlayer && !humanPlayer.isEliminated) {
            try {
                humanPlayer.update(deltaTime, this.gameMap, this.config.gameSpeed, this);
            } catch (error) {
                console.error(`Error updating human player:`, error);
            }
        }
        
        // Delegate AI updates to AIManager for performance and organization
        if (this.aiManager) {
            this.aiManager.updateAI(deltaTime);
        }
        
        // Process any pending throttled mouse events
        this.processPendingMouseEvent();
        
        // Update ship animations and probes with normal delta time (speed applied internally)
        try {
            this.updateShipAnimations(deltaTime);
            this.updateProbes(deltaTime);
            this.updateFloatingDiscoveryTexts(deltaTime);
        } catch (error) {
            console.error('Error updating animations:', error);
        }
        
        // Update combat system for delayed battles
        if (this.combatSystem) {
            try {
                this.combatSystem.update(deltaTime);
            } catch (error) {
                console.error('Combat system error:', error);
                console.error('Combat system error message:', error.message);
                console.error('Combat system error stack:', error.stack);
            }
        }
        
        // Update modular UI systems
        if (this.uiManager) {
            this.uiManager.update(deltaTime);
        }
        if (this.discoverySystem) {
            this.discoverySystem.updateFloatingDiscoveries();
            this.discoverySystem.updateTopDiscoveryAnnouncements();
        }
        if (this.animationSystem) {
            this.animationSystem.update(deltaTime);
        }
        if (this.controls) {
            this.controls.update(deltaTime);
        }
        
        // Process event queue for event-driven architecture
        if (this.eventProcessingEnabled) {
            gameEvents.processQueue(5); // Process up to 5 events per frame
        }
        
        // Update performance management and track frame metrics
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.updateTime = performance.now() - updateStart;
            this.performanceManager.update(deltaTime);
            
            // Trigger memory cleanup if memory usage is high
            if (this.performanceManager.getMemoryUsageMB() > 250) {
                this.performanceManager.triggerMemoryCleanup();
            }
        }
        
        // Throttled heavy operations for better performance - use SupplySystem module
        if (this.frameCount % 45 === 0) { // Every 45 frames (~0.75 seconds)
            this.supplySystem.validateSupplyRoutes();
        }
        // (Removed redundant 90-frame check; supply logic now in Territory.generateArmies())
        
        // Validate throne stars every 5 seconds to fix double throne bugs
        this.throneStarValidationTimer += deltaTime;
        if (this.throneStarValidationTimer >= 5000) {
            console.log('üïê Running throne star validation...');
            this.validateThroneStars();
            this.throneStarValidationTimer = 0;
        }
        
        // MANUAL DEBUG: Run validation every 60 frames for debugging
        if (this.frameCount % 60 === 0) {
            console.log(`üîç DEBUG: AI players: ${this.players.filter(p => p.type === 'ai').length}, Human players: ${this.players.filter(p => p.type === 'human').length}, Total: ${this.players.length}`);
            this.validateThroneStars();
        }
        
        // Check for player elimination (throttled)
        if (this.frameCount % 20 === 0) {
            this.checkPlayerElimination();
        }
        
        // Check win conditions (throttled) - only after game is properly initialized
        if (this.gameInitialized && this.frameCount % 30 === 0) {
            this.checkWinConditions();
        }
        
        // Update camera with edge panning
        this.camera.update(deltaTime);
        
        // Edge panning when mouse is near screen edges (desktop only)
        if (this.mousePos && !this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(this.mousePos.x, this.mousePos.y, deltaTime);
        }
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    checkPlayerElimination() {
        let playersEliminated = false;
        
        this.players.forEach(player => {
            if (!player.isEliminated && player.territories.length === 0) {
                player.isEliminated = true;
                playersEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player === this.humanPlayer) {
                    console.log('You have been eliminated! Entering spectator mode.');
                    // TODO: Show elimination message and spectator UI
                }
            }
        });
        
        // Invalidate AI player cache if any players were eliminated
        if (playersEliminated && this.aiManager) {
            this.aiManager.invalidatePlayerCache();
        }
    }
    
    checkWinConditions() {
        const alivePlayers = this.players.filter(p => !p.isEliminated);
        
        if (alivePlayers.length === 1) {
            this.endGame(alivePlayers[0]);
        } else if (alivePlayers.length === 0) {
            this.endGame(); // Draw
        }
    }
    
    endGame(winner = null) {
        this.gameState = 'ended';
        
        if (winner) {
            console.log(`Game Over! Winner: ${winner.name}`);
            this.showMessage(`Victory! ${winner.name} has conquered the galaxy!`, 10000);
        } else {
            console.log('Game Over! It\'s a draw.');
            this.showMessage('Game Over! Your empire has fallen.', 10000);
        }
        
        // Stop game loop
        if (this.gameLoopRunning) {
            this.gameLoopRunning = false;
        }
        
        // Show game over message for human player defeat
        if (this.humanPlayer && this.humanPlayer.isEliminated) {
            this.showMessage(`Your throne star has been captured! Your empire has fallen to ${winner?.name || 'your enemies'}.`, 15000);
        }
    }
    
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render parallax starfield behind everything via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render game world with Level of Detail (LOD) optimizations
        const lodLevel = this.getLODLevel();
        
        this.renderNebulas();
        this.renderTerritories();
        
        // Render connections based on LOD level
        if (lodLevel >= 2) {
            this.renderConnections();
        }
        
        // Render supply routes for operational and tactical view
        if (lodLevel >= 2) {
            this.renderSupplyRoutes();
        }
        
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        
        // Ship animations and probes for tactical view
        if (lodLevel >= 2) {
            // Use AnimationSystem for ship animations
            if (this.animationSystem) {
                this.animationSystem.renderShipAnimations(this.ctx, this.camera);
            }
            // this.renderProbes(); // Probe rendering disabled
        }
        
        // Use DiscoverySystem for floating discovery texts
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    /**
     * Get Level of Detail based on camera zoom level
     * Level 1: Strategic view (very zoomed out) - minimal detail
     * Level 2: Operational view (medium zoom) - moderate detail  
     * Level 3: Tactical view (zoomed in) - full detail
     */
    getLODLevel() {
        const zoom = this.camera.zoom;
        if (zoom <= 0.15) return 1; // Strategic view
        if (zoom <= 0.8) return 2;  // Operational view
        return 3; // Tactical view
    }
    
    updateVisibleTerritories() {
        // Enhanced viewport culling with incremental processing for smooth performance
        const now = Date.now();
        const updateInterval = GAME_CONSTANTS.VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS;
        
        // Adaptive interval based on performance - increase on slower devices
        const adaptiveInterval = this.fps < 30 ? updateInterval * 1.5 : updateInterval;
        
        if (now - this.lastVisibilityUpdate < adaptiveInterval) return;
        this.lastVisibilityUpdate = now;
        
        const bounds = this.camera.getViewBounds();
        const margin = GAME_CONSTANTS.TERRITORY_VISIBILITY_PADDING;
        
        // Initialize visibility tracking as Set for O(1) lookups
        if (!this.visibleTerritories || !this.visibleTerritories.has) {
            this.visibleTerritories = new Set();
        }
        
        this.visibleTerritories.clear();
        const territories = Object.values(this.gameMap.territories);
        
        // Incremental processing: split territory checks across multiple frames on large maps
        const batchSize = territories.length > 200 ? Math.ceil(territories.length / 3) : territories.length;
        const startIndex = (this.cullingBatchIndex || 0) % territories.length;
        const endIndex = Math.min(startIndex + batchSize, territories.length);
        
        // Process current batch
        for (let i = startIndex; i < endIndex; i++) {
            const territory = territories[i];
            if (territory.x + territory.radius >= bounds.left - margin &&
                territory.x - territory.radius <= bounds.right + margin &&
                territory.y + territory.radius >= bounds.top - margin &&
                territory.y - territory.radius <= bounds.bottom + margin) {
                this.visibleTerritories.add(territory.id);
            }
        }
        
        // Update batch index for next frame (if processing incrementally)
        if (batchSize < territories.length) {
            this.cullingBatchIndex = endIndex >= territories.length ? 0 : endIndex;
        }
        
        this.performanceStats.visibleTerritories = this.visibleTerritories.size;
    }
    
    // Render parallax starfield with multiple depth layers
    renderParallaxStarfield() {
        if (!this.starfield.initialized) return;
        
        const time = Date.now() * 0.001; // For subtle twinkling
        const cameraPosX = this.camera.x;
        const cameraPosY = this.camera.y;
        
        this.ctx.save();
        
        // Far stars (slowest parallax, barely moves)
        this.ctx.globalAlpha = 0.7; // Brighter for better visibility against background
        this.starfield.farStars.forEach(star => {
            // Very subtle parallax movement (5% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.05);
            const parallaxY = star.y - (cameraPosY * 0.05);
            
            // Skip stars outside visible area for performance
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            // Subtle twinkling effect
            const twinkle = star.twinkle + Math.sin(time * 0.5 + star.x * 0.01) * 0.1;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.7;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Mid stars (moderate parallax)
        this.ctx.globalAlpha = 0.8;
        this.starfield.midStars.forEach(star => {
            // Moderate parallax movement (15% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.15);
            const parallaxY = star.y - (cameraPosY * 0.15);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 0.8 + star.x * 0.02) * 0.15;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.8;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Near stars (most parallax movement)
        this.ctx.globalAlpha = 1.0;
        this.starfield.nearStars.forEach(star => {
            // Stronger parallax movement (30% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.3);
            const parallaxY = star.y - (cameraPosY * 0.3);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 1.2 + star.x * 0.03) * 0.2;
            this.ctx.globalAlpha = star.brightness * twinkle * 1.0;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderNebulas() {
        if (!this.gameMap.nebulas) return;
        
        this.ctx.save();
        
        // Render each nebula as a purple cloud
        this.gameMap.nebulas.forEach(nebula => {
            // Create radial gradient for cloud effect
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            
            gradient.addColorStop(0, `rgba(147, 51, 234, ${nebula.opacity})`);
            gradient.addColorStop(0.5, `rgba(147, 51, 234, ${nebula.opacity * 0.6})`);
            gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderTerritories() {
        this.updateVisibleTerritories();
        
        // Get current selected territory from input handler
        const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
        const selectedTerritory = inputState.selectedTerritory;
        
        // Render only visible territories
        for (const territoryId of this.visibleTerritories) {
            const territory = this.gameMap.territories[territoryId];
            if (territory) {
                territory.render(this.ctx, this.players, selectedTerritory, {
                    humanPlayer: this.humanPlayer,
                    homeSystemFlashStart: this.homeSystemFlashStart,
                    homeSystemFlashDuration: this.homeSystemFlashDuration,
                    gameMap: this.gameMap // Include game map for fog of war logic
                }, this.hoveredTerritory);
            }
        }
    }
    
    renderConnections() {
        this.ctx.lineWidth = 4;
        this.ctx.globalAlpha = 0.7;
        
        // Cache connections to avoid duplicate rendering
        const drawnConnections = new Set();
        
        // Use visible territories for optimized rendering
        const territoriesToCheck = this.visibleTerritories && this.visibleTerritories.size > 0 
            ? Array.from(this.visibleTerritories).map(id => this.gameMap.territories[id]).filter(t => t)
            : Object.values(this.gameMap.territories);
        
        territoriesToCheck.forEach(territory => {
            territory.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (!neighbor) return;
                
                // Create unique connection ID (smaller ID first)
                const connectionId = territory.id < neighborId 
                    ? `${territory.id}-${neighborId}` 
                    : `${neighborId}-${territory.id}`;
                
                if (drawnConnections.has(connectionId)) return;
                drawnConnections.add(connectionId);
                
                // SHOW ALL STAR LANES: Display all connections for better visibility
                const territoryOwnedByPlayer = territory.ownerId === this.humanPlayer?.id;
                const neighborOwnedByPlayer = neighbor.ownerId === this.humanPlayer?.id;
                const laneDiscovered = this.discoveredLanes.has(connectionId);
                
                // Always show star lanes (removed fog of war restriction)
                // if (!territoryOwnedByPlayer && !neighborOwnedByPlayer && !laneDiscovered) {
                //     return;
                // }
                
                // Add newly visible lanes to permanent discovery
                if ((territoryOwnedByPlayer || neighborOwnedByPlayer) && !laneDiscovered) {
                    this.discoveredLanes.add(connectionId);
                    console.log(`üó∫Ô∏è Star lane discovered: ${territory.id} ‚Üî ${neighborId}`);
                }
                
                // Set color based on ownership
                if (territory.ownerId !== null && 
                    neighbor.ownerId !== null && 
                    territory.ownerId === neighbor.ownerId) {
                    const owner = this.players[territory.ownerId];
                    this.ctx.strokeStyle = owner ? owner.color : '#666677';
                } else {
                    this.ctx.strokeStyle = '#666677';
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            });
        });
        
        this.ctx.globalAlpha = 1;
    }
    
    renderSupplyRoutes() {
        // Delegate to SupplySystem module for rendering
        this.supplySystem.renderSupplyRoutes(this.ctx, this.gameMap.territories);
    }
    
    getTransferPercentage(event) {
        // Default to 50% transfer
        if (!event) return 0.5;
        
        // Modifier key controls for different transfer amounts
        if (event.shiftKey) return 0.95; // Send almost all (leave 1)
        if (event.ctrlKey) return 0.25;  // Send quarter
        return 0.5; // Default 50%
    }
    
    renderDragPreview() {
        // Show drag preview when creating supply route
        if (this.isDraggingForSupplyRoute && this.dragStart) {
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            this.ctx.save();
            
            // Color-coded preview based on target validity
            if (targetTerritory && targetTerritory.ownerId === this.humanPlayer?.id && 
                targetTerritory.id !== this.dragStart.id) {
                this.ctx.strokeStyle = '#00ff00'; // Green for valid supply route target
                this.ctx.lineWidth = 3;
            } else {
                this.ctx.strokeStyle = '#ffff00'; // Yellow for neutral/unknown target
                this.ctx.lineWidth = 2;
            }
            
            this.ctx.globalAlpha = 0.8;
            this.ctx.setLineDash([5, 5]);
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.dragStart.x, this.dragStart.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }
    }
    
    renderProportionalDragUI() {
        if (!this.isProportionalDrag || !this.proportionalDragStart) return;
        
        this.ctx.save();
        
        const territory = this.proportionalDragStart.territory;
        const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Draw radial percentage indicator around source territory
        const radius = territory.radius + 15;
        const percentage = this.fleetPercentage;
        
        // Background circle
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 8;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Percentage arc
        const startAngle = -Math.PI / 2;
        const endAngle = startAngle + (percentage * Math.PI * 2);
        
        // Color based on percentage
        let color = '#44ff44'; // Green for low
        if (percentage > 0.7) color = '#ff4444'; // Red for high
        else if (percentage > 0.4) color = '#ffaa00'; // Orange for medium
        
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 6;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, startAngle, endAngle);
        this.ctx.stroke();
        
        // Calculate ships to send
        const availableShips = Math.max(0, territory.armySize - 1);
        const shipsToSend = Math.max(1, Math.floor(availableShips * percentage));
        const remaining = territory.armySize - shipsToSend;
        
        // Display text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 2;
        
        // Sending text
        const sendText = `Send: ${shipsToSend}`;
        this.ctx.strokeText(sendText, territory.x, territory.y - 8);
        this.ctx.fillText(sendText, territory.x, territory.y - 8);
        
        // Remaining text
        const remainText = `Keep: ${remaining}`;
        this.ctx.strokeText(remainText, territory.x, territory.y + 8);
        this.ctx.fillText(remainText, territory.x, territory.y + 8);
        
        // Draw drag line to target
        if (targetTerritory) {
            // Color based on action type
            let lineColor = '#666666';
            if (targetTerritory.ownerId === this.humanPlayer?.id) {
                lineColor = '#44ff44'; // Green for transfer
            } else if (targetTerritory.isColonizable) {
                lineColor = '#ffff00'; // Yellow for probe
            } else {
                lineColor = '#ff4444'; // Red for attack
            }
            
            this.ctx.strokeStyle = lineColor;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([8, 4]);
            this.ctx.beginPath();
            this.ctx.moveTo(territory.x, territory.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
        
        this.ctx.restore();
    }
    
    renderTransferPreview() {
        // Show fleet allocation preview when hovering over targets during selection
        if (!this.selectedTerritory || !this.hoveredTerritory || 
            this.selectedTerritory.id === this.hoveredTerritory.id ||
            this.selectedTerritory.ownerId !== this.humanPlayer?.id ||
            this.isProportionalDrag) { // Don't show during proportional drag
            return;
        }
        
        const from = this.selectedTerritory;
        const to = this.hoveredTerritory;
        
        // Only show preview for valid targets (neighbors or colonizable)
        const isValidTarget = from.neighbors.includes(to.id) || to.isColonizable;
        if (!isValidTarget) return;
        
        // Determine transfer percentage based on target type
        let transferPercentage = 0.5; // Default 50%
        if (to.ownerId === this.humanPlayer?.id) {
            transferPercentage = 0.5; // Transfer to own territory
        } else if (to.isColonizable) {
            transferPercentage = Math.min(1.0, 10 / from.armySize); // Probe cost (10 ships or all if less)
        } else {
            transferPercentage = 0.75; // Attack enemy territory
        }
        
        // Calculate amounts
        const availableShips = Math.max(0, from.armySize - 1);
        const shipsToSend = Math.min(availableShips, Math.max(1, Math.floor(from.armySize * transferPercentage)));
        const remaining = from.armySize - shipsToSend;
        
        // Convert to screen coordinates for UI display
        const screenPos = this.camera.worldToScreen(to.x, to.y);
        
        this.ctx.save();
        
        // Background for readability
        const padding = 8;
        const lineHeight = 16;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'left';
        
        const sendText = `Send: ${shipsToSend}`;
        const keepText = `Keep: ${remaining}`;
        const maxWidth = Math.max(this.ctx.measureText(sendText).width, this.ctx.measureText(keepText).width);
        
        const bgX = screenPos.x + 20;
        const bgY = screenPos.y - 25;
        const bgWidth = maxWidth + padding * 2;
        const bgHeight = lineHeight * 2 + padding;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
        
        // Border with action-specific color
        let borderColor = '#ffffff';
        if (to.ownerId === this.humanPlayer?.id) {
            borderColor = '#00ff00'; // Green for transfer
        } else if (to.isColonizable) {
            borderColor = '#ffff00'; // Yellow for probe
        } else {
            borderColor = '#ff4444'; // Red for attack
        }
        
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
        
        // Text
        this.ctx.fillStyle = '#00ff00'; // Green for send
        this.ctx.fillText(sendText, bgX + padding, bgY + lineHeight);
        
        this.ctx.fillStyle = '#ffffff'; // White for keep
        this.ctx.fillText(keepText, bgX + padding, bgY + lineHeight * 2);
        
        this.ctx.restore();
    }
    
    renderFloatingTexts() {
        if (!this.floatingTexts) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        // Update and render floating texts
        const now = Date.now();
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = now - text.startTime;
            if (elapsed >= text.duration) return false;
            
            // Calculate animation progress
            const progress = elapsed / text.duration;
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
            this.ctx.strokeText(text.text, text.x, text.y - yOffset);
            this.ctx.fillText(text.text, text.x, text.y - yOffset);
            
            return true;
        });
        
        this.ctx.restore();
    }
    
    renderArmies() {
        // Dynamic Level of Detail based on camera zoom level
        const zoomLevel = this.camera.getZoomLevel();
        const currentZoom = this.camera.zoom;
        
        // Supply system is now handled by Territory.js render method
        
        this.ctx.save();
        
        // Handle territories: visibleTerritories is a Set of IDs, convert to objects
        let territories;
        if (this.visibleTerritories && this.visibleTerritories.size > 0) {
            territories = Array.from(this.visibleTerritories).map(id => this.gameMap.territories[id]).filter(t => t);
        } else {
            territories = Object.values(this.gameMap.territories);
        }
        
        const playersLookup = {}; // Cache player lookups
        
        // Strategic View (zoomed out) - Show simplified information
        if (zoomLevel === 'strategic') {
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    // if (isEnemyMystery) continue; // SHOW ALL FLEET COUNTS
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner && territory.armySize >= 10) { // Only show significant fleets
                        let armyText = territory.armySize >= 100 ? `${Math.floor(territory.armySize / 10)}0+` : territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // Simplified text rendering for performance
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(armyText, territory.x, territory.y + 3);
                    }
                }
            }
        }
        // Operational View (mid zoom) - Show fleet counts as icons
        else if (zoomLevel === 'operational') {
            this.ctx.font = 'bold 13px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    // if (isEnemyMystery) continue; // SHOW ALL FLEET COUNTS
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        let armyText = territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // White outline for readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 4);
                        
                        // Color-coded text based on owner
                        this.ctx.fillStyle = owner.id === this.humanPlayer?.id ? '#000000' : '#333333';
                        this.ctx.fillText(armyText, territory.x, territory.y + 4);
                    }
                }
            }
        }
        // Tactical View (zoomed in) - Show full detail
        else {
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    // if (isEnemyMystery) continue; // SHOW ALL FLEET COUNTS
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        let armyText = territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // Debug logging for specific territories
                        if (territory.id === 79) {
                            console.log(`Star 79 tactical view: supplySystem exists: ${!!this.supplySystem}, isSupplySource: ${this.supplySystem?.isSupplySource(territory.id)}, text: "${armyText}"`);
                        }
                        
                        // High-contrast text with thick outline
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 5);
                        
                        // Main black text
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(armyText, territory.x, territory.y + 5);
                    }
                }
            }
        }
        
        this.ctx.restore();
    }
    
    render() {
        const startTime = performance.now();
        
        // Clear canvas with dark space background
        this.ctx.fillStyle = '#0a0a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render background galaxy image with parallax via UIManager (before camera transform)
        if (this.uiManager) {
            this.uiManager.renderBackgroundImage(this.ctx, this.camera);
        }
        
        // Render parallax starfield with movement via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Apply camera transformations for background elements
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render nebulas with proper depth
        this.renderNebulas();
        
        this.ctx.restore();
        
        // Apply camera transformations
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Update performance tracking
        this.updateVisibleTerritories();
        
        // Render connections between territories
        this.renderConnections();
        
        // Render supply routes
        this.renderSupplyRoutes();
        
        // Render territories with fleet counts
        this.renderTerritories();
        
        // Render probes (disabled - no active probes)
        // this.renderProbes();
        
        // Render ship animations
        this.renderShipAnimations();
        
        // Proportional drag interface handled by InputHandler
        
        // Selection is handled by Territory render method itself
        
        this.ctx.restore();
        
        // Floating discovery texts disabled - using top-center UI notifications instead
        // this.renderFloatingDiscoveryTexts();
        
        // Render UI overlay
        this.renderUI();
        
        // Update and render performance overlay
        if (this.performanceOverlay) {
            this.performanceOverlay.update();
            this.performanceOverlay.render();
        }
        
        // Update performance stats
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.renderTime = performance.now() - startTime;
        }
        this.performanceStats.renderTime = performance.now() - startTime;
    }
    
    renderFloatingDiscoveryTexts() {
        if (!this.floatingDiscoveryTexts || this.floatingDiscoveryTexts.length === 0) return;
        
        const now = Date.now();
        
        // Filter out expired texts and render remaining ones
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            if (age > text.duration) return false; // Remove expired texts
            
            // Only show human player discoveries
            if (text.playerId !== this.humanPlayer?.id) return false;
            
            // Calculate world position (not affected by camera)
            const worldX = text.x;
            const worldY = text.y - (age / text.duration) * 30; // Float upward over time
            
            // Convert to screen coordinates
            const screenX = (worldX - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
            const screenY = (worldY - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
            
            // Only render if on screen
            if (screenX < -100 || screenX > this.canvas.width + 100 || 
                screenY < -100 || screenY > this.canvas.height + 100) {
                return true; // Keep in array but don't render
            }
            
            // Calculate opacity (fade out in last 1 second)
            let opacity = 1;
            if (age > text.duration - text.fadeOutDuration) {
                const fadeAge = age - (text.duration - text.fadeOutDuration);
                opacity = 1 - (fadeAge / text.fadeOutDuration);
            }
            
            // Set up text rendering
            this.ctx.save();
            this.ctx.globalAlpha = opacity;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // Measure text with correct font
            this.ctx.font = 'bold 14px Arial';
            const textWidth = this.ctx.measureText(text.text).width;
            const padding = 8;
            
            // Draw text background for better visibility
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(screenX - textWidth/2 - padding, screenY - 12, textWidth + padding*2, 24);
            
            // Draw discovery icon
            this.ctx.font = '20px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.icon, screenX - textWidth/2 - 15, screenY);
            
            // Draw discovery text
            this.ctx.font = 'bold 14px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.text, screenX, screenY);
            
            this.ctx.restore();
            
            return true; // Keep in array
        });
    }
    
    renderUI() {
        if (this.ui) {
            const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
            
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: inputState.selectedTerritory,
                hoveredTerritory: this.inputHandler ? this.inputHandler.hoveredTerritory : null,
                mousePos: this.inputHandler ? this.inputHandler.mousePos : { x: 0, y: 0 },
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                // probeCount: this.probes.length, // Probe count disabled (no active probes)
                notifications: this.notifications,
                playerDiscoveries: this.playerDiscoveries,
                // recentProbeResults: this.recentProbeResults, // Probe results disabled
                discoveryLog: this.discoveryLog,
                showBonusPanel: this.showBonusPanel,
                inputState: inputState,
                messageText: this.messageText,
                messageTimer: this.messageTimer,
                combatSystem: this.combatSystem,
                supplySystem: this.supplySystem,
                territories: this.gameMap.territories
            });
        }
        
        // Render UI components via UIManager (notifications, messages)
        if (this.uiManager) {
            this.uiManager.renderNotifications(this.ctx);
            this.uiManager.renderMessage(this.ctx);
        }
        
        // Render top discovery bar
        if (this.discoverySystem) {
            this.discoverySystem.renderTopDiscoveryBar(this.ctx);
        }
    }
    
    // Input handling methods - REMOVED: Mouse handlers moved to InputHandler.js to prevent conflicts
    // All mouse input now processed through InputHandler.js and the finite state machine
    
    updateHoverState(mousePos) {
        const worldPos = this.camera.screenToWorld(mousePos.x, mousePos.y);
        const territory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        this.hoveredTerritory = territory;
        
        // Determine cursor mode based on selection and hover target
        if (this.selectedTerritory && this.selectedTerritory.ownerId === this.humanPlayer?.id && territory) {
            if (territory.ownerId === this.humanPlayer?.id && territory.id !== this.selectedTerritory.id) {
                this.cursorMode = 'transfer';
            } else if (territory.ownerId !== this.humanPlayer?.id && territory.ownerId !== null) {
                this.cursorMode = 'attack';
            } else if (territory.isColonizable) {
                this.cursorMode = 'probe';
            } else {
                this.cursorMode = 'default';
            }
        } else {
            this.cursorMode = 'default';
        }
        
        // Update canvas cursor
        this.updateCanvasCursor();
    }
    
    updateCanvasCursor() {
        if (!this.canvas) return;
        
        switch (this.cursorMode) {
            case 'attack':
                this.canvas.style.cursor = 'crosshair';
                break;
            case 'transfer':
                this.canvas.style.cursor = 'move';
                break;
            case 'probe':
                this.canvas.style.cursor = 'help';
                break;
            default:
                this.canvas.style.cursor = 'default';
                break;
        }
    }
    
    // Enhanced context action with modifier key support
    handleContextActionWithModifiers(targetTerritory) {
        if (!this.selectedTerritory || !targetTerritory) return;
        
        // Determine fleet percentage based on modifier keys
        let fleetPercentage = 0.5; // Default 50%
        
        if (this.modifierKeys.shift) {
            fleetPercentage = 1.0; // Send all available (leave 1)
        } else if (this.modifierKeys.ctrl) {
            fleetPercentage = 0.25; // Send 25% - conservative probe
        }
        
        this.executeFleetCommand(this.selectedTerritory, targetTerritory, fleetPercentage);
    }
    
    // Legacy context action for compatibility
    handleContextAction(targetTerritory) {
        if (!this.selectedTerritory || this.selectedTerritory.ownerId !== this.humanPlayer?.id || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        
        // Validate warp lane connectivity (except for colonizable planets)
        if (!targetTerritory.isColonizable && !fromTerritory.neighbors.includes(targetTerritory.id)) {
            console.log(`Cannot perform action: No warp lane from ${fromTerritory.id} to ${targetTerritory.id}`);
            return;
        }
        
        // Determine action based on target
        if (targetTerritory.ownerId === this.humanPlayer?.id && targetTerritory.id !== fromTerritory.id) {
            // Right-click on friendly territory - transfer
            this.transferArmies(fromTerritory, targetTerritory);
        } else if (targetTerritory.ownerId !== this.humanPlayer?.id && targetTerritory.ownerId !== null) {
            // Right-click on enemy territory - attack
            this.attackTerritory(fromTerritory, targetTerritory);
        } else if (targetTerritory.isColonizable) {
            // Right-click on colonizable territory - launch probe
            this.launchProbe(fromTerritory, targetTerritory);
        }
        
        // Visual feedback - flash the target territory
        targetTerritory.lastActionFlash = Date.now();
    }
    
    // Wheel handling moved to InputHandler
    
    handleUIClick(screenX, screenY) {
        // Handle UI element clicks (moved from old handleTerritorySelection)
        
        // Check for "PLAY AGAIN" button when human player is eliminated
        const humanPlayer = this.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            const buttonWidth = 200;
            const buttonHeight = 60;
            const buttonX = this.canvas.width / 2 - buttonWidth / 2;
            const buttonY = this.canvas.height / 2 + 50;
            
            if (screenX >= buttonX && screenX <= buttonX + buttonWidth &&
                screenY >= buttonY && screenY <= buttonY + buttonHeight) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for restart button on game over screen (mobile-friendly)
        if (this.gameState === 'ended' && this.ui && this.ui.restartButton) {
            const button = this.ui.restartButton;
            
            if (screenX >= button.x && screenX <= button.x + button.width &&
                screenY >= button.y && screenY <= button.y + button.height) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for leaderboard click (screen coordinates, not world coordinates)
        const leaderboardX = this.canvas.width - 220;
        const leaderboardY = 60;
        const leaderboardWidth = 200;
        const leaderboardHeight = this.leaderboardMinimized ? 30 : 200;
        
        if (screenX >= leaderboardX && screenX <= leaderboardX + leaderboardWidth &&
            screenY >= leaderboardY && screenY <= leaderboardY + leaderboardHeight) {
            this.leaderboardMinimized = !this.leaderboardMinimized;
            console.log('Leaderboard toggled:', this.leaderboardMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Check for minimap click - fix coordinate calculation
        const minimapSize = 150;
        const minimapX = this.canvas.width - minimapSize - 20;
        const minimapY = this.canvas.height - minimapSize - 20;
        const minimapHeight = this.minimapMinimized ? 30 : minimapSize;
        const minimapClickY = this.minimapMinimized ? (minimapY + minimapSize - 30) : minimapY;
        
        if (screenX >= minimapX && screenX <= minimapX + minimapSize &&
            screenY >= minimapClickY && screenY <= minimapClickY + minimapHeight) {
            this.minimapMinimized = !this.minimapMinimized;
            console.log('Minimap toggled:', this.minimapMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Zoom controls removed - using mousewheel only
        
        return false; // No UI element was clicked
    }
    
    launchProbe(fromTerritory, toTerritory) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            console.log('Not enough fleet power to launch probe! Need 10 fleet power.');
            return false;
        }
        
        if (!toTerritory.isColonizable) {
            console.log('Target territory is not colonizable!');
            return false;
        }
        
        // Create probe with gameMap and game references for nebula detection and discovery bonuses
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            this.humanPlayer.id,
            this.humanPlayer.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        
        // Emit probe launched event
        gameEvents.emit(GAME_EVENTS.PROBE_LAUNCHED, {
            probe: {
                id: probe.id,
                fromTerritoryId: fromTerritory.id,
                toTerritoryId: toTerritory.id
            },
            player: {
                id: this.humanPlayer.id,
                name: this.humanPlayer.name
            }
        }, EVENT_PRIORITY.MEDIUM);
        
        console.log(`Probe launched from territory ${fromTerritory.id} to colonizable planet ${toTerritory.id}`);
        return true;
    }
    
    launchAIProbe(fromTerritory, toTerritory, player) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            return;
        }
        
        // Create AI probe with gameMap and game references for nebula detection
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            player.id,
            player.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        

    }
    
    transferFleet(fromTerritory, toTerritory) {
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Delegate to centralized CombatSystem
        const success = this.combatSystem.transferArmies(fromTerritory, toTerritory);
        
        if (!success) {
            console.log('Transfer failed - not enough armies or invalid target');
        }
    }
    
    // Enhanced fleet transfer with specific amount
    transferFleetWithAmount(fromTerritory, toTerritory, amount) {
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Delegate to centralized CombatSystem with specific amount
        const success = this.combatSystem.transferArmies(fromTerritory, toTerritory, amount);
        
        if (!success) {
            console.log('Transfer failed - not enough armies or invalid target');
        }
    }
    
    // Supply route system - delegate to SupplySystem module
    async createSupplyRoute(fromTerritory, toTerritory) {
        try {
            const result = await this.supplySystem.createSupplyRoute(fromTerritory, toTerritory);
            if (result) {
                console.log(`Supply route created: ${fromTerritory.id} ‚Üí ${toTerritory.id}`);
            }
            return result;
        } catch (error) {
            console.error('Failed to create supply route:', error);
            return false;
        }
    }
    
    findPathBetweenTerritories(start, end) {
        // BFS to find shortest path through owned territories
        const queue = [[start]];
        const visited = new Set([start.id]);
        
        while (queue.length > 0) {
            const path = queue.shift();
            const current = path[path.length - 1];
            
            if (current.id === end.id) {
                return path;
            }
            
            // Check all neighbors
            current.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                
                if (neighbor && 
                    !visited.has(neighbor.id) && 
                    neighbor.ownerId === this.humanPlayer?.id) {
                    
                    visited.add(neighbor.id);
                    queue.push([...path, neighbor]);
                }
            });
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Check all supply routes for broken connections
        const routesToRemove = [];
        
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            // Check if territories still exist and are owned by player
            if (!fromTerritory || !toTerritory || 
                fromTerritory.ownerId !== this.humanPlayer?.id || 
                toTerritory.ownerId !== this.humanPlayer?.id) {
                routesToRemove.push(fromId);
                return;
            }
            
            // Revalidate path every few seconds
            const now = Date.now();
            if (now - route.lastValidation > 5000) {
                const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
                
                if (!newPath) {
                    routesToRemove.push(fromId);
                    console.log(`Supply route broken: ${fromId} ‚Üí ${route.targetId}`);
                } else {
                    // Update path and delay if it changed
                    const delayPerHop = 2000;
                    const newDelay = (newPath.length - 2) * delayPerHop;
                    
                    route.path = newPath;
                    route.delay = newDelay;
                    route.lastValidation = now;
                }
            }
        });
        
        // Remove broken routes
        routesToRemove.forEach(id => {
            this.supplyRoutes.delete(id);
        });
    }
    
    processSupplyRoutes() {
        // Handle automatic ship sending along supply routes
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && fromTerritory.armySize > 2) {
                // Send new ships when they're generated (but not too frequently)
                const now = Date.now();
                if (!route.lastShipment || now - route.lastShipment > 3000) {
                    const shipsToSend = Math.floor(fromTerritory.armySize / 3); // Send 1/3 of armies
                    
                    if (shipsToSend > 0) {
                        fromTerritory.armySize -= shipsToSend;
                        route.lastShipment = now;
                        
                        // Create delayed transfer with route visualization
                        this.createDelayedSupplyTransfer(fromTerritory, toTerritory, shipsToSend, route.delay);
                    }
                }
            }
        });
    }
    
    createDelayedSupplyTransfer(fromTerritory, toTerritory, shipCount, delay) {
        // Find the supply route to get the path
        const route = this.supplyRoutes.get(fromTerritory.id);
        if (route && route.path && route.path.length > 1) {
            // Create multi-hop ship animation following the path
            this.createSupplyRouteAnimation(route.path, this.humanPlayer.color);
        } else {
            // Fallback to direct animation
            this.createShipAnimation(fromTerritory, toTerritory, false);
        }
        
        // Apply transfer after delay
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipCount;
                console.log(`Supply route delivered ${shipCount} ships to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    findTerritoryAt(x, y) {
        // Viewport culling optimization: only check visible territories for hover detection
        if (this.visibleTerritories && this.visibleTerritories.size > 0) {
            for (const territoryId of this.visibleTerritories) {
                const territory = this.gameMap.territories[territoryId];
                if (!territory) continue;
                
                const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                if (distance <= territory.radius) {
                    return territory;
                }
            }
            return null;
        }
        
        // Fallback to spatial indexing if visibility culling not available
        return this.gameMap.findTerritoryAt(x, y);
    }
    
    // Core fleet command execution with percentage control
    executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, commandType = 'auto', path = null) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Calculate ships to send - hardcoded 50% for new system
        const availableShips = Math.max(0, fromTerritory.armySize - 1);
        const shipsToSend = Math.max(1, Math.floor(availableShips * 0.5));
        
        // Visual feedback - show number flying off
        this.showFleetCommandFeedback(fromTerritory, shipsToSend, 0.5);
        
        // Handle different command types
        switch (commandType) {
            case 'multi-hop-transfer':
                if (path && path.length > 1) {
                    this.executeMultiHopTransfer(fromTerritory, toTerritory, shipsToSend, path);
                    console.log(`Multi-hop transfer: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id} via path: ${path.join(' -> ')}`);
                } else {
                    console.error('Multi-hop transfer requires valid path');
                }
                break;
                
            case 'transfer':
                if (toTerritory.ownerId === this.humanPlayer?.id) {
                    this.combatSystem.transferArmies(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, false, shipsToSend);
                    console.log(`Direct transfer: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id}`);
                }
                break;
                
            case 'attack':
                if (toTerritory.ownerId !== this.humanPlayer?.id && !toTerritory.isColonizable) {
                    this.combatSystem.attackTerritory(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, true, shipsToSend);
                    console.log(`Attack: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id}`);
                }
                break;
                
            case 'auto':
            default:
                // Legacy auto-detection mode
                if (toTerritory.ownerId === this.humanPlayer?.id) {
                    this.combatSystem.transferArmies(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, false, shipsToSend);
                } else if (toTerritory.isColonizable) {
                    this.launchProbe(fromTerritory, toTerritory);
                } else {
                    this.combatSystem.attackTerritory(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, true, shipsToSend);
                }
                break;
        }
    }
    
    executeMultiHopTransfer(fromTerritory, toTerritory, shipsToSend, path) {
        // Validate path
        if (!path || path.length < 2) {
            console.error('Invalid path for multi-hop transfer');
            return;
        }
        
        // Execute transfer on source territory
        fromTerritory.armySize -= shipsToSend;
        
        // Create multi-hop animation following the path
        this.createSupplyRouteAnimation(path.map(id => this.gameMap.territories[id]), this.humanPlayer.color);
        
        // Calculate delivery delay based on path length (2 seconds per hop)
        const deliveryDelay = (path.length - 1) * 2000;
        
        // Schedule delivery to destination
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipsToSend;
                
                // Add visual feedback
                toTerritory.floatingText = {
                    text: `+${shipsToSend}`,
                    startTime: Date.now(),
                    duration: 2000,
                    startY: toTerritory.y
                };
                
                console.log(`Multi-hop transfer completed: ${shipsToSend} ships delivered to territory ${toTerritory.id}`);
            }
        }, deliveryDelay);
    }
    
    // Visual feedback for fleet commands
    showFleetCommandFeedback(territory, shipsToSend, percentage) {
        // Flash the territory briefly
        territory.lastCombatFlash = Date.now();
        
        // Show floating text with ship count
        const floatingText = {
            x: territory.x + (Math.random() - 0.5) * 40,
            y: territory.y - 20,
            text: `-${shipsToSend}`,
            color: percentage >= 0.8 ? '#ff4444' : percentage >= 0.5 ? '#ffaa00' : '#44ff44',
            startTime: Date.now(),
            duration: 1500
        };
        
        if (!this.floatingTexts) this.floatingTexts = [];
        this.floatingTexts.push(floatingText);
    }
    
    attackTerritory(attackingTerritory, defendingTerritory) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        // Delegate to centralized CombatSystem
        const result = this.combatSystem.attackTerritory(attackingTerritory, defendingTerritory);
        
        if (result.success) {
            console.log(`Territory captured! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            
            if (result.throneCapture) {
                console.log('üëë THRONE STAR CAPTURED!');
            }
            
            if (result.gameEnded) {
                this.endGame();
            }
        } else {
            if (result.reason) {
                console.log(`Attack failed: ${result.reason}`);
            } else {
                console.log(`Attack failed! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Enhanced attack method with custom army amount
    attackTerritoryWithAmount(attackingTerritory, defendingTerritory, attackingArmies) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        // Delegate to centralized CombatSystem with specific army count
        const result = this.combatSystem.attackTerritory(attackingTerritory, defendingTerritory, attackingArmies);
        
        if (result.success) {
            console.log(`Territory captured with custom attack! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            
            if (result.throneCapture) {
                console.log('üëë THRONE STAR CAPTURED!');
            }
            
            if (result.gameEnded) {
                this.endGame();
            }
        } else {
            if (result.reason) {
                console.log(`Custom attack failed: ${result.reason}`);
            } else {
                console.log(`Custom attack failed! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Touch event handlers for mobile
    handleTouchStart(e) {
        e.preventDefault();
        
        this.touchStartTime = Date.now();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchStart: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch - prepare for selection or pan
            const touch = e.touches[0];
            this.mousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            this.lastMousePos = { ...this.mousePos };
            this.isDragging = false;
            this.isMultiTouch = false;
            
            // Setup long press detection
            this.longPressStartPos = { ...this.mousePos };
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            this.longPressTarget = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            // Clear any existing long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
            }
            
            // Start long press timer
            this.longPressTimer = setTimeout(() => {
                this.handleLongPress();
            }, this.longPressThreshold);
            
            this.touchDebugInfo += `\nSingle: ${Math.round(this.mousePos.x)}, ${Math.round(this.mousePos.y)}`;
            
        } else if (e.touches.length === 2) {
            // Two touches - enhanced pinch zoom and pan
            this.isMultiTouch = true;
            this.isDragging = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Store initial touch positions for pan/zoom
            this.touchStartDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            this.pinchCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            this.lastMousePos = { ...this.pinchCenter };
            this.initialZoom = this.camera.zoom; // Store initial zoom for relative scaling
            this.lastPinchDistance = this.touchStartDistance; // Track for smooth updates
            
            this.touchDebugInfo += `\nPinch Start: dist ${Math.round(this.touchStartDistance)} zoom ${(this.initialZoom * 100).toFixed(0)}%`;
        }
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchMove: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch drag - pan
            const touch = e.touches[0];
            const currentPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            this.touchDebugInfo += `\nSingle: ${Math.round(currentPos.x)}, ${Math.round(currentPos.y)}`;
            
            if (this.lastMousePos) {
                const deltaX = currentPos.x - this.lastMousePos.x;
                const deltaY = currentPos.y - this.lastMousePos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Start dragging if moved more than 10 pixels
                if (!this.isDragging && distance > 10) {
                    this.isDragging = true;
                    this.touchDebugInfo += `\nStarted Pan`;
                    
                    // Cancel long press if we start dragging
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                }
                
                if (this.isDragging && !this.isMultiTouch) {
                    this.camera.pan(-deltaX, -deltaY);
                    this.touchDebugInfo += `\nPan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentPos;
            
        } else if (e.touches.length === 2) {
            // Two touches - pinch zoom and pan
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Calculate current distance for zoom
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            // Enhanced pinch-to-zoom with much higher sensitivity
            if (this.lastPinchDistance && Math.abs(currentDistance - this.lastPinchDistance) > 2) {
                // Use incremental scaling with higher sensitivity
                const distanceRatio = currentDistance / this.lastPinchDistance;
                
                // Apply incremental zoom change with dramatic sensitivity
                const zoomMultiplier = 1 + (distanceRatio - 1) * 1.5; // Dramatic scaling for responsive zoom
                const newZoom = Math.max(0.5, Math.min(3.0, this.camera.zoom * zoomMultiplier));
                
                // Calculate zoom center between the two fingers
                const centerX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                const centerY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
                
                // Apply zoom smoothly to the pinch center
                this.camera.zoomTo(newZoom, centerX, centerY);
                this.lastPinchDistance = currentDistance;
                this.lastZoomTime = Date.now();
                
                this.touchDebugInfo += `\nPinch Zoom: ${(newZoom * 100).toFixed(0)}% (dist: ${Math.round(currentDistance)})`;
            }
            
            // Enhanced two-finger pan with smoother movement
            const currentCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            if (this.lastMousePos && Date.now() - this.lastZoomTime > 50) {
                const deltaX = currentCenter.x - this.lastMousePos.x;
                const deltaY = currentCenter.y - this.lastMousePos.y;
                
                // Smoother pan threshold for better control
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    this.camera.pan(-deltaX * 0.8, -deltaY * 0.8); // Damped panning
                    this.touchDebugInfo += `\nTwo-finger pan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentCenter;
        }
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        const touchDuration = Date.now() - this.touchStartTime;
        console.log('Touch end:', e.touches.length, 'remaining touches, duration:', touchDuration);
        
        if (e.touches.length === 0) {
            // All fingers lifted
            if (!this.isDragging && touchDuration < 500 && this.mousePos) {
                // Quick tap - handle territory selection
                const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
                this.handleTerritorySelection(worldPos);
                console.log('Territory selection at:', worldPos);
            }
            
            this.isDragging = false;
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            this.lastPinchDistance = null;
            this.lastMousePos = null;
            this.pinchCenter = null;
            this.lastZoomTime = 0;
            this.initialZoom = 1.0;
            
            // Cancel long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            
        } else if (e.touches.length === 1) {
            // One finger lifted during multi-touch - continue with single touch
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            this.lastMousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }
    }
    
    // Keyboard handling is now done by InputHandler module
    
    handleDoubleClick(targetTerritory) {
        // Double-click detected - create supply route between owned territories
        if (!this.selectedTerritory || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        const toTerritory = targetTerritory;
        
        // Both territories must be owned by human player
        if (fromTerritory.ownerId !== this.humanPlayer?.id || toTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Must be different territories
        if (fromTerritory.id === toTerritory.id) {
            return;
        }
        
        // Check if connected by owned territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (path && path.length > 0) {
            this.createSupplyRoute(fromTerritory, toTerritory);
            console.log(`Double-click: Supply route created from ${fromTerritory.id} to ${toTerritory.id}`);
        } else {
            console.log('Double-click: Territories not connected by owned star lanes for supply route');
        }
    }
    
    restartGame() {
        // Reset game state
        this.gameState = 'lobby';
        this.gameTimer = 10 * 60 * 1000;
        this.selectedTerritory = null;
        
        // Clear players
        this.players = [];
        this.humanPlayer = null;
        
        // Regenerate map and restart
        this.gameMap = new GameMap(2000, 1500, this.config); // Pass config to maintain connection distances
        this.startGame();
    }
    
    /**
     * Validates throne star assignments and fixes double throne star bugs
     */
    validateThroneStars() {
        console.log('üîç THRONE VALIDATION: Starting validation...');
        
        // Count throne stars per player
        const playerThroneCount = new Map();
        
        for (const player of this.players) {
            playerThroneCount.set(player.id, 0);
        }
        
        // Count throne stars and log what we find
        const allThrones = [];
        for (const territory of Object.values(this.gameMap.territories)) {
            if (territory.isThronestar) {
                allThrones.push({id: territory.id, owner: territory.ownerId});
                if (territory.ownerId !== null) {
                    const currentCount = playerThroneCount.get(territory.ownerId) || 0;
                    playerThroneCount.set(territory.ownerId, currentCount + 1);
                }
            }
        }
        
        console.log(`üîç THRONE VALIDATION: Found ${allThrones.length} throne stars:`, allThrones);
        console.log(`üîç THRONE VALIDATION: Player throne counts:`, Array.from(playerThroneCount.entries()));
        
        // Fix players with multiple throne stars
        let fixed = false;
        for (const [playerId, throneCount] of playerThroneCount.entries()) {
            if (throneCount > 1) {
                const player = this.players.find(p => p.id === playerId);
                console.log(`üîß FIXING: Player ${player ? player.name : playerId} (ID: ${playerId}) has ${throneCount} throne stars - removing extras`);
                
                // Find all throne stars for this player
                const playerThrones = [];
                for (const territory of Object.values(this.gameMap.territories)) {
                    if (territory.isThronestar && territory.ownerId === playerId) {
                        playerThrones.push(territory);
                    }
                }
                
                console.log(`üîß Found throne territories for player ${playerId}:`, playerThrones.map(t => t.id));
                
                // Keep the first throne star, remove the rest
                for (let i = 1; i < playerThrones.length; i++) {
                    playerThrones[i].isThronestar = false;
                    console.log(`üîß Removed throne star flag from territory ${playerThrones[i].id}`);
                    fixed = true;
                }
            }
        }
        
        if (!fixed) {
            console.log('üîç THRONE VALIDATION: No fixes needed, all players have single throne stars');
        }
    }
}


===============================================================================
CLIENT/SRC/GAME/SUPPLYSYSTEM.JS - SUPPLY ROUTE MANAGEMENT
===============================================================================

/**
 * SupplySystem.js - Supply route management module
 * 
 * Manages the creation, validation, and processing of supply routes.
 * Uses the new PathfindingService for route calculations.
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants';
// Removed PathfindingService import (unused; using injected game.pathfindingService)

export class SupplySystem {
    constructor(game) {
        this.game = game;
        this.supplyRoutes = [];
        this.routeValidationFrame = 0;
        this.routeProcessingFrame = 0;
    }
    
    async createSupplyRoute(fromTerritory, toTerritory) {
        console.log('SupplySystem: createSupplyRoute called', fromTerritory.id, toTerritory.id);
        
        if (!this.validateSupplyRouteCreation(fromTerritory, toTerritory)) {
            console.log('SupplySystem: validation failed');
            return false;
        }
        
        /*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  NEW  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
         * A source star may supply ONE destination at a time.
         * If the source already has a route, remove / replace it.          */
        this.supplyRoutes = this.supplyRoutes.filter(r => {
            const keep = r.from !== fromTerritory.id;
            if (!keep) console.log(`SupplySystem: replacing route ${r.id} from ${r.from}`);
            return keep;
        });
        
        // Check if pathfinding service exists
        if (!this.game.pathfindingService) {
            console.log('SupplySystem: pathfindingService not available');
            return false;
        }
        
        // Find path between territories using PathfindingService
        console.log('SupplySystem: calling pathfindingService.findShortestPath');
        
        // Create proper graph structure for pathfinding
        // Convert gameMap.territories object to array for pathfinding service
        const territoriesArray = Object.values(this.game.gameMap.territories);
        const graph = {
            territories: territoriesArray
        };
        
        console.log('SupplySystem: created graph with', territoriesArray.length, 'territories');
        console.log('SupplySystem: first few territories:', territoriesArray.slice(0, 2));
        console.log('SupplySystem: humanPlayer:', this.game.humanPlayer);
        const path = await this.game.pathfindingService.findShortestPath(
            fromTerritory.id, 
            toTerritory.id, 
            graph, 
            this.game.humanPlayer?.id
        );
        
        console.log('SupplySystem: pathfinding result:', path);
        
        if (!path || path.length < 2) {
            console.log('No valid path found between territories');
            return false;
        }
        
        // Create new supply route
        const route = {
            id: this.generateRouteId(),
            from: fromTerritory.id,
            to: toTerritory.id,
            path: path,
            active: true,
            lastTransfer: 0,
            transferCooldown: GAME_CONSTANTS.SUPPLY_ROUTE.TRANSFER_INTERVAL,
            createdTime: Date.now()
        };
        
        this.supplyRoutes.push(route);
        
        console.log(`Supply route created: ${fromTerritory.id} ‚Üí ${toTerritory.id} (${path.length} hops)`);
        
        // Visual feedback
        this.game.showMessage(`Supply route established: ${path.length - 1} hop${path.length > 2 ? 's' : ''}`, 2000);
        
        return true;
    }
    
    validateSupplyRouteCreation(fromTerritory, toTerritory) {
        const humanPlayerId = this.game.humanPlayer?.id;
        
        // Check ownership
        if (fromTerritory.ownerId !== humanPlayerId || toTerritory.ownerId !== humanPlayerId) {
            console.log('Both territories must be owned by player to create supply route');
            return false;
        }
        
        // Check if territories are different
        if (fromTerritory.id === toTerritory.id) {
            console.log('Cannot create supply route to same territory');
            return false;
        }
        
        return true;
    }
    
    // Removed unused: findExistingRoute (no other code calls this)
    
    findPathBetweenTerritories(fromTerritory, toTerritory) {
        const humanPlayerId = this.game.humanPlayer?.id;
        const visited = new Set();
        const queue = [{
            territory: fromTerritory,
            path: [fromTerritory]
        }];
        
        visited.add(fromTerritory.id);
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            // Found target
            if (current.territory.id === toTerritory.id) {
                return current.path;
            }
            
            // Explore neighbors
            for (const neighborId of current.territory.neighbors) {
                if (visited.has(neighborId)) continue;
                
                const neighbor = this.game.gameMap.territories[neighborId];
                if (!neighbor) continue;
                
                // Only traverse through owned territories
                if (neighbor.ownerId !== humanPlayerId) continue;
                
                visited.add(neighborId);
                queue.push({
                    territory: neighbor,
                    path: [...current.path, neighbor]
                });
            }
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Throttle validation to every 45 frames
        this.routeValidationFrame++;
        if (this.routeValidationFrame < 45) return;
        this.routeValidationFrame = 0;
        
        const humanPlayerId = this.game.humanPlayer?.id;
        
        for (let i = this.supplyRoutes.length - 1; i >= 0; i--) {
            const route = this.supplyRoutes[i];
            
            // Check if territories still exist and are owned
            const fromTerritory = this.game.gameMap.territories[route.from];
            const toTerritory = this.game.gameMap.territories[route.to];
            
            if (!fromTerritory || !toTerritory ||
                fromTerritory.ownerId !== humanPlayerId ||
                toTerritory.ownerId !== humanPlayerId) {
                
                console.log(`Supply route ${route.id} invalidated - territory ownership changed`);
                this.supplyRoutes.splice(i, 1);
                continue;
            }
            
            // Validate path integrity
            if (!this.isPathValid(route.path, humanPlayerId)) {
                console.log(`Supply route ${route.id} invalidated - path broken`);
                route.active = false;
                
                // Try to find new path
                const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
                if (newPath) {
                    route.path = newPath;
                    route.active = true;
                    console.log(`Supply route ${route.id} rerouted`);
                } else {
                    this.supplyRoutes.splice(i, 1);
                }
            }
        }
    }
    
    isPathValid(path, ownerId) {
        // Path contains territory IDs, not territory objects
        for (const territoryId of path) {
            const territory = this.game.gameMap.territories[territoryId];
            if (!territory || territory.ownerId !== ownerId) {
                return false;
            }
        }
        
        // Check path connectivity
        for (let i = 0; i < path.length - 1; i++) {
            const currentId = path[i];
            const nextId = path[i + 1];
            const current = this.game.gameMap.territories[currentId];
            
            if (!current || !current.neighbors.includes(nextId)) {
                return false;
            }
        }
        
        return true;
    }
    
    processSupplyRoutes(deltaTime) {
        // Supply routes now redirect army generation instead of transferring armies
        // Validation is handled in validateSupplyRoutes() method called from main game loop
        // This method is no longer needed but kept for interface compatibility
    }
    
    // Supply routes now redirect army generation instead of transferring armies
    // The old transfer-based methods are no longer needed
    
    generateRouteId() {
        return `route_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Check if a territory is redirecting its army generation via supply route
    isSupplySource(territoryId) {
        return this.supplyRoutes.some(route => route.active && route.from === territoryId);
    }
    
    // Get the destination territory for a supply source
    getSupplyDestination(territoryId) {
        const route = this.supplyRoutes.find(route => route.active && route.from === territoryId);
        return route ? route.to : null;
    }
    
    // Public interface
    getActiveSupplyRoutes() {
        return this.supplyRoutes.filter(route => route.active);
    }
    
    // Removed unused: getSupplyRouteCount (simply this.supplyRoutes.length)
    
    removeSupplyRoute(routeId) {
        const index = this.supplyRoutes.findIndex(route => route.id === routeId);
        if (index > -1) {
            this.supplyRoutes.splice(index, 1);
            console.log(`Supply route ${routeId} removed`);
            return true;
        }
        return false;
    }
    
    // Removed unused: removeAllSupplyRoutes (no callers found)
    
    renderSupplyRoutes(ctx, territories) {
        // Render active supply routes with animated arrows
        this.supplyRoutes.forEach(route => {
            if (!route.active) return;
            
            const fromTerritory = territories[route.from];
            const toTerritory = territories[route.to];
            
            if (fromTerritory && toTerritory && route.path && route.path.length > 1) {
                ctx.save();
                
                // Draw route path with animated dashes - color based on activity
                const routeActive = fromTerritory.armySize > 10; // Route is active if source has armies
                if (routeActive) {
                    ctx.strokeStyle = '#00ffff'; // Bright cyan for active routes
                    ctx.globalAlpha = 0.9;
                } else {
                    ctx.strokeStyle = '#006666'; // Dimmed cyan for inactive routes
                    ctx.globalAlpha = 0.5;
                }
                ctx.lineWidth = 3;
                
                /* Dynamic dash speed : faster when more lines converge */
                const currentTime   = Date.now();
                const inboundCount  = this.supplyRoutes.filter(r =>
                      r.active && r.to === route.to).length;
                const speedFactor   = Math.min(inboundCount, 6); // cap at 6 √ó
                const animationOffset = (currentTime * (0.02 * speedFactor)) % 20;
                ctx.setLineDash([8, 12]);
                ctx.lineDashOffset = -animationOffset;
                
                // Draw path segments using territory IDs to get coordinates
                for (let i = 0; i < route.path.length - 1; i++) {
                    const currentId = route.path[i];
                    const nextId = route.path[i + 1];
                    const current = territories[currentId];
                    const next = territories[nextId];
                    
                    if (current && next) {
                        ctx.beginPath();
                        ctx.moveTo(current.x, current.y);
                        ctx.lineTo(next.x, next.y);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
                
                /* White pulsing highlight while either end is hovered */
                const hoveredId = this.game.inputHandler?.hoveredTerritory?.id;
                if (hoveredId === route.from || hoveredId === route.to) {
                    const pulse = 0.5 + 0.5 * Math.sin(currentTime * 0.006);
                    ctx.save();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth   = 4;
                    ctx.globalAlpha = pulse;
                    ctx.setLineDash([]);   // solid white pulse
                    ctx.beginPath();
                    for (let i = 0; i < route.path.length - 1; i++) {
                        const c = territories[route.path[i]];
                        const n = territories[route.path[i + 1]];
                        if (c && n) {
                            if (i === 0) ctx.moveTo(c.x, c.y);
                            ctx.lineTo(n.x, n.y);
                        }
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            }
        });
    }
    
    stopSupplyRoutesFromTerritory(territoryId) {
        const routesToRemove = this.supplyRoutes.filter(route => route.from === territoryId);
        const count = routesToRemove.length;
        
        if (count > 0) {
            this.supplyRoutes = this.supplyRoutes.filter(route => route.from !== territoryId);
            console.log(`Supply Stopped - ${count} route(s) from territory ${territoryId} halted`);
            return true;
        }
        return false;
    }
    
    getSupplyRoutesBetween(territoryId1, territoryId2) {
        return this.supplyRoutes.filter(route => 
            (route.from === territoryId1 && route.to === territoryId2) ||
            (route.from === territoryId2 && route.to === territoryId1)
        );
    }
    
    // Debug and statistics
    getSupplyRouteStats() {
        const active = this.supplyRoutes.filter(r => r.active).length;
        const inactive = this.supplyRoutes.filter(r => !r.active).length;
        const totalPaths = this.supplyRoutes.reduce((sum, r) => sum + (r.path?.length || 0), 0);
        const avgPathLength = this.supplyRoutes.length > 0 ? totalPaths / this.supplyRoutes.length : 0;
        
        return {
            total: this.supplyRoutes.length,
            active,
            inactive,
            averagePathLength: Math.round(avgPathLength * 100) / 100
        };
    }
    
    logSupplyRouteDebug() {
        console.log('=== Supply Route Debug ===');
        console.log(`Total routes: ${this.supplyRoutes.length}`);
        
        for (const route of this.supplyRoutes) {
            const fromTerritory = this.game.gameMap.territories[route.from];
            const toTerritory = this.game.gameMap.territories[route.to];
            
            console.log(`Route ${route.id}: ${route.from} ‚Üí ${route.to}`);
            console.log(`  Status: ${route.active ? 'Active' : 'Inactive'}`);
            console.log(`  Path length: ${route.path?.length || 0} territories`);
            console.log(`  From armies: ${fromTerritory?.armySize || 'N/A'}`);
            console.log(`  To armies: ${toTerritory?.armySize || 'N/A'}`);
            console.log(`  Last transfer: ${Date.now() - route.lastTransfer}ms ago`);
        }
    }
}

===============================================================================
CLIENT/SRC/GAME/TERRITORY.JS - TERRITORY DATA STRUCTURE
===============================================================================

export class Territory {
    constructor(id, x, y, radius = 25, isColonizable = false) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.neighbors = [];
        this.hiddenNeighbors = []; // Legacy - no longer used with new visibility system
        this.ownerId = null; // null for neutral, or player ID
        
        // All territories start with neutral garrisons (1-30 armies)
        this.armySize = Math.floor(Math.random() * 30) + 1;
        this.isColonizable = false; // No longer needed with new visibility system
        
        // Visual properties
        this.baseColor = '#444444';
        this.neutralColor = '#666666'; // Standard neutral color
        this.strokeColor = '#888888'; // Standard stroke for all territories
        
        // Animation
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.lastArmyGeneration = 0;
        this.armyGenerationRate = 3000; // Generate army every 3 seconds (matches GAME_CONSTANTS)
        
        // Combat flash effect
        this.combatFlashTime = 0;
        this.combatFlashDuration = 800; // Flash for 800ms
        
        // Probe launch visual feedback
        this.probeFlashTime = 0;
        this.probeFlashDuration = 1000; // Flash for 1 second
        this.floatingText = null; // For floating "-10" text
    }
    
    addNeighbor(territoryId) {
        if (!this.neighbors.includes(territoryId)) {
            this.neighbors.push(territoryId);
        }
    }
    
    addHiddenNeighbor(territoryId) {
        if (!this.hiddenNeighbors.includes(territoryId)) {
            this.hiddenNeighbors.push(territoryId);
        }
    }
    
    revealConnections() {
        // Move hidden connections to visible neighbors when colonized
        this.neighbors.push(...this.hiddenNeighbors);
        this.hiddenNeighbors = [];
        this.isColonizable = false; // No longer colonizable
    }
    
    isNeutral() {
        return this.ownerId === null;
    }
    
    triggerCombatFlash() {
        this.combatFlashTime = Date.now();
    }
    
    // triggerProbeFlash disabled (no probes active)
    // triggerProbeFlash() {
    //     this.probeFlashTime = Date.now();
    //     this.floatingText = {
    //         text: '-10',
    //         startTime: Date.now(),
    //         duration: 1000,
    //         startY: this.y - this.radius - 10,
    //         color: '#ff4444'
    //     };
    // }
    
    generateArmies(deltaTime, player, gameSpeed = 1.0, game = null) {
        // Neutral territories have fixed army sizes and don't generate armies
        if (this.ownerId === null) return;
        
        // Don't generate armies until a few seconds after game start to prevent initialization issues
        if (game && game.gameStartTime && (Date.now() - game.gameStartTime) < 5000) {
            return;
        }
        
        // Apply game speed multiplier to army generation timing
        const speedAdjustedDelta = deltaTime * gameSpeed;
        this.lastArmyGeneration += speedAdjustedDelta;
        
        // Calculate generation rate with discovery bonuses
        let effectiveGenerationRate = this.armyGenerationRate;
        
        // Apply planet-specific bonuses
        if (this.discoveryBonus === 'factory') {
            effectiveGenerationRate *= 0.5; // 200% speed (half the time)
        } else if (this.discoveryBonus === 'minerals') {
            effectiveGenerationRate *= 0.67; // 150% speed
        } else if (this.discoveryBonus === 'void_storm') {
            effectiveGenerationRate *= 1.33; // 75% speed
        }
        
        // Apply empire-wide nanotech bonus
        if (game && game.discoveries && game.discoveries.precursorNanotech > 0) {
            const nanotechBonus = 1 + (game.discoveries.precursorNanotech * 0.1);
            effectiveGenerationRate /= nanotechBonus;
        }
        
        if (this.lastArmyGeneration >= effectiveGenerationRate) {
            const armiesGenerated = Math.floor(this.lastArmyGeneration / effectiveGenerationRate);
            this.lastArmyGeneration = this.lastArmyGeneration % effectiveGenerationRate;
            
            // Check if this territory has an active supply route
            if (game && game.supplySystem && game.supplySystem.isSupplySource(this.id)) {
                const destinationId = game.supplySystem.getSupplyDestination(this.id);
                const destinationTerritory = game.gameMap.territories[destinationId];
                
                if (destinationTerritory && destinationTerritory.ownerId === this.ownerId) {
                    // Redirect army generation to destination
                    destinationTerritory.armySize += armiesGenerated;
                    // Supply route redirection (logging disabled for cleaner console output)
                    
                    // Visual feedback disabled to prevent text spam on heavily reinforced territories
                } else {
                    // Route broken, generate locally
                    this.armySize += armiesGenerated;
                }
            } else {
                // Normal army generation
                this.armySize += armiesGenerated;
            }
            
            if (player) {
                player.totalArmies += armiesGenerated;
            }
        }
    }
    
    render(ctx, players, selectedTerritory, gameData, hoveredTerritory = null) {
        const isSelected = selectedTerritory && selectedTerritory.id === this.id;
        const isHovered = hoveredTerritory && hoveredTerritory.id === this.id;
        
        // Determine territory color
        let fillColor = this.neutralColor;
        if (this.ownerId !== null && players[this.ownerId]) {
            fillColor = players[this.ownerId].color;
        }
        
        // Add home system flashing effect for human player
        if (gameData && gameData.humanPlayer && this.ownerId === gameData.humanPlayer.id && 
            gameData.homeSystemFlashStart && gameData.humanPlayer.territories.includes(this.id)) {
            const currentTime = Date.now();
            const elapsed = currentTime - gameData.homeSystemFlashStart;
            
            if (elapsed < gameData.homeSystemFlashDuration) {
                // Flash every 300ms for 3 seconds
                const flashCycle = Math.floor(elapsed / 300) % 2;
                if (flashCycle === 1) {
                    fillColor = '#ffffff'; // Flash to white
                }
            }
        }
        
        // Add combat flash effect (only for owned territories)
        const currentTime = Date.now();
        if (this.ownerId !== null && this.combatFlashTime > 0 && currentTime - this.combatFlashTime < this.combatFlashDuration) {
            const flashProgress = (currentTime - this.combatFlashTime) / this.combatFlashDuration;
            const flashIntensity = Math.sin(flashProgress * Math.PI * 6) * (1 - flashProgress);
            if (flashIntensity > 0 && this.combatFlashColor) {
                // Use attacker's color for combat flash
                fillColor = this.combatFlashColor;
            } else if (flashIntensity > 0) {
                // Fallback to red if no color specified
                fillColor = this.adjustColorBrightness('#ff4444', 1 + flashIntensity * 0.8);
            }
        }
        
        // Add selection highlighting
        if (isSelected) {
            // Pulsing selection effect
            this.pulsePhase += 0.1;
            const pulseIntensity = Math.sin(this.pulsePhase) * 0.3 + 0.7;
            fillColor = this.adjustColorBrightness(fillColor, pulseIntensity);
        }
        
        // Optimize rendering with batch operations
        ctx.save();
        
        // FOG OF WAR: Check if this is a mysterious territory
        const humanPlayerId = gameData?.humanPlayer?.id;
        const isNeutralMystery = this.ownerId === null && !this.neighbors.some(neighborId => {
            const neighbor = gameData?.gameMap?.territories?.[neighborId];
            return neighbor && neighbor.ownerId === humanPlayerId;
        });
        
        const isEnemyMystery = this.ownerId !== null && this.ownerId !== humanPlayerId && !this.neighbors.some(neighborId => {
            const neighbor = gameData?.gameMap?.territories?.[neighborId];
            return neighbor && neighbor.ownerId === humanPlayerId;
        });
        
        const isMysteriousTerritory = isNeutralMystery || isEnemyMystery;
        
        // Adjust rendering for mysterious territories
        const renderRadius = isMysteriousTerritory ? this.radius * 0.8 : this.radius;
        const renderAlpha = isMysteriousTerritory ? 0.6 : 1.0;
        
        // Add hover glow effect (reduced for mysterious territories)
        if (isHovered && !isSelected) {
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = isMysteriousTerritory ? 8 : 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Apply mystery transparency
        ctx.globalAlpha = renderAlpha;
        
        // Draw territory circle and border in single operation
        ctx.beginPath();
        ctx.arc(this.x, this.y, renderRadius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        
        // Clear shadow for subsequent rendering
        ctx.shadowBlur = 0;
        
        // Optimize player lookup using direct access
        const player = this.ownerId ? players[this.ownerId] : null;
        const isHumanPlayer = player && player.type === 'human';
        
        // Set stroke properties based on state
        if (isSelected) {
            // Pulsating selection outline
            const pulseIntensity = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulseIntensity})`;
            ctx.lineWidth = 4;
        } else if (isHovered) {
            // Bright white hover outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
        } else if (isHumanPlayer) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
        } else {
            ctx.strokeStyle = this.strokeColor;
            ctx.lineWidth = 1;
        }
        ctx.stroke();
        
        // Action confirmation flash
        if (this.lastActionFlash && (currentTime - this.lastActionFlash) < 300) {
            const flashProgress = (currentTime - this.lastActionFlash) / 300;
            const flashIntensity = 1 - flashProgress;
            ctx.strokeStyle = `rgba(0, 255, 0, ${flashIntensity})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Add extra ring for player territories
        if (this.ownerId !== null && player) {
            // Draw outer ring for all player territories
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 4, 0, Math.PI * 2);
            
            if (isHumanPlayer) {
                // Bright cyan outer ring for human player
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 6;
            } else {
                // Player color outer ring for AI players
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 3;
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        // Draw flag for human player territories
        if (isHumanPlayer) {
            this.renderHumanFlag(ctx);
        }
        
        // Draw crown for throne star territories (SHOW ALL CROWNS)
        if (this.isThronestar && this.ownerId !== null) {
            this.renderCrown(ctx);
        }
        
        // Draw factory icon for Precursor Factory discoveries
        if (this.hasFactory) {
            this.renderFactoryIcon(ctx);
        }
        
        // Draw explosion animation for failed probes
        if (this.explosionTime && Date.now() - this.explosionTime < this.explosionDuration) {
            this.renderExplosion(ctx);
        }
        
        // Draw army count for neutral territories - hide only if in nebula
        if (this.ownerId === null) {
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            // Check if territory is inside a nebula (hide fleet count if so)
            const isInNebula = gameData?.gameMap?.isInNebula?.(this.x, this.y) || false;
            
            if (isInNebula) {
                // Neutral territory in nebula - show purple question mark
                ctx.fillStyle = '#9966ff'; // Purple text for nebula mystery
                ctx.strokeStyle = 'rgba(153, 102, 255, 0.8)'; // Purple outline
                ctx.lineWidth = 2;
                ctx.font = 'bold 16px Arial';
                
                const displayText = '?';
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            } else {
                // Neutral territory outside nebula - show army count normally
                ctx.fillStyle = '#000000'; // Black text
                ctx.strokeStyle = '#ffffff'; // White outline for contrast
                ctx.lineWidth = 2;
                
                const displayText = this.armySize.toString();
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            }
        }
        
        // Draw territory ID (for debugging)
        if (isSelected) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`T${this.id}`, this.x, this.y - this.radius - 8);
        }
        
        // Draw army count for owned territories - ALWAYS show player's own fleet counts
        if (this.ownerId !== null) {
            const player = players[this.ownerId];
            if (player) {
                const humanPlayerId = gameData?.humanPlayer?.id;
                const isPlayerOwned = this.ownerId === humanPlayerId;
                const isInNebula = gameData?.gameMap?.isInNebula?.(this.x, this.y) || false;
                
                // Always show fleet counts for player's own territories, even in nebulas
                if (isPlayerOwned || !isInNebula) {
                    // Show army count normally for player territories or non-nebula territories
                    // Probe flash effect disabled: always use default color
                    const isProbeFlashing = false; // (currentTime - this.probeFlashTime) < this.probeFlashDuration;
                    let textColor = '#000000'; // Default black text
                    // if (isProbeFlashing) { ... } // Skip probe flash color change (always default)
                    
                    ctx.fillStyle = textColor;
                    ctx.strokeStyle = '#ffffff'; // White outline for better readability
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    
                    let displayText = this.armySize.toString();
                    
                    // Add black dot indicator for reinforcing stars
                    if (window.game?.supplySystem?.isSupplySource(this.id)) {
                        displayText = `‚óè ${displayText}`;
                    }
                    
                    ctx.strokeText(displayText, this.x, this.y + 4);
                    ctx.fillText(displayText, this.x, this.y + 4);
                } else {
                    // Enemy territory in nebula - show purple question mark
                    ctx.fillStyle = '#9966ff'; // Purple text for nebula mystery
                    ctx.strokeStyle = 'rgba(153, 102, 255, 0.8)'; // Purple outline
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    
                    const displayText = '?';
                    ctx.strokeText(displayText, this.x, this.y + 4);
                    ctx.fillText(displayText, this.x, this.y + 4);
                }
            }
        }
        
        // Draw floating text (probe-related floating text disabled)
        if (this.floatingText && !this.floatingText.text.includes('-10')) {
            const currentTime = Date.now();
            const elapsed = currentTime - this.floatingText.startTime;
            
            if (elapsed < this.floatingText.duration) {
                const progress = elapsed / this.floatingText.duration;
                const alpha = 1 - progress;
                const yOffset = progress * 30; // Float upward
                
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    this.floatingText.text,
                    this.x,
                    this.floatingText.startY - yOffset
                );
            } else {
                this.floatingText = null; // Remove when done
            }
        }
        
        // Highlight potential targets if this territory is selected
        if (isSelected && this.ownerId !== null) {
            this.renderPotentialTargets(ctx, players);
        }
        
        // Restore alpha for subsequent rendering
        ctx.globalAlpha = 1.0;
        
        ctx.restore();
    }
    
    renderHumanFlag(ctx) {
        // Small flag pole and flag for human territories
        const flagX = this.x + this.radius * 0.6;
        const flagY = this.y - this.radius * 0.8;
        const poleHeight = this.radius * 0.7;
        const flagWidth = this.radius * 0.4;
        const flagHeight = this.radius * 0.25;
        
        // Draw flag pole
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX, flagY + poleHeight);
        ctx.stroke();
        
        // Draw flag
        ctx.fillStyle = '#00ffff';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX + flagWidth, flagY + flagHeight / 2);
        ctx.lineTo(flagX, flagY + flagHeight);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Add small star on flag
        ctx.fillStyle = '#ffffff';
        ctx.font = `${Math.max(8, this.radius * 0.3)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('‚òÖ', flagX + flagWidth * 0.4, flagY + flagHeight * 0.7);
    }
    
    renderCrown(ctx) {
        // Crown positioned above the planet
        const crownX = this.x;
        const crownY = this.y - this.radius - 15;
        const crownSize = Math.max(12, this.radius * 0.8);
        
        ctx.save();
        
        // Crown shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${crownSize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üëë', crownX + 1, crownY + 1);
        
        // Main crown - golden color
        ctx.fillStyle = '#FFD700';
        ctx.font = `bold ${crownSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üëë', crownX, crownY);
        
        ctx.restore();
    }
    
    renderFactoryIcon(ctx) {
        // Factory icon positioned to the right of the planet
        const factoryX = this.x + this.radius + 10;
        const factoryY = this.y;
        const factorySize = Math.max(10, this.radius * 0.6);
        
        ctx.save();
        
        // Factory shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${factorySize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üè≠', factoryX + 1, factoryY + 1);
        
        // Main factory icon - orange/industrial color
        ctx.fillStyle = '#FF8C00';
        ctx.font = `bold ${factorySize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üè≠', factoryX, factoryY);
        
        ctx.restore();
    }
    
    renderExplosion(ctx) {
        const elapsed = Date.now() - this.explosionTime;
        const progress = elapsed / this.explosionDuration;
        
        if (progress >= 1) return; // Animation finished
        
        ctx.save();
        
        // Multiple explosion rings expanding outward
        const maxRadius = this.radius * 3;
        const numRings = 3;
        
        for (let i = 0; i < numRings; i++) {
            const ringProgress = Math.max(0, progress - i * 0.2);
            const radius = ringProgress * maxRadius;
            const opacity = Math.max(0, 1 - ringProgress * 2);
            
            if (radius > 0 && opacity > 0) {
                // Orange/red explosion colors
                const colors = ['#ff4444', '#ff8800', '#ffaa00'];
                ctx.strokeStyle = colors[i % colors.length];
                ctx.globalAlpha = opacity;
                ctx.lineWidth = Math.max(1, 4 - ringProgress * 3);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Central flash effect
        if (progress < 0.3) {
            const flashOpacity = (0.3 - progress) / 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity * 0.8})`;
            ctx.globalAlpha = flashOpacity;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    renderPotentialTargets(ctx, players) {
        // Show attackable neighbors with red outline
        this.neighbors.forEach(neighborId => {
            const neighbor = this.gameMap?.territories[neighborId];
            if (neighbor && neighbor.ownerId !== this.ownerId) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(neighbor.x, neighbor.y, neighbor.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }
    
    adjustColorBrightness(hex, factor) {
        if (hex.startsWith('#')) {
            hex = hex.slice(1);
        }
        
        const num = parseInt(hex, 16);
        const r = Math.min(255, Math.floor((num >> 16) * factor));
        const g = Math.min(255, Math.floor(((num >> 8) & 0x00FF) * factor));
        const b = Math.min(255, Math.floor((num & 0x0000FF) * factor));
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    getDistanceTo(otherTerritory) {
        const dx = this.x - otherTerritory.x;
        const dy = this.y - otherTerritory.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    isNeighborOf(otherTerritory) {
        return this.neighbors.includes(otherTerritory.id);
    }
    
    // Serialize territory data for network transmission (future multiplayer)
    serialize() {
        return {
            id: this.id,
            x: this.x,
            y: this.y,
            radius: this.radius,
            neighbors: this.neighbors,
            ownerId: this.ownerId,
            armySize: this.armySize
        };
    }
    
    // Deserialize territory data from network (future multiplayer)
    static deserialize(data) {
        const territory = new Territory(data.id, data.x, data.y, data.radius);
        territory.neighbors = data.neighbors || [];
        territory.ownerId = data.ownerId;
        territory.armySize = data.armySize || 0;
        return territory;
    }
}


===============================================================================
COMMON/GAMECONSTANTS.TS - GAME CONFIGURATION VALUES
===============================================================================

// This file centralizes all game balance, rendering, and configuration constants.
// It is shared between the client and server to ensure a single source of truth.

export const GAME_CONSTANTS = {
    // Debug Configuration
    DEBUG_MODE: false, // Toggle verbose logging and debug features
    
    // Game Core
    DEFAULT_MAP_WIDTH: 2000,
    DEFAULT_MAP_HEIGHT: 2000,
    DEFAULT_GAME_TIMER_MINUTES: 10,
    MAX_TOTAL_PLAYERS: 100,
    HUMAN_PLAYER_ID_PREFIX: 'human',
    AI_PLAYER_ID_PREFIX: 'ai',

    // Player & AI Defaults
    DEFAULT_SINGLE_PLAYER_AI_COUNT: 19,
    DEFAULT_MULTIPLAYER_AI_COUNT: 90,
    DEFAULT_MAP_SIZE_TERRITORIES: 200,
    INITIAL_COLONIZED_ARMY_SIZE: 1,
    INITIAL_STARTING_ARMY_SIZE: 50,

    // Territory & Map Configuration
    TERRITORY_RADIUS: 25,
    CONNECTION_DISTANCE: 60, // Very short range connections for tactical gameplay
    ARMY_GENERATION_RATE: 1500, // milliseconds per army - faster for more dynamic gameplay

    // Probe System
    PROBE_LAUNCH_COST_FLEET: 10,
    PROBE_COST: 10, // Alias for compatibility
    PROBE_MIN_ARMY_TO_LAUNCH: 11, // Must have more than the cost to launch
    PROBE_UPDATE_INTERVAL_MS: 50,
    PROBE_SPEED_UNITS_PER_UPDATE: 1.25,
    PROBE_SPEED: 25, // Pixels per second

    // Fleet Transfer
    MIN_ARMY_TO_LEAVE_AFTER_TRANSFER: 1,
    TRANSFER_AMOUNT_DIVISOR: 2,

    // Supply Route System
    SUPPLY_ROUTE: {
        TRANSFER_INTERVAL: 3000,        // ms between automatic sends
        DELAY_PER_HOP: 2000,            // animation / delivery latency
        MAX_ROUTES_PER_PLAYER: 20,
        /** How many armies the source keeps back each tick.
         *  0 = ship everything. Raise to 1-2 if you want a token garrison. */
        MIN_GARRISON: 0
    },
    // Legacy constants for backward compatibility
    SUPPLY_ROUTE_MIN_ARMY_DIFFERENCE: 5,  // No longer used but kept for compatibility
    SUPPLY_ROUTE_TRANSFER_DIVISOR: 4,
    SUPPLY_ROUTE_DELAY_PER_HOP_MS: 2000,
    SUPPLY_ROUTE_LINE_WIDTH: 2,
    SUPPLY_ROUTE_ALPHA: 0.8,
    SUPPLY_ROUTE_DASH_PATTERN: [10, 10],
    SUPPLY_ROUTE_COLOR: '#00ffff',

    // Combat
    MIN_ARMY_TO_ATTACK: 2,
    MIN_ATTACK_ARMIES: 2, // Alias for compatibility
    ARMY_LEFT_AFTER_ATTACK: 1,
    ATTACK_POWER_BASE_MULTIPLIER: 0.8,
    ATTACK_POWER_RANDOM_RANGE: 0.4,
    DEFENSE_POWER_BASE_MULTIPLIER: 0.9,
    DEFENSE_POWER_RANDOM_RANGE: 0.2,
    ATTACKER_SURVIVAL_RATE: 0.7,
    DEFENDER_SURVIVAL_RATE: 0.8,
    COMBAT_ATTACKER_MODIFIER: 0.8,
    COMBAT_DEFENDER_MODIFIER: 0.9,

    // Rendering & UI
    BACKGROUND_COLOR: '#000011',
    CONNECTION_LINE_WIDTH: 1,
    CONNECTION_ALPHA: 0.3,
    CONNECTION_COLOR: '#444444',
    OWNED_CONNECTION_LINE_WIDTH: 3,
    OWNED_CONNECTION_ALPHA: 0.6,
    DRAG_PREVIEW_LINE_WIDTH: 2,
    DRAG_PREVIEW_ALPHA: 0.5,
    DRAG_PREVIEW_DASH_PATTERN: [5, 5],
    DRAG_PREVIEW_COLOR: '#ffffff',
    SHIP_ANIMATION_MIN_DURATION_MS: 500,
    SHIP_ANIMATION_SPEED_MS_PER_PX: 2,
    SHIP_ANIMATION_DEFAULT_COLOR: '#ffffff',
    TERRITORY_VISIBILITY_PADDING: 50,

    // Performance Throttling
    FPS_UPDATE_INTERVAL_MS: 1000,
    VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS: 150, // Increased for large maps
    AI_UPDATE_PLAYERS_PER_FRAME_DIVISOR: 4, // More aggressive batching for large maps
    SUPPLY_ROUTE_VALIDATION_FRAME_INTERVAL: 45,
    SUPPLY_ROUTE_PROCESSING_FRAME_INTERVAL: 90,
    
    // LOD Rendering Thresholds
    LOD_STRATEGIC_ZOOM_THRESHOLD: 0.3, // Below this zoom, use strategic rendering
    LOD_TACTICAL_ZOOM_THRESHOLD: 1.5,  // Above this zoom, use tactical rendering
    LOD_MAX_VISIBLE_TERRITORIES: 150,  // Limit rendered territories at any zoom level

    // Input & Controls
    DRAG_THRESHOLD_PIXELS_MOUSE: 5,
    DRAG_THRESHOLD_PIXELS_TOUCH: 10,
    DOUBLE_TAP_THRESHOLD_MS: 300,
    MOUSE_LEFT_BUTTON: 0,
    KEY_RESTART_GAME: ['r', 'R'],
    KEY_TOGGLE_MINIMAP: ['m', 'M'],

    // AI Configuration
    AI_DECISION_INTERVAL_MS: 1000,
    AI_DECISION_INTERVAL_JITTER_MS: 500,
    AI_AGGRESSION_THRESHOLD_TERRITORY_PERCENT: 0.3,
    AI_CONSOLIDATION_THRESHOLD_TERRITORY_COUNT: 5,
    AI_ATTACK_STRENGTH_MULTIPLIER: 1.5,

    // Server Specific
    SERVER_PORT: 5000,
    CORS_ORIGIN: "*",
    CORS_METHODS: ["GET", "POST"],
    ROOM_ID_GENERATION_RADIX: 36,
    ROOM_ID_GENERATION_SUBSTRING_START: 2,
    ROOM_ID_GENERATION_SUBSTRING_END: 8,
    SERVER_TICK_RATE_MS: 1000 / 20, // 20 ticks per second
};

===============================================================================
DEBUGGING SUMMARY AND ANALYSIS
===============================================================================

CRITICAL ISSUES TO INVESTIGATE:

1. NEBULA FOG OF WAR BUG:
   - Line 846 in GameUI.js: isInNebula = gameData?.gameMap?.isInNebula?.(territory.x, territory.y)
   - Line 870-890: Should apply fog of war but isInNebula returning false
   - GameMap.js isInNebula() function appears correct but may not receive proper data
   - Debug shows territory clearly inside purple nebula but tooltip reveals fleet count

2. SUPPLY ROUTE INDICATORS MISSING:
   - Line 327 in Renderer.js calls renderSupplyRouteIndicators() for every territory
   - Line 460-470 has test code to show green '+' on every 3rd human territory
   - renderSupplyRouteIndicators() should work but indicators not appearing
   - May be canvas context issue or human player ID mismatch

DATA FLOW INVESTIGATION NEEDED:
- How gameData.gameMap is passed from StarThrone.js to GameUI.js
- Whether nebula array exists and has correct coordinates
- If human player ID matches territory.ownerId correctly
- Whether canvas rendering context is valid during indicator drawing

EXPECTED DEBUG OUTPUT (not appearing):
üîç NEBULA DEBUG - Territory X: inNebula=true
üß™ TEST: Adding fake supply indicator to territory Y

FIX PRIORITY: Data structure validation and rendering context verification
