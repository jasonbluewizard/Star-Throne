# COMPLETE STAR THRONE CODEBASE - ALL RELEVANT MODULES
# Critical Issues Analysis Document
# Created: January 5, 2025

## CRITICAL ISSUES SUMMARY
1. DOUBLE THRONE STAR BUG (T3 and T79 for same player)
2. DISCOVERY SYSTEM UI NOT DISPLAYING (data exists but UI shows zeros)  
3. 10-SECOND BLACK SCREEN ON STARTUP (performance bottleneck)

## CONSOLE OUTPUT EVIDENCE
- Discovery processing working: 'üî¨ Processing discovery', 'üîç Discovery on conquered planet'
- Discovery data empty: 'üîç DEBUG: Human player discoveries found: {precursorWeapons:0...}'
- No throne validation: Missing 'üïê Running throne star validation' messages
- Unhandled rejection errors preventing proper initialization

===============================================================================
### COMPLETE STARTTHRONE.JS CODE
===============================================================================
import { GameMap } from './GameMap.js';
import { Player } from './Player.js';
import { GameUI } from './GameUI.js';
import { Camera } from './Camera.js';
import { Probe } from './Probe.js';
import { InputHandler } from './InputHandler.js';
import { Renderer } from './Renderer.js';
import { CombatSystem } from './CombatSystem.js';
import { SupplySystem } from './SupplySystem.js';
import { PathfindingService } from './PathfindingService.js';
import { GameUtils } from './utils.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants';
import { gameEvents, GAME_EVENTS, EVENT_PRIORITY, EventHelpers } from './EventSystem.js';
import { PerformanceManager } from './PerformanceManager.js';
import { PerformanceOverlay } from './PerformanceOverlay.js';
import { DiscoverySystem } from './DiscoverySystem.js';
import { AnimationSystem } from './AnimationSystem.js';
import { UIManager } from './UIManager.js';
import { AIManager } from './AIManager.js';
import Controls from './Controls.js';

export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        this.gameInitialized = false; // Prevent early win condition checks
        
        // Persistent star lane discovery system
        this.discoveredLanes = new Set(); // Stores "id1-id2" strings for permanently visible lanes
        
        // Throne star validation timer
        this.throneStarValidationTimer = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        this.pathfindingService = null;
        this.performanceManager = null;
        this.discoverySystem = null;
        this.animationSystem = null;
        this.uiManager = null;
        this.controls = null;
        
        // Legacy properties for backward compatibility
        this.hoveredTerritory = null;
        
        // Performance
        this.lastFrameTime = 0;
        this.fps = 0;
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        
        // Performance optimizations
        this.visibleTerritories = new Set();
        this.lastVisibilityUpdate = 0;
        this.cullingBatchIndex = 0; // For incremental visibility processing
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        this.showPerformancePanel = false; // Toggle with P key
        
        // Ship movement animations
        this.shipAnimations = [];
        this.shipAnimationPool = []; // Reuse objects to reduce garbage collection
        
        // Pre-populate animation pool with multi-hop support
        for (let i = 0; i < 20; i++) {
            this.shipAnimationPool.push({
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            });
        }
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Default minimap to off
        
        // Probe system
        this.probes = [];
        this.nextProbeId = 0;
        
        // Discovery announcements
        this.floatingDiscoveryTexts = [];
        this.discoveryLog = []; // Recent discovery announcements for panel display
        
        // Discovery system - Map of playerId -> discovery object
        this.playerDiscoveries = new Map();
        
        // Legacy drag variables (kept for compatibility)
        this.dragStart = null;
        this.dragEnd = null;
        this.isDraggingForSupplyRoute = false;
        
        // Background image system
        this.backgroundImage = null;
        this.backgroundLoaded = false;
        this.backgroundScale = 1.0;
        
        // Parallax starfield system
        this.starfield = {
            farStars: [],      // Slowest moving, smallest stars
            midStars: [],      // Medium speed, medium stars  
            nearStars: [],     // Fastest moving, larger stars
            initialized: false
        };
        
        // Static background optimization
        this.staticBg = document.createElement('canvas');
        this.staticBgCtx = this.staticBg.getContext('2d');
        
        // Discovery system for planet colonization - per player tracking
        this.playerDiscoveries = new Map(); // Map of playerId -> discoveries
        
        // Initialize event system for decoupled component communication
        this.eventProcessingEnabled = true;
        
        // Global discovery log for all players
        this.discoveryLog = [];
        
        // Recent probe results for UI announcements
        this.recentProbeResults = [];
        
        // Notification system
        this.notifications = [];
        
        // Bonus panel state
        this.showBonusPanel = true;
        
        // Message display system
        this.messageText = '';
        this.messageTimer = 0;
        
        // Performance optimization: Throttled logging system
        this.debugMode = false; // Set to true for development, false for production
        this.logThrottles = new Map(); // Track throttled log messages
        this.lastLogTimes = new Map(); // Track last log timestamp per message type
        
        // DOM optimization: Cache layout measurements
        this.cachedCanvasRect = null;
        this.canvasRectUpdateTime = 0;
        this.canvasRectCacheDuration = 1000; // Cache for 1 second
        
        // Input throttling for performance
        this.lastMouseMoveTime = 0;
        this.mouseMoveThrottleMs = 16; // ~60 FPS, one event per frame
        this.pendingMouseEvent = null;
        
        this.init();
        this.loadBackgroundImage();
    }
    
    /**
     * Performance-optimized logging with throttling
     * @param {string} message - Log message
     * @param {string} type - Log type (info, warn, error)
     * @param {number} throttleMs - Minimum time between identical messages
     */
    log(message, type = 'info', throttleMs = 1000) {
        if (!this.debugMode && type === 'info') return; // Skip info logs in production
        
        const key = `${type}:${message}`;
        const now = Date.now();
        const lastTime = this.lastLogTimes.get(key) || 0;
        
        if (now - lastTime >= throttleMs) {
            this.lastLogTimes.set(key, now);
            if (type === 'error') {
                console.error(message);
            } else if (type === 'warn') {
                console.warn(message);
            } else {
                console.log(message);
            }
        }
    }
    
    /**
     * Get cached canvas bounding rectangle with automatic cache invalidation
     * Prevents expensive getBoundingClientRect() calls on every mouse event
     */
    getCachedCanvasRect() {
        const now = Date.now();
        
        // Return cached rect if still valid
        if (this.cachedCanvasRect && (now - this.canvasRectUpdateTime) < this.canvasRectCacheDuration) {
            return this.cachedCanvasRect;
        }
        
        // Update cache with fresh measurement
        if (this.canvas) {
            this.cachedCanvasRect = this.canvas.getBoundingClientRect();
            this.canvasRectUpdateTime = now;
        }
        
        return this.cachedCanvasRect;
    }
    
    /**
     * Invalidate canvas rect cache on window resize or scroll
     */
    invalidateCanvasRectCache() {
        this.cachedCanvasRect = null;
        this.canvasRectUpdateTime = 0;
    }
    
    /**
     * Throttled mouse event processing - limits to one event per frame
     * @param {MouseEvent} event - Raw mouse event
     * @param {Function} handler - Event handler function
     */
    handleThrottledMouseEvent(event, handler) {
        const now = Date.now();
        
        // Store the latest event for processing
        this.pendingMouseEvent = { event, handler, timestamp: now };
        
        // Only process if enough time has passed (throttle to ~60 FPS)
        if (now - this.lastMouseMoveTime >= this.mouseMoveThrottleMs) {
            this.processPendingMouseEvent();
        }
    }
    
    /**
     * Process the most recent pending mouse event
     */
    processPendingMouseEvent() {
        if (!this.pendingMouseEvent) return;
        
        const { event, handler } = this.pendingMouseEvent;
        this.lastMouseMoveTime = Date.now();
        
        // Get cached canvas rect to avoid expensive DOM measurement
        const rect = this.getCachedCanvasRect();
        if (rect) {
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handler(x, y, event);
        }
        
        this.pendingMouseEvent = null;
    }
    
    loadBackgroundImage() {
        // Load the background galaxy image
        this.backgroundImage = new Image();
        this.backgroundImage.onload = () => {
            this.backgroundLoaded = true;
            console.log('Background galaxy image loaded');
        };
        this.backgroundImage.onerror = () => {
            console.log('Background image failed to load, using default starfield');
            this.backgroundLoaded = false;
        };
        // Set the image path
        this.backgroundImage.src = '/galaxy-background.jpg';
    }
    
    renderBackgroundImage() {
        if (!this.backgroundImage || !this.backgroundLoaded) return;
        
        this.ctx.save();
        
        // Calculate parallax offset (background moves slower than camera)
        const parallaxFactor = 0.2; // Background moves at 20% of camera speed
        const offsetX = -this.camera.x * parallaxFactor;
        const offsetY = -this.camera.y * parallaxFactor;
        
        // Calculate scale to ensure image covers the entire viewport
        const imageAspect = this.backgroundImage.width / this.backgroundImage.height;
        const canvasAspect = this.canvas.width / this.canvas.height;
        
        let drawWidth, drawHeight;
        if (imageAspect > canvasAspect) {
            // Image is wider - fit to height
            drawHeight = this.canvas.height * 1.5; // Scale up for parallax coverage
            drawWidth = drawHeight * imageAspect;
        } else {
            // Image is taller - fit to width
            drawWidth = this.canvas.width * 1.5; // Scale up for parallax coverage
            drawHeight = drawWidth / imageAspect;
        }
        
        // Center the image with parallax offset
        const drawX = (this.canvas.width - drawWidth) / 2 + offsetX;
        const drawY = (this.canvas.height - drawHeight) / 2 + offsetY;
        
        // Draw the background image with very low opacity
        this.ctx.globalAlpha = 0.15; // Even more transparent for very subtle background effect
        this.ctx.drawImage(this.backgroundImage, drawX, drawY, drawWidth, drawHeight);
        
        // Add dark overlay to further dim the background
        this.ctx.globalAlpha = 0.6;
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.globalAlpha = 1.0;
        
        this.ctx.restore();
    }
    
    /**
     * Setup event listeners for event-driven architecture
     */
    setupEventListeners() {
        // Listen for territory capture events to update UI
        gameEvents.on(GAME_EVENTS.TERRITORY_CAPTURED, (event) => {
            this.handleTerritoryCapture(event.data);
        }, EVENT_PRIORITY.HIGH);
        
        // Listen for throne capture events for game ending
        gameEvents.on(GAME_EVENTS.THRONE_CAPTURED, (event) => {
            this.handleThroneCapture(event.data);
        }, EVENT_PRIORITY.CRITICAL);
        
        // Listen for discovery events to update UI
        gameEvents.on(GAME_EVENTS.DISCOVERY_MADE, (event) => {
            this.handleDiscoveryEvent(event.data);
        }, EVENT_PRIORITY.MEDIUM);
        
        // Listen for combat events for animations
        gameEvents.on(GAME_EVENTS.COMBAT_STARTED, (event) => {
            this.handleCombatStart(event.data);
        }, EVENT_PRIORITY.HIGH);
        
        // Process event queue each frame
        this.eventProcessingEnabled = true;
    }
    
    /**
     * Handle territory capture events
     */
    handleTerritoryCapture(data) {
        if (data.player && data.player.id === this.humanPlayer?.id) {
            this.addNotification(`Territory ${data.territory.id} captured!`, '#44ff44');
        }
    }
    
    /**
     * Handle throne capture events
     */
    handleThroneCapture(data) {
        if (data.gameEnded) {
            if (data.attacker.id === this.humanPlayer?.id) {
                this.addNotification(`Victory! You captured ${data.defender.name}'s throne!`, '#ffff44', 8000);
            } else if (data.defender.id === this.humanPlayer?.id) {
                this.addNotification(`Defeat! Your throne was captured by ${data.attacker.name}!`, '#ff4444', 8000);
                this.endGame();
            }
        }
    }
    
    /**
     * Handle discovery events
     */
    handleDiscoveryEvent(data) {
        if (data.player.id === this.humanPlayer?.id) {
            this.addNotification(`Discovery: ${data.discovery.name}`, '#44ffff', 5000);
        }
    }
    
    /**
     * Handle combat start events
     */
    handleCombatStart(data) {
        // Could trigger special effects, sounds, etc.
        if (data.attacker.id === this.humanPlayer?.id || data.defender?.id === this.humanPlayer?.id) {
            // Human player is involved in combat - maybe add special visual effects
        }
    }

    // Add notification to display queue
    addNotification(text, color = '#44ff44', duration = 4000) {
        this.notifications.push({
            text: text,
            color: color,
            createdAt: Date.now(),
            duration: duration,
            opacity: 1.0
        });
    }
    
    // Update and clean up notifications
    updateNotifications() {
        const now = Date.now();
        this.notifications = this.notifications.filter(notification => {
            const age = now - notification.createdAt;
            if (age > notification.duration) {
                return false; // Remove expired notifications
            }
            
            // Fade out in the last 500ms
            if (age > notification.duration - 500) {
                notification.opacity = (notification.duration - age) / 500;
            }
            
            return true;
        });
    }
    
    // Message display system for FSM feedback
    showMessage(text, duration = 3000) {
        this.messageText = text;
        this.messageTimer = duration;
        console.log(`Message: ${text}`);
    }
    
    hideMessage() {
        this.messageText = '';
        this.messageTimer = 0;
    }
    
    showError(text) {
        this.showMessage(`‚ùå ${text}`, 2000);
    }
    
    updateMessage(deltaTime) {
        if (this.messageTimer > 0) {
            this.messageTimer -= deltaTime;
            if (this.messageTimer <= 0) {
                this.hideMessage();
            }
        }
    }
    
    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.gameMap = new GameMap(2000, 1500, this.config); // Large map with advanced configuration
        this.gameMap.game = this; // Reference for AI animations
        
        // Use logical dimensions for camera, not physical canvas dimensions
        const logicalWidth = this.canvas.style.width ? parseInt(this.canvas.style.width) : window.innerWidth;
        const logicalHeight = this.canvas.style.height ? parseInt(this.canvas.style.height) : window.innerHeight;
        this.camera = new Camera(logicalWidth, logicalHeight);
        
        // Update camera map boundaries to match actual expanded map size
        this.camera.mapWidth = this.gameMap.width;
        this.camera.mapHeight = this.gameMap.height;
        
        // Center camera on map and set appropriate zoom
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2); // Center of expanded map
        this.camera.targetZoom = 0.25; // Zoom out further to see more territories
        this.camera.zoom = 0.25;
        
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Initialize modular systems
        this.inputHandler = new InputHandler(this);
        this.renderer = new Renderer(this.canvas, this.camera, this);
        this.combatSystem = new CombatSystem(this);
        this.supplySystem = new SupplySystem(this);
        this.pathfindingService = new PathfindingService(this);
        this.performanceManager = new PerformanceManager(this);
        this.performanceOverlay = new PerformanceOverlay(this.canvas, this.performanceManager);
        this.discoverySystem = new DiscoverySystem(this);
        this.animationSystem = new AnimationSystem(this);
        this.uiManager = new UIManager(this);
        this.aiManager = new AIManager(this);
        this.controls = new Controls(this);
        
        // TODO: Remove global reference (use dependency injection instead)
        // window.game = this;  // (global game reference deprecated)
        window.game = this; // Temporary global access - to be replaced with dependency injection
        
        // Auto-detect optimal performance profile
        this.performanceManager.detectOptimalProfile();
        
        this.gameStartTime = Date.now(); // Track when game actually starts
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            {
                id: 'hostile_aliens',
                name: 'Hostile Aliens',
                description: 'Hostile alien life destroys your probe!',
                probability: 0.15,
                type: 'negative',
                effect: 'probe_lost'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.12,
                type: 'positive',
                effect: 'extra_fleet',
                bonus: 50
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons Cache',
                description: 'Ancient weapon technology discovered!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'attack_bonus',
                bonus: 10 // +10% attack
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'speed_bonus',
                bonus: 20 // +20% speed
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology enhances your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'defense_bonus',
                bonus: 10 // +10% defense
            },
            {
                id: 'precursor_factory',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facility still operational!',
                probability: 0.06,
                type: 'planet_bonus',
                effect: 'factory_planet',
                bonus: 100 // +100% generation (200% total)
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating technology spreads across your empire!',
                probability: 0.05,
                type: 'empire_bonus',
                effect: 'generation_bonus',
                bonus: 10 // +10% empire-wide generation
            },
            {
                id: 'mineral_deposits',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.10,
                type: 'planet_bonus',
                effect: 'mineral_planet',
                bonus: 50 // +50% generation
            },
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                description: 'Mysterious structures provide no immediate benefit.',
                probability: 0.08,
                type: 'neutral',
                effect: 'cosmetic'
            },
            {
                id: 'void_storm',
                name: 'Void Storm Remnants',
                description: 'Dangerous energy storms reduce planet effectiveness.',
                probability: 0.06,
                type: 'negative',
                effect: 'reduced_generation',
                bonus: -25 // -25% generation
            },
            {
                id: 'no_discovery',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.14,
                type: 'neutral',
                effect: 'none'
            }
        ];
    }
    
    // Initialize parallax starfield layers
    initializeStarfield() {
        if (this.starfield.initialized) return;
        
        // Expand starfield area beyond visible map for smooth parallax
        const starfieldWidth = this.gameMap.width * 2;
        const starfieldHeight = this.gameMap.height * 2;
        const offsetX = -this.gameMap.width * 0.5;
        const offsetY = -this.gameMap.height * 0.5;
        
        // Far layer: Many small, dim stars that barely move
        for (let i = 0; i < 300; i++) {
            this.starfield.farStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1 + 0.5,
                brightness: Math.random() * 0.3 + 0.1,
                twinkle: Math.random() * 0.2 + 0.8
            });
        }
        
        // Mid layer: Medium stars with moderate movement
        for (let i = 0; i < 150; i++) {
            this.starfield.midStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1.5 + 1,
                brightness: Math.random() * 0.4 + 0.2,
                twinkle: Math.random() * 0.3 + 0.7
            });
        }
        
        // Near layer: Fewer large stars with most movement
        for (let i = 0; i < 80; i++) {
            this.starfield.nearStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 2 + 1.5,
                brightness: Math.random() * 0.5 + 0.3,
                twinkle: Math.random() * 0.4 + 0.6
            });
        }
        
        this.starfield.initialized = true;
        console.log('Parallax starfield initialized with 530 stars across 3 layers');
    }
    
    // Pre-render static background elements once for performance optimization
    preRenderStaticBackground() {
        // Set static canvas to game map size
        this.staticBg.width = this.gameMap.width;
        this.staticBg.height = this.gameMap.height;
        
        // Clear the static background
        this.staticBgCtx.fillStyle = '#0a0a1a';
        this.staticBgCtx.fillRect(0, 0, this.staticBg.width, this.staticBg.height);
        
        // Render starfield to static background (once only)
        this.renderStarfieldStatic(this.staticBgCtx);
        
        // Render nebulas to static background (once only)
        this.renderNebulasStatic(this.staticBgCtx);
        
        console.log('Static background pre-rendered for performance optimization');
    }
    
    // Render starfield without parallax for static background
    renderStarfieldStatic(ctx) {
        if (!this.starfield.initialized) return;
        
        ctx.save();
        
        // Render all star layers at base positions (no parallax)
        const renderLayer = (stars, baseOpacity) => {
            stars.forEach(star => {
                // Simple twinkling effect for static background
                const twinkle = 0.8; // Static brightness
                const opacity = star.brightness * baseOpacity * twinkle;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        };
        
        // Render all layers
        renderLayer(this.starfield.farStars, 0.7);
        renderLayer(this.starfield.midStars, 0.8);
        renderLayer(this.starfield.nearStars, 1.0);
        
        ctx.restore();
    }
    
    // Render nebulas for static background
    renderNebulasStatic(ctx) {
        if (!this.gameMap.nebulas) return;
        
        this.gameMap.nebulas.forEach(nebula => {
            const gradient = ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Log discovery for UI display (called for both successful and failed probes)
    logDiscoveryForUI(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log for UI display
        this.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`üîç Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Add floating discovery text above the planet
        this.addFloatingDiscoveryText(territory, discovery, playerId);
        
        // Track probe result for UI announcements
        this.recentProbeResults.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discoveryName: discovery.name,
            success: discovery.effect !== 'probe_lost',
            discovery: discovery
        });
        
        // Keep only recent results (last 10)
        if (this.recentProbeResults.length > 10) {
            this.recentProbeResults.shift();
        }
    }
    
    // Process discovery when a planet is successfully colonized - MOVED TO UTILS.JS
    
    addFloatingDiscoveryText(territory, discovery, playerId) {
        // Create floating text object
        const floatingText = {
            x: territory.x,
            y: territory.y - 40, // Start above the planet
            text: discovery.name,
            icon: this.getDiscoveryIcon(discovery.effect),
            color: this.getDiscoveryColor(discovery.effect),
            startTime: Date.now(),
            duration: 4000, // 4 seconds
            fadeOutDuration: 1000, // Last 1 second fades out
            playerId: playerId
        };
        
        this.floatingDiscoveryTexts.push(floatingText);
        
        // Limit to 10 floating texts to prevent clutter
        if (this.floatingDiscoveryTexts.length > 10) {
            this.floatingDiscoveryTexts.shift();
        }
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': 'üíÄ',
            'extra_fleet': 'üëΩ',
            'precursor_weapons': '‚öîÔ∏è',
            'precursor_drive': 'üöÄ',
            'precursor_shield': 'üõ°Ô∏è',
            'precursor_nanotech': 'üî¨',
            'factory_complex': 'üè≠',
            'mineral_deposits': 'üíé',
            'void_storm': '‚ö°',
            'ancient_ruins': 'üèõÔ∏è'
        };
        return icons[effect] || 'üîç';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    updateFloatingDiscoveryTexts(deltaTime) {
        const now = Date.now();
        
        // Update and remove expired floating texts
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            
            if (age > text.duration) {
                return false; // Remove expired text
            }
            
            // Animate the text (float upward)
            text.y -= 20 * (deltaTime / 1000); // Move up 20 pixels per second
            
            return true;
        });
    }
    
    // REMOVED: Second duplicate processDiscovery function - logic moved to GameUtils.js
    
    // Create ship movement animation
    createShipAnimation(fromTerritory, toTerritory, isAttack = false, fleetSize = 0) {
        // Use object pooling to reduce garbage collection
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false,
                fleetSize: 0
            };
        }
        
        const player = this.players[fromTerritory.ownerId];
        const playerColor = player ? player.color : '#ffffff';
        
        // Reset animation properties
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 1000 / this.config.gameSpeed;
        animation.startTime = Date.now();
        animation.isAttack = isAttack;
        animation.playerColor = playerColor;
        animation.id = Math.random();
        animation.path = null;
        animation.currentSegment = 0;
        animation.isMultiHop = false;
        animation.fleetSize = fleetSize;
        
        this.shipAnimations.push(animation);
    }

    // Create multi-hop ship animation following supply route path
    createSupplyRouteAnimation(path, playerColor) {
        if (!path || path.length < 2) return;
        
        let animation = this.shipAnimationPool.pop();
        if (!animation) {
            animation = {
                fromX: 0, fromY: 0, toX: 0, toY: 0,
                progress: 0, duration: 0, startTime: 0,
                isAttack: false, playerColor: '#ffffff', id: 0,
                path: null, currentSegment: 0, isMultiHop: false
            };
        }
        
        // Set up multi-hop animation
        animation.path = path;
        animation.currentSegment = 0;
        animation.isMultiHop = true;
        animation.playerColor = playerColor;
        animation.isAttack = false;
        animation.id = Math.random();
        
        // Start with first segment
        this.initializeAnimationSegment(animation);
        
        this.shipAnimations.push(animation);
    }

    // Initialize animation segment for multi-hop
    initializeAnimationSegment(animation) {
        if (!animation.path || animation.currentSegment >= animation.path.length - 1) {
            return false;
        }
        
        const fromTerritory = animation.path[animation.currentSegment];
        const toTerritory = animation.path[animation.currentSegment + 1];
        
        animation.fromX = fromTerritory.x;
        animation.fromY = fromTerritory.y;
        animation.toX = toTerritory.x;
        animation.toY = toTerritory.y;
        animation.progress = 0;
        animation.duration = 800 / this.config.gameSpeed; // Faster per-segment animation
        animation.startTime = Date.now();
        
        return true;
    }
    
    // Update ship animations
    updateShipAnimations(deltaTime) {
        const currentTime = Date.now();
        
        // Optimize with object pooling and manual iteration
        for (let i = this.shipAnimations.length - 1; i >= 0; i--) {
            const animation = this.shipAnimations[i];
            animation.progress = (currentTime - animation.startTime) / animation.duration;
            
            if (animation.progress >= 1) {
                if (animation.isMultiHop && animation.path) {
                    // Move to next segment in multi-hop animation
                    animation.currentSegment++;
                    
                    if (this.initializeAnimationSegment(animation)) {
                        // Continue to next segment
                        continue;
                    }
                }
                
                // Return completed animation to pool for reuse
                this.shipAnimationPool.push(animation);
                this.shipAnimations.splice(i, 1);
            }
        }
    }
    
    // Update probes
    updateProbes(deltaTime) {
        for (let i = this.probes.length - 1; i >= 0; i--) {
            const probe = this.probes[i];
            const reachedDestination = probe.update(deltaTime);
            
            if (reachedDestination) {
                // Probe reached destination - colonize the planet
                this.colonizePlanet(probe);
                this.probes.splice(i, 1);
            }
        }
    }
    
    // Colonize planet when probe arrives
    colonizePlanet(probe) {
        const planet = probe.toTerritory;
        const player = this.players.find(p => p.id === probe.playerId);
        
        if (!planet || !player) return;
        
        // Check if planet is already colonized by another player
        if (planet.ownerId !== null && planet.ownerId !== player.id) {
            console.log(`Probe from ${player.name} destroyed! Planet ${planet.id} already colonized by another player.`);
            return;
        }
        
        console.log(`Probe colonizing planet ${planet.id} for player ${player.name}`);
        
        // Set ownership - discovery might have already set army size
        planet.ownerId = player.id;
        if (planet.armySize === 0 || planet.armySize === planet.hiddenArmySize) {
            planet.armySize = 1; // Default if not set by discovery
        }
        
        // Mark as no longer colonizable
        planet.isColonizable = false;
        
        // Add to player's territories
        player.territories.push(planet.id);
        
        // Reveal hidden connections
        planet.revealConnections();
        
        // Update neighboring territories' connections
        Object.values(this.gameMap.territories).forEach(territory => {
            if (territory.hiddenNeighbors.includes(planet.id)) {
                territory.hiddenNeighbors = territory.hiddenNeighbors.filter(id => id !== planet.id);
                territory.neighbors.push(planet.id);
            }
        });
        
        // Update player stats
        player.updateStats();
        
        console.log(`Planet ${planet.id} colonized successfully! Discovery: ${discovery.name}`);
    }
    
    // Render ship animations
    renderShipAnimations() {
        this.shipAnimations.forEach(animation => {
            const progress = Math.min(1, animation.progress);
            const eased = this.easeInOutQuad(progress);
            
            const x = animation.fromX + (animation.toX - animation.fromX) * eased;
            const y = animation.fromY + (animation.toY - animation.fromY) * eased;
            
            // Draw ship using player's color
            this.ctx.save();
            this.ctx.fillStyle = animation.playerColor;
            this.ctx.shadowColor = animation.playerColor;
            this.ctx.shadowBlur = 8;
            
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Add trail effect
            const trailLength = 5;
            for (let i = 1; i <= trailLength; i++) {
                const trailProgress = Math.max(0, eased - (i * 0.1));
                const trailX = animation.fromX + (animation.toX - animation.fromX) * trailProgress;
                const trailY = animation.fromY + (animation.toY - animation.fromY) * trailProgress;
                
                this.ctx.globalAlpha = (trailLength - i) / trailLength * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(trailX, trailY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
        });
    }
    
    // Render probes
    renderProbes() {
        this.probes.forEach(probe => {
            probe.render(this.ctx);
        });
    }
    
    renderFloatingDiscoveryTexts() {
        if (this.floatingDiscoveryTexts.length === 0) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        this.floatingDiscoveryTexts.forEach(text => {
            const now = Date.now();
            const age = now - text.startTime;
            const progress = age / text.duration;
            
            // Calculate opacity (fade out in the last 25% of duration)
            let opacity = 1;
            if (progress > 0.75) {
                opacity = 1 - ((progress - 0.75) / 0.25);
            }
            
            // Only render if text is within camera view
            const screenPos = this.camera.worldToScreen(text.x, text.y);
            if (screenPos.x >= -100 && screenPos.x <= this.canvas.width + 100 &&
                screenPos.y >= -100 && screenPos.y <= this.canvas.height + 100) {
                
                // Draw background
                this.ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.8})`;
                const textWidth = this.ctx.measureText(text.text).width;
                this.ctx.fillRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw border
                this.ctx.strokeStyle = text.color;
                this.ctx.globalAlpha = opacity;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(screenPos.x - textWidth/2 - 15, screenPos.y - 15, textWidth + 30, 20);
                
                // Draw icon
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.icon, screenPos.x - textWidth/2 - 5, screenPos.y - 2);
                
                // Draw text
                this.ctx.fillStyle = text.color;
                this.ctx.fillText(text.text, screenPos.x + 10, screenPos.y - 2);
            }
        });
        
        this.ctx.restore();
    }
    
    // Easing function for smooth animation
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    setupCanvas() {
        // Create canvas element
        const canvasElement = document.createElement('canvas');
        canvasElement.id = 'gameCanvas';
        
        // Get device pixel ratio for crisp rendering on high-DPI displays
        const dpr = window.devicePixelRatio || 1;
        const rect = { width: window.innerWidth, height: window.innerHeight };
        
        // Set canvas size with DPI scaling
        canvasElement.width = rect.width * dpr;
        canvasElement.height = rect.height * dpr;
        canvasElement.style.width = rect.width + 'px';
        canvasElement.style.height = rect.height + 'px';
        canvasElement.style.display = 'block';
        canvasElement.style.background = '#1a1a2e';
        canvasElement.style.position = 'fixed';
        canvasElement.style.top = '0';
        canvasElement.style.left = '0';
        canvasElement.style.zIndex = '1';
        
        console.log(`Creating canvas: ${rect.width}x${rect.height} (${canvasElement.width}x${canvasElement.height} with DPR ${dpr})`);
        
        // Append to root without destroying React content
        const root = document.getElementById('root');
        if (root) {
            // Check if canvas already exists
            const existingCanvas = document.getElementById('gameCanvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }
            root.appendChild(canvasElement);
            console.log('Canvas appended to root');
        } else {
            console.error('Root element not found!');
            return;
        }
        
        this.canvas = canvasElement;
        this.ctx = canvasElement.getContext('2d');
        
        if (!this.ctx) {
            console.error('Failed to get 2D context!');
            return;
        }
        
        // Scale context to match device pixel ratio for crisp rendering
        this.ctx.scale(dpr, dpr);
        
        // Store DPI ratio for resize handling
        this.devicePixelRatio = dpr;
        
        console.log('Canvas setup complete');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera) {
                this.camera.updateViewport(this.canvas.width, this.canvas.height);
            }
        });
    }
    
    setupEventListeners() {
        // Safety check to ensure canvas exists
        if (!this.canvas) {
            console.error('Canvas not available for event listeners');
            return;
        }
        
        // Mouse events now handled by InputHandler.js - removed to prevent conflicts
        // Wheel events handled by InputHandler
        
        // Touch events for mobile - with better event handling
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: false });
        
        // Window events for DOM optimization
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('scroll', this.invalidateCanvasRectCache.bind(this));
        
        // Initialize canvas rect cache
        this.getCachedCanvasRect();
        
        // Also add document-level listeners to catch events outside canvas
        document.addEventListener('touchmove', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target === this.canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Enhanced touch state tracking for better pinch-to-zoom
        this.touchStartTime = 0;
        this.touchStartDistance = null;
        this.lastPinchDistance = null;
        this.isMultiTouch = false;
        this.touchDebugInfo = '';
        this.showTouchDebug = true;
        this.leaderboardMinimized = false;
        this.lastZoomTime = 0;
        this.pinchCenter = null;
        this.initialZoom = 1.0;
        
        // Long press functionality
        this.longPressTimer = null;
        this.longPressThreshold = 800; // 800ms for long press
        this.longPressTarget = null;
        this.longPressStartPos = null;
        
        // Keyboard events now handled by InputHandler
        
        // Prevent context menu
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    /**
     * Handle window resize events with DOM cache invalidation
     */
    handleResize() {
        if (!this.canvas) return;
        
        // Get device pixel ratio for crisp rendering on high-DPI displays
        const dpr = this.devicePixelRatio || window.devicePixelRatio || 1;
        const rect = { width: window.innerWidth, height: window.innerHeight };
        
        // Set canvas size with DPI scaling
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        // Re-scale context after resize
        this.ctx.scale(dpr, dpr);
        
        if (this.camera) {
            // Camera uses logical pixels, not physical pixels
            this.camera.updateViewport(rect.width, rect.height);
        }
        
        // Invalidate canvas rect cache after resize
        this.invalidateCanvasRectCache();
        
        console.log(`Resized canvas: ${rect.width}x${rect.height} (${this.canvas.width}x${this.canvas.height} with DPR ${dpr})`);
    }
    
    /**
     * Throttled mouse move handler - called via the throttling system
     * @param {number} x - Canvas-relative X coordinate
     * @param {number} y - Canvas-relative Y coordinate
     * @param {MouseEvent} event - Original mouse event
     */
    handleMouseMoveThrottled(x, y, event) {
        // Update mouse position for other systems
        this.mousePos = { x, y };
        
        // Update hovered territory without expensive DOM operations
        const worldPos = this.camera.screenToWorld(x, y);
        this.updateHoveredTerritory(worldPos.x, worldPos.y);
        
        // Handle camera edge panning for desktop
        if (!this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(x, y, 16); // 16ms frame time approximation
        }
    }
    
    startGame() {
        console.log('Starting Star Throne game with config:', this.config);
        
        // Generate territories using configured map size
        this.gameMap.generateTerritories(this.config.mapSize);
        
        // Build spatial index for O(1) territory lookups (60% performance improvement)
        this.gameMap.buildSpatialIndex();
        this.log('Spatial index built for optimized territory lookups', 'info');
        
        // Create players: 1 human + configured AI count
        const totalPlayers = 1 + this.config.aiCount;
        this.createPlayers(Math.min(totalPlayers, this.maxPlayers));
        
        // Update human player name from config
        if (this.humanPlayer) {
            this.humanPlayer.name = this.config.playerName;
        }
        
        // Distribute initial territories
        this.distributeStartingTerritories();
        
        // Center camera on human player's starting territory
        if (this.humanPlayer && this.humanPlayer.territories.length > 0) {
            const startTerritory = this.gameMap.territories[this.humanPlayer.territories[0]];
            this.camera.centerOn(startTerritory.x, startTerritory.y);
        }
        
        this.gameState = 'playing';
        
        // Initialize modular systems after map generation
        this.animationSystem.initializeStarfield();
        this.animationSystem.preRenderStaticBackground();
        this.uiManager.loadBackgroundImage();
        
        // Start home system flashing for player identification
        this.homeSystemFlashStart = Date.now();
        
        // Mark game as fully initialized to allow win condition checks
        this.gameInitialized = true;
        
        // Run immediate throne star validation to fix any double throne issues
        console.log('üïê Running initial throne star validation...');
        this.validateThroneStars();
        
        console.log(`Game started with ${this.players.length} players (${this.config.playerName} + ${this.config.aiCount} AI) and ${Object.keys(this.gameMap.territories).length} territories`);
    }
    
    generateAIName(index) {
        const firstNames = [
            'Alex', 'Blake', 'Casey', 'Dana', 'Emma', 'Felix', 'Grace', 'Hunter', 'Iris', 'Jack',
            'Kai', 'Luna', 'Max', 'Nova', 'Owen', 'Piper', 'Quinn', 'Riley', 'Sage', 'Tyler',
            'Uma', 'Victor', 'Wade', 'Xara', 'Yuki', 'Zara', 'Ash', 'Beck', 'Cole', 'Drew',
            'Echo', 'Finn', 'Gale', 'Hope', 'Ivan', 'Jade', 'Kane', 'Lexi', 'Mika', 'Nora',
            'Orion', 'Phoenix', 'Raven', 'Storm', 'Tara', 'Vale', 'Wren', 'Zane', 'Aria', 'Brix',
            'Coda', 'Dex', 'Eden', 'Fox', 'Gray', 'Hawk', 'Juno', 'Kira', 'Lux', 'Moss',
            'Neo', 'Oslo', 'Pike', 'Rain', 'Sky', 'Tex', 'Vex', 'Wolf', 'Zed', 'Atlas',
            'Bear', 'Cruz', 'Dash', 'Enzo', 'Flint', 'Ghost', 'Haze', 'Jett', 'Knox', 'Link'
        ];
        
        const clanNames = [
            'StarForge', 'VoidHunters', 'NebulaRise', 'CosmicFury', 'SolarFlare', 'DarkMatter',
            'GalaxyCorp', 'NovaStrike', 'CelestialWar', 'SpaceRaiders', 'StellarWolves', 'OrbitClan',
            'AstroElite', 'CubClan', 'ZenithForce', 'PlasmaBorn', 'StarDust', 'VoidWalkers',
            'QuantumLeap', 'PhotonStorm', 'EtherGuard', 'CosmoKnights', 'StarVeins', 'NebulaCrest',
            'VortexClan', 'AstralFire', 'MeteoRiders', 'IonStorm', 'PulsarWave', 'GravityWell',
            'SolarWind', 'BlackHole', 'RedGiant', 'WhiteDwarf', 'SuperNova', 'Constellation',
            'MilkyWay', 'Andromeda', 'Centauri', 'Proxima', 'Kepler', 'Hubble', 'Armstrong',
            'Gagarin', 'Apollo', 'Artemis', 'Orion', 'Pegasus', 'Phoenix', 'Dragon', 'Falcon'
        ];
        
        const additionalNames = [
            'Admiral Voss', 'Captain Zara', 'Commander Rex', 'Colonel Stone', 'General Mars',
            'Chief Khan', 'Major Swift', 'Lieutenant Nova', 'Sergeant Blade', 'Marshal Iron',
            'Dr. Quantum', 'Professor Void', 'Scientist Echo', 'Engineer Prime', 'Architect Zero',
            'The Shadow', 'The Phoenix', 'The Storm', 'The Hunter', 'The Ghost',
            'Cyber Wolf', 'Steel Eagle', 'Iron Hawk', 'Gold Tiger', 'Silver Fox',
            'Red Baron', 'Blue Devil', 'Green Arrow', 'Black Knight', 'White Falcon',
            'Star Runner', 'Moon Walker', 'Sun Rider', 'Sky Dancer', 'Wind Chaser',
            'Fire Brand', 'Ice Queen', 'Thunder Lord', 'Lightning Strike', 'Storm Bringer'
        ];
        
        // Only 25% chance of clan name, 75% for varied names
        if (index % 4 === 0) {
            // Clan name format
            const firstName = firstNames[index % firstNames.length];
            const clanName = clanNames[Math.floor(index / firstNames.length) % clanNames.length];
            return `[${clanName}] ${firstName}`;
        } else {
            // Varied name format - mix of first names and additional names
            const namePool = [...firstNames, ...additionalNames];
            return namePool[index % namePool.length];
        }
    }

    createPlayers(numPlayers) {
        // Expanded unique color palette - no duplicates
        const baseColors = [
            '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', 
            '#ff8844', '#88ff44', '#4488ff', '#ff4488', '#88ff88', '#8844ff',
            '#ffaa44', '#aaff44', '#44aaff', '#ff44aa', '#aaff88', '#aa44ff',
            '#ff6644', '#66ff44', '#4466ff', '#ff4466', '#66ff88', '#6644ff',
            '#ff9944', '#99ff44', '#4499ff', '#ff4499', '#99ff88', '#9944ff',
            '#ffcc44', '#ccff44', '#44ccff', '#ff44cc', '#ccff88', '#cc44ff',
            '#ff7744', '#77ff44', '#4477ff', '#ff4477', '#77ff88', '#7744ff',
            '#ffdd44', '#ddff44', '#44ddff', '#ff44dd', '#ddff88', '#dd44ff'
        ];
        
        // Create human player with distinctive bright cyan color
        this.humanPlayer = new Player(0, 'You', '#00ffff', 'human');
        this.players.push(this.humanPlayer);
        this.initializePlayerDiscoveries(this.humanPlayer.id);
        
        // Create AI players with unique colors and human-like names
        const usedColors = new Set(['#00ffff']); // Reserve human color
        
        for (let i = 1; i < numPlayers && i < this.maxPlayers; i++) {
            let playerColor;
            let attempts = 0;
            
            // Find a unique color
            do {
                const colorIndex = (i - 1) % baseColors.length;
                playerColor = baseColors[colorIndex];
                
                // If we've used this color, generate a slight variation
                if (usedColors.has(playerColor)) {
                    const variation = Math.floor(attempts / baseColors.length) * 0.1 + 0.1;
                    playerColor = this.adjustColorBrightness(playerColor, variation);
                }
                attempts++;
            } while (usedColors.has(playerColor) && attempts < 100);
            
            usedColors.add(playerColor);
            
            // Generate human-like name with clan designation
            const aiName = AIManager.generateAIName(i - 1);
            const aiPlayer = new Player(i, aiName, playerColor, 'ai');
            this.players.push(aiPlayer);
            this.initializePlayerDiscoveries(aiPlayer.id);
        }
        
        this.currentPlayers = this.players.length;
    }
    
    initializePlayerDiscoveries(playerId) {
        this.playerDiscoveries.set(playerId, {
            // Empire-wide bonuses (levels stack)
            precursorWeapons: 0,    // +10% attack per level
            precursorDrive: 0,      // +20% probe/ship speed per level
            precursorShield: 0,     // +10% defense per level
            precursorNanotech: 0,   // +10% empire-wide generation per level
            
            // Planet-specific bonuses
            factoryPlanets: new Set(), // Planets with 200% generation
            friendlyAliens: 0,      // Count of friendly alien encounters
            richMinerals: 0,        // Count of rich mineral discoveries
            voidStorms: 0,          // Count of void storm discoveries
            ancientRuins: 0,        // Count of ancient ruin discoveries
            hostileAliens: 0        // Count of hostile alien encounters
        });
    }
    
    adjustColorBrightness(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent * 100);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    distributeStartingTerritories() {
        // Since all territories are now colonizable, manually colonize starting territories
        const allTerritories = Object.values(this.gameMap.territories);
        const usedTerritories = [];
        const minDistance = 200; // Minimum distance between starting territories
        
        console.log(`Available territories for distribution: ${allTerritories.length} (all have neutral garrisons)`);
        
        // Give each player exactly one starting territory with spacing
        for (let i = 0; i < this.players.length; i++) {
            const player = this.players[i];
            let bestTerritory = null;
            let bestMinDistance = 0;
            
            // Find territory with maximum distance from all previously assigned territories
            for (const territory of allTerritories) {
                if (usedTerritories.includes(territory.id)) continue;
                
                let minDistanceToUsed = Infinity;
                for (const usedId of usedTerritories) {
                    const usedTerritory = this.gameMap.territories[usedId];
                    const distance = Math.sqrt(
                        (territory.x - usedTerritory.x) ** 2 + 
                        (territory.y - usedTerritory.y) ** 2
                    );
                    minDistanceToUsed = Math.min(minDistanceToUsed, distance);
                }
                
                // If first player or this territory is far enough from others
                if (usedTerritories.length === 0 || minDistanceToUsed > bestMinDistance) {
                    bestTerritory = territory;
                    bestMinDistance = minDistanceToUsed;
                }
            }
            
            if (bestTerritory) {
                // Colonize this territory for the player (defeating the neutral garrison)
                bestTerritory.ownerId = player.id;
                bestTerritory.armySize = GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE;
                bestTerritory.isThronestar = true; // Mark as throne star
                
                console.log(`üè† Starting territory ${bestTerritory.id} for ${player.name}: ${GAME_CONSTANTS.INITIAL_STARTING_ARMY_SIZE} armies`);
                
                // Debug: Track army changes for human player
                if (player.id === 0) { // Human player ID
                    console.log(`üë§ HUMAN PLAYER starting territory ${bestTerritory.id} initialized with ${bestTerritory.armySize} armies`);
                }
                
                player.territories.push(bestTerritory.id);
                player.totalArmies += bestTerritory.armySize;
                player.throneStarId = bestTerritory.id; // Assign throne star ID
                
                usedTerritories.push(bestTerritory.id);
                
                console.log(`üëë Player ${player.name} assigned throne star: Territory ${bestTerritory.id} (distance from others: ${bestMinDistance.toFixed(1)})`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    gameLoop(currentTime = 0) {
        try {
            const frameStart = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            // Update FPS counter
            this.updateFPS(currentTime);
            
            if (this.gameState === 'playing') {
                this.update(deltaTime);
            }
            
            this.render();
            
            // Track overall frame performance
            this.performanceStats.frameTime = performance.now() - frameStart;
        } catch (error) {
            console.error('Game loop error:', error);
            console.error('Error message:', error.message);
            console.error('Error stack:', error.stack);
            console.error('Game state:', this.gameState);
            // Continue running to prevent complete game halt
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    updateFPS(currentTime) {
        this.frameCount++;
        if (currentTime - this.lastFpsUpdate >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
            this.frameCount = 0;
            this.lastFpsUpdate = currentTime;
        }
    }
    
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update game timer
        this.gameTimer -= deltaTime;
        
        if (this.gameTimer <= 0) {
            this.endGame();
            return;
        }
        
        // Always update human player every frame for responsiveness
        const humanPlayer = this.players.find(p => p.type === 'human');
        if (humanPlayer && !humanPlayer.isEliminated) {
            try {
                humanPlayer.update(deltaTime, this.gameMap, this.config.gameSpeed, this);
            } catch (error) {
                console.error(`Error updating human player:`, error);
            }
        }
        
        // Delegate AI updates to AIManager for performance and organization
        if (this.aiManager) {
            this.aiManager.updateAI(deltaTime);
        }
        
        // Process any pending throttled mouse events
        this.processPendingMouseEvent();
        
        // Update ship animations and probes with normal delta time (speed applied internally)
        try {
            this.updateShipAnimations(deltaTime);
            this.updateProbes(deltaTime);
            this.updateFloatingDiscoveryTexts(deltaTime);
        } catch (error) {
            console.error('Error updating animations:', error);
        }
        
        // Update combat system for delayed battles
        if (this.combatSystem) {
            try {
                this.combatSystem.update(deltaTime);
            } catch (error) {
                console.error('Combat system error:', error);
                console.error('Combat system error message:', error.message);
                console.error('Combat system error stack:', error.stack);
            }
        }
        
        // Update modular UI systems
        if (this.uiManager) {
            this.uiManager.update(deltaTime);
        }
        if (this.discoverySystem) {
            this.discoverySystem.updateFloatingDiscoveries();
        }
        if (this.animationSystem) {
            this.animationSystem.update(deltaTime);
        }
        if (this.controls) {
            this.controls.update(deltaTime);
        }
        
        // Process event queue for event-driven architecture
        if (this.eventProcessingEnabled) {
            gameEvents.processQueue(5); // Process up to 5 events per frame
        }
        
        // Update performance management and track frame metrics
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.updateTime = performance.now() - updateStart;
            this.performanceManager.update(deltaTime);
            
            // Trigger memory cleanup if memory usage is high
            if (this.performanceManager.getMemoryUsageMB() > 250) {
                this.performanceManager.triggerMemoryCleanup();
            }
        }
        
        // Throttled heavy operations for better performance - use SupplySystem module
        if (this.frameCount % 45 === 0) { // Every 45 frames (~0.75 seconds)
            this.supplySystem.validateSupplyRoutes();
        }
        // (Removed redundant 90-frame check; supply logic now in Territory.generateArmies())
        
        // Validate throne stars every 5 seconds to fix double throne bugs
        this.throneStarValidationTimer += deltaTime;
        if (this.throneStarValidationTimer >= 5000) {
            console.log('üïê Running throne star validation...');
            this.validateThroneStars();
            this.throneStarValidationTimer = 0;
        }
        
        // Check for player elimination (throttled)
        if (this.frameCount % 20 === 0) {
            this.checkPlayerElimination();
        }
        
        // Check win conditions (throttled) - only after game is properly initialized
        if (this.gameInitialized && this.frameCount % 30 === 0) {
            this.checkWinConditions();
        }
        
        // Update camera with edge panning
        this.camera.update(deltaTime);
        
        // Edge panning when mouse is near screen edges (desktop only)
        if (this.mousePos && !this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(this.mousePos.x, this.mousePos.y, deltaTime);
        }
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    checkPlayerElimination() {
        let playersEliminated = false;
        
        this.players.forEach(player => {
            if (!player.isEliminated && player.territories.length === 0) {
                player.isEliminated = true;
                playersEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player === this.humanPlayer) {
                    console.log('You have been eliminated! Entering spectator mode.');
                    // TODO: Show elimination message and spectator UI
                }
            }
        });
        
        // Invalidate AI player cache if any players were eliminated
        if (playersEliminated && this.aiManager) {
            this.aiManager.invalidatePlayerCache();
        }
    }
    
    checkWinConditions() {
        const alivePlayers = this.players.filter(p => !p.isEliminated);
        
        if (alivePlayers.length === 1) {
            this.endGame(alivePlayers[0]);
        } else if (alivePlayers.length === 0) {
            this.endGame(); // Draw
        }
    }
    
    endGame(winner = null) {
        this.gameState = 'ended';
        
        if (winner) {
            console.log(`Game Over! Winner: ${winner.name}`);
            this.showMessage(`Victory! ${winner.name} has conquered the galaxy!`, 10000);
        } else {
            console.log('Game Over! It\'s a draw.');
            this.showMessage('Game Over! Your empire has fallen.', 10000);
        }
        
        // Stop game loop
        if (this.gameLoopRunning) {
            this.gameLoopRunning = false;
        }
        
        // Show game over message for human player defeat
        if (this.humanPlayer && this.humanPlayer.isEliminated) {
            this.showMessage(`Your throne star has been captured! Your empire has fallen to ${winner?.name || 'your enemies'}.`, 15000);
        }
    }
    
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render parallax starfield behind everything via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render game world with Level of Detail (LOD) optimizations
        const lodLevel = this.getLODLevel();
        
        this.renderNebulas();
        this.renderTerritories();
        
        // Render connections based on LOD level
        if (lodLevel >= 2) {
            this.renderConnections();
        }
        
        // Render supply routes for operational and tactical view
        if (lodLevel >= 2) {
            this.renderSupplyRoutes();
        }
        
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        
        // Ship animations and probes for tactical view
        if (lodLevel >= 2) {
            // Use AnimationSystem for ship animations
            if (this.animationSystem) {
                this.animationSystem.renderShipAnimations(this.ctx, this.camera);
            }
            this.renderProbes();
        }
        
        // Use DiscoverySystem for floating discovery texts
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    /**
     * Get Level of Detail based on camera zoom level
     * Level 1: Strategic view (very zoomed out) - minimal detail
     * Level 2: Operational view (medium zoom) - moderate detail  
     * Level 3: Tactical view (zoomed in) - full detail
     */
    getLODLevel() {
        const zoom = this.camera.zoom;
        if (zoom <= 0.15) return 1; // Strategic view
        if (zoom <= 0.8) return 2;  // Operational view
        return 3; // Tactical view
    }
    
    updateVisibleTerritories() {
        // Enhanced viewport culling with incremental processing for smooth performance
        const now = Date.now();
        const updateInterval = GAME_CONSTANTS.VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS;
        
        // Adaptive interval based on performance - increase on slower devices
        const adaptiveInterval = this.fps < 30 ? updateInterval * 1.5 : updateInterval;
        
        if (now - this.lastVisibilityUpdate < adaptiveInterval) return;
        this.lastVisibilityUpdate = now;
        
        const bounds = this.camera.getViewBounds();
        const margin = GAME_CONSTANTS.TERRITORY_VISIBILITY_PADDING;
        
        // Initialize visibility tracking as Set for O(1) lookups
        if (!this.visibleTerritories || !this.visibleTerritories.has) {
            this.visibleTerritories = new Set();
        }
        
        this.visibleTerritories.clear();
        const territories = Object.values(this.gameMap.territories);
        
        // Incremental processing: split territory checks across multiple frames on large maps
        const batchSize = territories.length > 200 ? Math.ceil(territories.length / 3) : territories.length;
        const startIndex = (this.cullingBatchIndex || 0) % territories.length;
        const endIndex = Math.min(startIndex + batchSize, territories.length);
        
        // Process current batch
        for (let i = startIndex; i < endIndex; i++) {
            const territory = territories[i];
            if (territory.x + territory.radius >= bounds.left - margin &&
                territory.x - territory.radius <= bounds.right + margin &&
                territory.y + territory.radius >= bounds.top - margin &&
                territory.y - territory.radius <= bounds.bottom + margin) {
                this.visibleTerritories.add(territory.id);
            }
        }
        
        // Update batch index for next frame (if processing incrementally)
        if (batchSize < territories.length) {
            this.cullingBatchIndex = endIndex >= territories.length ? 0 : endIndex;
        }
        
        this.performanceStats.visibleTerritories = this.visibleTerritories.size;
    }
    
    // Render parallax starfield with multiple depth layers
    renderParallaxStarfield() {
        if (!this.starfield.initialized) return;
        
        const time = Date.now() * 0.001; // For subtle twinkling
        const cameraPosX = this.camera.x;
        const cameraPosY = this.camera.y;
        
        this.ctx.save();
        
        // Far stars (slowest parallax, barely moves)
        this.ctx.globalAlpha = 0.7; // Brighter for better visibility against background
        this.starfield.farStars.forEach(star => {
            // Very subtle parallax movement (5% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.05);
            const parallaxY = star.y - (cameraPosY * 0.05);
            
            // Skip stars outside visible area for performance
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            // Subtle twinkling effect
            const twinkle = star.twinkle + Math.sin(time * 0.5 + star.x * 0.01) * 0.1;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.7;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Mid stars (moderate parallax)
        this.ctx.globalAlpha = 0.8;
        this.starfield.midStars.forEach(star => {
            // Moderate parallax movement (15% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.15);
            const parallaxY = star.y - (cameraPosY * 0.15);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 0.8 + star.x * 0.02) * 0.15;
            this.ctx.globalAlpha = star.brightness * twinkle * 0.8;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Near stars (most parallax movement)
        this.ctx.globalAlpha = 1.0;
        this.starfield.nearStars.forEach(star => {
            // Stronger parallax movement (30% of camera movement)
            const parallaxX = star.x - (cameraPosX * 0.3);
            const parallaxY = star.y - (cameraPosY * 0.3);
            
            if (!this.camera.isPointVisible(parallaxX, parallaxY, 100)) return;
            
            const twinkle = star.twinkle + Math.sin(time * 1.2 + star.x * 0.03) * 0.2;
            this.ctx.globalAlpha = star.brightness * twinkle * 1.0;
            
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderNebulas() {
        if (!this.gameMap.nebulas) return;
        
        this.ctx.save();
        
        // Render each nebula as a purple cloud
        this.gameMap.nebulas.forEach(nebula => {
            // Create radial gradient for cloud effect
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            
            gradient.addColorStop(0, `rgba(147, 51, 234, ${nebula.opacity})`);
            gradient.addColorStop(0.5, `rgba(147, 51, 234, ${nebula.opacity * 0.6})`);
            gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderTerritories() {
        this.updateVisibleTerritories();
        
        // Get current selected territory from input handler
        const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
        const selectedTerritory = inputState.selectedTerritory;
        
        // Render only visible territories
        for (const territoryId of this.visibleTerritories) {
            const territory = this.gameMap.territories[territoryId];
            if (territory) {
                territory.render(this.ctx, this.players, selectedTerritory, {
                    humanPlayer: this.humanPlayer,
                    homeSystemFlashStart: this.homeSystemFlashStart,
                    homeSystemFlashDuration: this.homeSystemFlashDuration,
                    gameMap: this.gameMap // Include game map for fog of war logic
                }, this.hoveredTerritory);
            }
        }
    }
    
    renderConnections() {
        this.ctx.lineWidth = 4;
        this.ctx.globalAlpha = 0.7;
        
        // Cache connections to avoid duplicate rendering
        const drawnConnections = new Set();
        
        // Use visible territories for optimized rendering
        const territoriesToCheck = this.visibleTerritories && this.visibleTerritories.size > 0 
            ? Array.from(this.visibleTerritories).map(id => this.gameMap.territories[id]).filter(t => t)
            : Object.values(this.gameMap.territories);
        
        territoriesToCheck.forEach(territory => {
            territory.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (!neighbor) return;
                
                // Create unique connection ID (smaller ID first)
                const connectionId = territory.id < neighborId 
                    ? `${territory.id}-${neighborId}` 
                    : `${neighborId}-${territory.id}`;
                
                if (drawnConnections.has(connectionId)) return;
                drawnConnections.add(connectionId);
                
                // FOG OF WAR: Show star lanes if either:
                // 1. At least one end is owned by the human player (current visibility)
                // 2. The lane was previously discovered (permanent knowledge)
                const territoryOwnedByPlayer = territory.ownerId === this.humanPlayer?.id;
                const neighborOwnedByPlayer = neighbor.ownerId === this.humanPlayer?.id;
                const laneDiscovered = this.discoveredLanes.has(connectionId);
                
                if (!territoryOwnedByPlayer && !neighborOwnedByPlayer && !laneDiscovered) {
                    // Neither territory is owned by player AND lane not previously discovered
                    return;
                }
                
                // Add newly visible lanes to permanent discovery
                if ((territoryOwnedByPlayer || neighborOwnedByPlayer) && !laneDiscovered) {
                    this.discoveredLanes.add(connectionId);
                    console.log(`üó∫Ô∏è Star lane discovered: ${territory.id} ‚Üî ${neighborId}`);
                }
                
                // Set color based on ownership
                if (territory.ownerId !== null && 
                    neighbor.ownerId !== null && 
                    territory.ownerId === neighbor.ownerId) {
                    const owner = this.players[territory.ownerId];
                    this.ctx.strokeStyle = owner ? owner.color : '#666677';
                } else {
                    this.ctx.strokeStyle = '#666677';
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            });
        });
        
        this.ctx.globalAlpha = 1;
    }
    
    renderSupplyRoutes() {
        // Delegate to SupplySystem module for rendering
        this.supplySystem.renderSupplyRoutes(this.ctx, this.gameMap.territories);
    }
    
    getTransferPercentage(event) {
        // Default to 50% transfer
        if (!event) return 0.5;
        
        // Modifier key controls for different transfer amounts
        if (event.shiftKey) return 0.95; // Send almost all (leave 1)
        if (event.ctrlKey) return 0.25;  // Send quarter
        return 0.5; // Default 50%
    }
    
    renderDragPreview() {
        // Show drag preview when creating supply route
        if (this.isDraggingForSupplyRoute && this.dragStart) {
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            this.ctx.save();
            
            // Color-coded preview based on target validity
            if (targetTerritory && targetTerritory.ownerId === this.humanPlayer?.id && 
                targetTerritory.id !== this.dragStart.id) {
                this.ctx.strokeStyle = '#00ff00'; // Green for valid supply route target
                this.ctx.lineWidth = 3;
            } else {
                this.ctx.strokeStyle = '#ffff00'; // Yellow for neutral/unknown target
                this.ctx.lineWidth = 2;
            }
            
            this.ctx.globalAlpha = 0.8;
            this.ctx.setLineDash([5, 5]);
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.dragStart.x, this.dragStart.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }
    }
    
    renderProportionalDragUI() {
        if (!this.isProportionalDrag || !this.proportionalDragStart) return;
        
        this.ctx.save();
        
        const territory = this.proportionalDragStart.territory;
        const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        // Draw radial percentage indicator around source territory
        const radius = territory.radius + 15;
        const percentage = this.fleetPercentage;
        
        // Background circle
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 8;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Percentage arc
        const startAngle = -Math.PI / 2;
        const endAngle = startAngle + (percentage * Math.PI * 2);
        
        // Color based on percentage
        let color = '#44ff44'; // Green for low
        if (percentage > 0.7) color = '#ff4444'; // Red for high
        else if (percentage > 0.4) color = '#ffaa00'; // Orange for medium
        
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 6;
        this.ctx.beginPath();
        this.ctx.arc(territory.x, territory.y, radius, startAngle, endAngle);
        this.ctx.stroke();
        
        // Calculate ships to send
        const availableShips = Math.max(0, territory.armySize - 1);
        const shipsToSend = Math.max(1, Math.floor(availableShips * percentage));
        const remaining = territory.armySize - shipsToSend;
        
        // Display text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 2;
        
        // Sending text
        const sendText = `Send: ${shipsToSend}`;
        this.ctx.strokeText(sendText, territory.x, territory.y - 8);
        this.ctx.fillText(sendText, territory.x, territory.y - 8);
        
        // Remaining text
        const remainText = `Keep: ${remaining}`;
        this.ctx.strokeText(remainText, territory.x, territory.y + 8);
        this.ctx.fillText(remainText, territory.x, territory.y + 8);
        
        // Draw drag line to target
        if (targetTerritory) {
            // Color based on action type
            let lineColor = '#666666';
            if (targetTerritory.ownerId === this.humanPlayer?.id) {
                lineColor = '#44ff44'; // Green for transfer
            } else if (targetTerritory.isColonizable) {
                lineColor = '#ffff00'; // Yellow for probe
            } else {
                lineColor = '#ff4444'; // Red for attack
            }
            
            this.ctx.strokeStyle = lineColor;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([8, 4]);
            this.ctx.beginPath();
            this.ctx.moveTo(territory.x, territory.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
        
        this.ctx.restore();
    }
    
    renderTransferPreview() {
        // Show fleet allocation preview when hovering over targets during selection
        if (!this.selectedTerritory || !this.hoveredTerritory || 
            this.selectedTerritory.id === this.hoveredTerritory.id ||
            this.selectedTerritory.ownerId !== this.humanPlayer?.id ||
            this.isProportionalDrag) { // Don't show during proportional drag
            return;
        }
        
        const from = this.selectedTerritory;
        const to = this.hoveredTerritory;
        
        // Only show preview for valid targets (neighbors or colonizable)
        const isValidTarget = from.neighbors.includes(to.id) || to.isColonizable;
        if (!isValidTarget) return;
        
        // Determine transfer percentage based on target type
        let transferPercentage = 0.5; // Default 50%
        if (to.ownerId === this.humanPlayer?.id) {
            transferPercentage = 0.5; // Transfer to own territory
        } else if (to.isColonizable) {
            transferPercentage = Math.min(1.0, 10 / from.armySize); // Probe cost (10 ships or all if less)
        } else {
            transferPercentage = 0.75; // Attack enemy territory
        }
        
        // Calculate amounts
        const availableShips = Math.max(0, from.armySize - 1);
        const shipsToSend = Math.min(availableShips, Math.max(1, Math.floor(from.armySize * transferPercentage)));
        const remaining = from.armySize - shipsToSend;
        
        // Convert to screen coordinates for UI display
        const screenPos = this.camera.worldToScreen(to.x, to.y);
        
        this.ctx.save();
        
        // Background for readability
        const padding = 8;
        const lineHeight = 16;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'left';
        
        const sendText = `Send: ${shipsToSend}`;
        const keepText = `Keep: ${remaining}`;
        const maxWidth = Math.max(this.ctx.measureText(sendText).width, this.ctx.measureText(keepText).width);
        
        const bgX = screenPos.x + 20;
        const bgY = screenPos.y - 25;
        const bgWidth = maxWidth + padding * 2;
        const bgHeight = lineHeight * 2 + padding;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
        
        // Border with action-specific color
        let borderColor = '#ffffff';
        if (to.ownerId === this.humanPlayer?.id) {
            borderColor = '#00ff00'; // Green for transfer
        } else if (to.isColonizable) {
            borderColor = '#ffff00'; // Yellow for probe
        } else {
            borderColor = '#ff4444'; // Red for attack
        }
        
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
        
        // Text
        this.ctx.fillStyle = '#00ff00'; // Green for send
        this.ctx.fillText(sendText, bgX + padding, bgY + lineHeight);
        
        this.ctx.fillStyle = '#ffffff'; // White for keep
        this.ctx.fillText(keepText, bgX + padding, bgY + lineHeight * 2);
        
        this.ctx.restore();
    }
    
    renderFloatingTexts() {
        if (!this.floatingTexts) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        // Update and render floating texts
        const now = Date.now();
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = now - text.startTime;
            if (elapsed >= text.duration) return false;
            
            // Calculate animation progress
            const progress = elapsed / text.duration;
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
            this.ctx.strokeText(text.text, text.x, text.y - yOffset);
            this.ctx.fillText(text.text, text.x, text.y - yOffset);
            
            return true;
        });
        
        this.ctx.restore();
    }
    
    renderArmies() {
        // Dynamic Level of Detail based on camera zoom level
        const zoomLevel = this.camera.getZoomLevel();
        const currentZoom = this.camera.zoom;
        
        // Supply system is now handled by Territory.js render method
        
        this.ctx.save();
        
        // Handle territories: visibleTerritories is a Set of IDs, convert to objects
        let territories;
        if (this.visibleTerritories && this.visibleTerritories.size > 0) {
            territories = Array.from(this.visibleTerritories).map(id => this.gameMap.territories[id]).filter(t => t);
        } else {
            territories = Object.values(this.gameMap.territories);
        }
        
        const playersLookup = {}; // Cache player lookups
        
        // Strategic View (zoomed out) - Show simplified information
        if (zoomLevel === 'strategic') {
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    if (isEnemyMystery) continue;
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner && territory.armySize >= 10) { // Only show significant fleets
                        let armyText = territory.armySize >= 100 ? `${Math.floor(territory.armySize / 10)}0+` : territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // Simplified text rendering for performance
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(armyText, territory.x, territory.y + 3);
                    }
                }
            }
        }
        // Operational View (mid zoom) - Show fleet counts as icons
        else if (zoomLevel === 'operational') {
            this.ctx.font = 'bold 13px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    if (isEnemyMystery) continue;
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        let armyText = territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // White outline for readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 4);
                        
                        // Color-coded text based on owner
                        this.ctx.fillStyle = owner.id === this.humanPlayer?.id ? '#000000' : '#333333';
                        this.ctx.fillText(armyText, territory.x, territory.y + 4);
                    }
                }
            }
        }
        // Tactical View (zoomed in) - Show full detail
        else {
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // FOG OF WAR: Check if this is a mysterious enemy territory
                    const isEnemyMystery = territory.ownerId !== this.humanPlayer?.id && !territory.neighbors.some(neighborId => {
                        const neighbor = this.gameMap.territories[neighborId];
                        return neighbor && neighbor.ownerId === this.humanPlayer?.id;
                    });
                    
                    // Skip army numbers for mysterious enemy territories
                    if (isEnemyMystery) continue;
                    
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        let armyText = territory.armySize.toString();
                        
                        // Add black dot indicator for reinforcing stars
                        if (this.supplySystem?.isSupplySource(territory.id)) {
                            armyText = `‚óè ${armyText}`;
                        }
                        
                        // Debug logging for specific territories
                        if (territory.id === 79) {
                            console.log(`Star 79 tactical view: supplySystem exists: ${!!this.supplySystem}, isSupplySource: ${this.supplySystem?.isSupplySource(territory.id)}, text: "${armyText}"`);
                        }
                        
                        // High-contrast text with thick outline
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 5);
                        
                        // Main black text
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(armyText, territory.x, territory.y + 5);
                    }
                }
            }
        }
        
        this.ctx.restore();
    }
    
    render() {
        const startTime = performance.now();
        
        // Clear canvas with dark space background
        this.ctx.fillStyle = '#0a0a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render background galaxy image with parallax via UIManager (before camera transform)
        if (this.uiManager) {
            this.uiManager.renderBackgroundImage(this.ctx, this.camera);
        }
        
        // Render parallax starfield with movement via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Apply camera transformations for background elements
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render nebulas with proper depth
        this.renderNebulas();
        
        this.ctx.restore();
        
        // Apply camera transformations
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Update performance tracking
        this.updateVisibleTerritories();
        
        // Render connections between territories
        this.renderConnections();
        
        // Render supply routes
        this.renderSupplyRoutes();
        
        // Render territories with fleet counts
        this.renderTerritories();
        
        // Render probes
        this.renderProbes();
        
        // Render ship animations
        this.renderShipAnimations();
        
        // Proportional drag interface handled by InputHandler
        
        // Selection is handled by Territory render method itself
        
        this.ctx.restore();
        
        // Floating discovery texts disabled - using top-center UI notifications instead
        // this.renderFloatingDiscoveryTexts();
        
        // Render UI overlay
        this.renderUI();
        
        // Update and render performance overlay
        if (this.performanceOverlay) {
            this.performanceOverlay.update();
            this.performanceOverlay.render();
        }
        
        // Update performance stats
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.renderTime = performance.now() - startTime;
        }
        this.performanceStats.renderTime = performance.now() - startTime;
    }
    
    renderFloatingDiscoveryTexts() {
        if (!this.floatingDiscoveryTexts || this.floatingDiscoveryTexts.length === 0) return;
        
        const now = Date.now();
        
        // Filter out expired texts and render remaining ones
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const age = now - text.startTime;
            if (age > text.duration) return false; // Remove expired texts
            
            // Only show human player discoveries
            if (text.playerId !== this.humanPlayer?.id) return false;
            
            // Calculate world position (not affected by camera)
            const worldX = text.x;
            const worldY = text.y - (age / text.duration) * 30; // Float upward over time
            
            // Convert to screen coordinates
            const screenX = (worldX - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
            const screenY = (worldY - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
            
            // Only render if on screen
            if (screenX < -100 || screenX > this.canvas.width + 100 || 
                screenY < -100 || screenY > this.canvas.height + 100) {
                return true; // Keep in array but don't render
            }
            
            // Calculate opacity (fade out in last 1 second)
            let opacity = 1;
            if (age > text.duration - text.fadeOutDuration) {
                const fadeAge = age - (text.duration - text.fadeOutDuration);
                opacity = 1 - (fadeAge / text.fadeOutDuration);
            }
            
            // Set up text rendering
            this.ctx.save();
            this.ctx.globalAlpha = opacity;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // Measure text with correct font
            this.ctx.font = 'bold 14px Arial';
            const textWidth = this.ctx.measureText(text.text).width;
            const padding = 8;
            
            // Draw text background for better visibility
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(screenX - textWidth/2 - padding, screenY - 12, textWidth + padding*2, 24);
            
            // Draw discovery icon
            this.ctx.font = '20px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.icon, screenX - textWidth/2 - 15, screenY);
            
            // Draw discovery text
            this.ctx.font = 'bold 14px Arial';
            this.ctx.fillStyle = text.color;
            this.ctx.fillText(text.text, screenX, screenY);
            
            this.ctx.restore();
            
            return true; // Keep in array
        });
    }
    
    renderUI() {
        if (this.ui) {
            const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
            
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: inputState.selectedTerritory,
                hoveredTerritory: this.inputHandler ? this.inputHandler.hoveredTerritory : null,
                mousePos: this.inputHandler ? this.inputHandler.mousePos : { x: 0, y: 0 },
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                probeCount: this.probes.length,
                notifications: this.notifications,
                playerDiscoveries: this.playerDiscoveries,
                recentProbeResults: this.recentProbeResults,
                discoveryLog: this.discoveryLog,
                showBonusPanel: this.showBonusPanel,
                inputState: inputState,
                messageText: this.messageText,
                messageTimer: this.messageTimer,
                combatSystem: this.combatSystem,
                supplySystem: this.supplySystem,
                territories: this.gameMap.territories
            });
        }
        
        // Render UI components via UIManager (notifications, messages)
        if (this.uiManager) {
            this.uiManager.renderNotifications(this.ctx);
            this.uiManager.renderMessage(this.ctx);
        }
    }
    
    // Input handling methods - REMOVED: Mouse handlers moved to InputHandler.js to prevent conflicts
    // All mouse input now processed through InputHandler.js and the finite state machine
    
    updateHoverState(mousePos) {
        const worldPos = this.camera.screenToWorld(mousePos.x, mousePos.y);
        const territory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        this.hoveredTerritory = territory;
        
        // Determine cursor mode based on selection and hover target
        if (this.selectedTerritory && this.selectedTerritory.ownerId === this.humanPlayer?.id && territory) {
            if (territory.ownerId === this.humanPlayer?.id && territory.id !== this.selectedTerritory.id) {
                this.cursorMode = 'transfer';
            } else if (territory.ownerId !== this.humanPlayer?.id && territory.ownerId !== null) {
                this.cursorMode = 'attack';
            } else if (territory.isColonizable) {
                this.cursorMode = 'probe';
            } else {
                this.cursorMode = 'default';
            }
        } else {
            this.cursorMode = 'default';
        }
        
        // Update canvas cursor
        this.updateCanvasCursor();
    }
    
    updateCanvasCursor() {
        if (!this.canvas) return;
        
        switch (this.cursorMode) {
            case 'attack':
                this.canvas.style.cursor = 'crosshair';
                break;
            case 'transfer':
                this.canvas.style.cursor = 'move';
                break;
            case 'probe':
                this.canvas.style.cursor = 'help';
                break;
            default:
                this.canvas.style.cursor = 'default';
                break;
        }
    }
    
    // Enhanced context action with modifier key support
    handleContextActionWithModifiers(targetTerritory) {
        if (!this.selectedTerritory || !targetTerritory) return;
        
        // Determine fleet percentage based on modifier keys
        let fleetPercentage = 0.5; // Default 50%
        
        if (this.modifierKeys.shift) {
            fleetPercentage = 1.0; // Send all available (leave 1)
        } else if (this.modifierKeys.ctrl) {
            fleetPercentage = 0.25; // Send 25% - conservative probe
        }
        
        this.executeFleetCommand(this.selectedTerritory, targetTerritory, fleetPercentage);
    }
    
    // Legacy context action for compatibility
    handleContextAction(targetTerritory) {
        if (!this.selectedTerritory || this.selectedTerritory.ownerId !== this.humanPlayer?.id || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        
        // Validate warp lane connectivity (except for colonizable planets)
        if (!targetTerritory.isColonizable && !fromTerritory.neighbors.includes(targetTerritory.id)) {
            console.log(`Cannot perform action: No warp lane from ${fromTerritory.id} to ${targetTerritory.id}`);
            return;
        }
        
        // Determine action based on target
        if (targetTerritory.ownerId === this.humanPlayer?.id && targetTerritory.id !== fromTerritory.id) {
            // Right-click on friendly territory - transfer
            this.transferArmies(fromTerritory, targetTerritory);
        } else if (targetTerritory.ownerId !== this.humanPlayer?.id && targetTerritory.ownerId !== null) {
            // Right-click on enemy territory - attack
            this.attackTerritory(fromTerritory, targetTerritory);
        } else if (targetTerritory.isColonizable) {
            // Right-click on colonizable territory - launch probe
            this.launchProbe(fromTerritory, targetTerritory);
        }
        
        // Visual feedback - flash the target territory
        targetTerritory.lastActionFlash = Date.now();
    }
    
    // Wheel handling moved to InputHandler
    
    handleUIClick(screenX, screenY) {
        // Handle UI element clicks (moved from old handleTerritorySelection)
        
        // Check for "PLAY AGAIN" button when human player is eliminated
        const humanPlayer = this.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            const buttonWidth = 200;
            const buttonHeight = 60;
            const buttonX = this.canvas.width / 2 - buttonWidth / 2;
            const buttonY = this.canvas.height / 2 + 50;
            
            if (screenX >= buttonX && screenX <= buttonX + buttonWidth &&
                screenY >= buttonY && screenY <= buttonY + buttonHeight) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for restart button on game over screen (mobile-friendly)
        if (this.gameState === 'ended' && this.ui && this.ui.restartButton) {
            const button = this.ui.restartButton;
            
            if (screenX >= button.x && screenX <= button.x + button.width &&
                screenY >= button.y && screenY <= button.y + button.height) {
                this.restartGame();
                return true;
            }
        }
        
        // Check for leaderboard click (screen coordinates, not world coordinates)
        const leaderboardX = this.canvas.width - 220;
        const leaderboardY = 60;
        const leaderboardWidth = 200;
        const leaderboardHeight = this.leaderboardMinimized ? 30 : 200;
        
        if (screenX >= leaderboardX && screenX <= leaderboardX + leaderboardWidth &&
            screenY >= leaderboardY && screenY <= leaderboardY + leaderboardHeight) {
            this.leaderboardMinimized = !this.leaderboardMinimized;
            console.log('Leaderboard toggled:', this.leaderboardMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Check for minimap click - fix coordinate calculation
        const minimapSize = 150;
        const minimapX = this.canvas.width - minimapSize - 20;
        const minimapY = this.canvas.height - minimapSize - 20;
        const minimapHeight = this.minimapMinimized ? 30 : minimapSize;
        const minimapClickY = this.minimapMinimized ? (minimapY + minimapSize - 30) : minimapY;
        
        if (screenX >= minimapX && screenX <= minimapX + minimapSize &&
            screenY >= minimapClickY && screenY <= minimapClickY + minimapHeight) {
            this.minimapMinimized = !this.minimapMinimized;
            console.log('Minimap toggled:', this.minimapMinimized ? 'minimized' : 'maximized');
            return true;
        }
        
        // Zoom controls removed - using mousewheel only
        
        return false; // No UI element was clicked
    }
    
    launchProbe(fromTerritory, toTerritory) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            console.log('Not enough fleet power to launch probe! Need 10 fleet power.');
            return false;
        }
        
        if (!toTerritory.isColonizable) {
            console.log('Target territory is not colonizable!');
            return false;
        }
        
        // Create probe with gameMap and game references for nebula detection and discovery bonuses
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            this.humanPlayer.id,
            this.humanPlayer.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        
        // Emit probe launched event
        gameEvents.emit(GAME_EVENTS.PROBE_LAUNCHED, {
            probe: {
                id: probe.id,
                fromTerritoryId: fromTerritory.id,
                toTerritoryId: toTerritory.id
            },
            player: {
                id: this.humanPlayer.id,
                name: this.humanPlayer.name
            }
        }, EVENT_PRIORITY.MEDIUM);
        
        console.log(`Probe launched from territory ${fromTerritory.id} to colonizable planet ${toTerritory.id}`);
        return true;
    }
    
    launchAIProbe(fromTerritory, toTerritory, player) {
        const probeCost = 10;
        
        if (fromTerritory.armySize < probeCost) {
            return;
        }
        
        // Create AI probe with gameMap and game references for nebula detection
        const probe = new Probe(
            this.nextProbeId++,
            fromTerritory,
            toTerritory,
            player.id,
            player.color,
            this.config.gameSpeed,
            this.gameMap,
            this
        );
        
        this.probes.push(probe);
        fromTerritory.armySize -= probeCost;
        
        // Trigger visual feedback
        fromTerritory.triggerProbeFlash();
        

    }
    
    transferFleet(fromTerritory, toTerritory) {
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Delegate to centralized CombatSystem
        const success = this.combatSystem.transferArmies(fromTerritory, toTerritory);
        
        if (!success) {
            console.log('Transfer failed - not enough armies or invalid target');
        }
    }
    
    // Enhanced fleet transfer with specific amount
    transferFleetWithAmount(fromTerritory, toTerritory, amount) {
        // Create ship animation for transfer
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        // Delegate to centralized CombatSystem with specific amount
        const success = this.combatSystem.transferArmies(fromTerritory, toTerritory, amount);
        
        if (!success) {
            console.log('Transfer failed - not enough armies or invalid target');
        }
    }
    
    // Supply route system - delegate to SupplySystem module
    async createSupplyRoute(fromTerritory, toTerritory) {
        try {
            const result = await this.supplySystem.createSupplyRoute(fromTerritory, toTerritory);
            if (result) {
                console.log(`Supply route created: ${fromTerritory.id} ‚Üí ${toTerritory.id}`);
            }
            return result;
        } catch (error) {
            console.error('Failed to create supply route:', error);
            return false;
        }
    }
    
    findPathBetweenTerritories(start, end) {
        // BFS to find shortest path through owned territories
        const queue = [[start]];
        const visited = new Set([start.id]);
        
        while (queue.length > 0) {
            const path = queue.shift();
            const current = path[path.length - 1];
            
            if (current.id === end.id) {
                return path;
            }
            
            // Check all neighbors
            current.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                
                if (neighbor && 
                    !visited.has(neighbor.id) && 
                    neighbor.ownerId === this.humanPlayer?.id) {
                    
                    visited.add(neighbor.id);
                    queue.push([...path, neighbor]);
                }
            });
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Check all supply routes for broken connections
        const routesToRemove = [];
        
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            // Check if territories still exist and are owned by player
            if (!fromTerritory || !toTerritory || 
                fromTerritory.ownerId !== this.humanPlayer?.id || 
                toTerritory.ownerId !== this.humanPlayer?.id) {
                routesToRemove.push(fromId);
                return;
            }
            
            // Revalidate path every few seconds
            const now = Date.now();
            if (now - route.lastValidation > 5000) {
                const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
                
                if (!newPath) {
                    routesToRemove.push(fromId);
                    console.log(`Supply route broken: ${fromId} ‚Üí ${route.targetId}`);
                } else {
                    // Update path and delay if it changed
                    const delayPerHop = 2000;
                    const newDelay = (newPath.length - 2) * delayPerHop;
                    
                    route.path = newPath;
                    route.delay = newDelay;
                    route.lastValidation = now;
                }
            }
        });
        
        // Remove broken routes
        routesToRemove.forEach(id => {
            this.supplyRoutes.delete(id);
        });
    }
    
    processSupplyRoutes() {
        // Handle automatic ship sending along supply routes
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && fromTerritory.armySize > 2) {
                // Send new ships when they're generated (but not too frequently)
                const now = Date.now();
                if (!route.lastShipment || now - route.lastShipment > 3000) {
                    const shipsToSend = Math.floor(fromTerritory.armySize / 3); // Send 1/3 of armies
                    
                    if (shipsToSend > 0) {
                        fromTerritory.armySize -= shipsToSend;
                        route.lastShipment = now;
                        
                        // Create delayed transfer with route visualization
                        this.createDelayedSupplyTransfer(fromTerritory, toTerritory, shipsToSend, route.delay);
                    }
                }
            }
        });
    }
    
    createDelayedSupplyTransfer(fromTerritory, toTerritory, shipCount, delay) {
        // Find the supply route to get the path
        const route = this.supplyRoutes.get(fromTerritory.id);
        if (route && route.path && route.path.length > 1) {
            // Create multi-hop ship animation following the path
            this.createSupplyRouteAnimation(route.path, this.humanPlayer.color);
        } else {
            // Fallback to direct animation
            this.createShipAnimation(fromTerritory, toTerritory, false);
        }
        
        // Apply transfer after delay
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipCount;
                console.log(`Supply route delivered ${shipCount} ships to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    findTerritoryAt(x, y) {
        // Viewport culling optimization: only check visible territories for hover detection
        if (this.visibleTerritories && this.visibleTerritories.size > 0) {
            for (const territoryId of this.visibleTerritories) {
                const territory = this.gameMap.territories[territoryId];
                if (!territory) continue;
                
                const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                if (distance <= territory.radius) {
                    return territory;
                }
            }
            return null;
        }
        
        // Fallback to spatial indexing if visibility culling not available
        return this.gameMap.findTerritoryAt(x, y);
    }
    
    // Core fleet command execution with percentage control
    executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, commandType = 'auto', path = null) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Calculate ships to send - hardcoded 50% for new system
        const availableShips = Math.max(0, fromTerritory.armySize - 1);
        const shipsToSend = Math.max(1, Math.floor(availableShips * 0.5));
        
        // Visual feedback - show number flying off
        this.showFleetCommandFeedback(fromTerritory, shipsToSend, 0.5);
        
        // Handle different command types
        switch (commandType) {
            case 'multi-hop-transfer':
                if (path && path.length > 1) {
                    this.executeMultiHopTransfer(fromTerritory, toTerritory, shipsToSend, path);
                    console.log(`Multi-hop transfer: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id} via path: ${path.join(' -> ')}`);
                } else {
                    console.error('Multi-hop transfer requires valid path');
                }
                break;
                
            case 'transfer':
                if (toTerritory.ownerId === this.humanPlayer?.id) {
                    this.combatSystem.transferArmies(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, false, shipsToSend);
                    console.log(`Direct transfer: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id}`);
                }
                break;
                
            case 'attack':
                if (toTerritory.ownerId !== this.humanPlayer?.id && !toTerritory.isColonizable) {
                    this.combatSystem.attackTerritory(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, true, shipsToSend);
                    console.log(`Attack: ${shipsToSend} ships from ${fromTerritory.id} to ${toTerritory.id}`);
                }
                break;
                
            case 'auto':
            default:
                // Legacy auto-detection mode
                if (toTerritory.ownerId === this.humanPlayer?.id) {
                    this.combatSystem.transferArmies(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, false, shipsToSend);
                } else if (toTerritory.isColonizable) {
                    this.launchProbe(fromTerritory, toTerritory);
                } else {
                    this.combatSystem.attackTerritory(fromTerritory, toTerritory);
                    this.createShipAnimation(fromTerritory, toTerritory, true, shipsToSend);
                }
                break;
        }
    }
    
    executeMultiHopTransfer(fromTerritory, toTerritory, shipsToSend, path) {
        // Validate path
        if (!path || path.length < 2) {
            console.error('Invalid path for multi-hop transfer');
            return;
        }
        
        // Execute transfer on source territory
        fromTerritory.armySize -= shipsToSend;
        
        // Create multi-hop animation following the path
        this.createSupplyRouteAnimation(path.map(id => this.gameMap.territories[id]), this.humanPlayer.color);
        
        // Calculate delivery delay based on path length (2 seconds per hop)
        const deliveryDelay = (path.length - 1) * 2000;
        
        // Schedule delivery to destination
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipsToSend;
                
                // Add visual feedback
                toTerritory.floatingText = {
                    text: `+${shipsToSend}`,
                    startTime: Date.now(),
                    duration: 2000,
                    startY: toTerritory.y
                };
                
                console.log(`Multi-hop transfer completed: ${shipsToSend} ships delivered to territory ${toTerritory.id}`);
            }
        }, deliveryDelay);
    }
    
    // Visual feedback for fleet commands
    showFleetCommandFeedback(territory, shipsToSend, percentage) {
        // Flash the territory briefly
        territory.lastCombatFlash = Date.now();
        
        // Show floating text with ship count
        const floatingText = {
            x: territory.x + (Math.random() - 0.5) * 40,
            y: territory.y - 20,
            text: `-${shipsToSend}`,
            color: percentage >= 0.8 ? '#ff4444' : percentage >= 0.5 ? '#ffaa00' : '#44ff44',
            startTime: Date.now(),
            duration: 1500
        };
        
        if (!this.floatingTexts) this.floatingTexts = [];
        this.floatingTexts.push(floatingText);
    }
    
    attackTerritory(attackingTerritory, defendingTerritory) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        // Delegate to centralized CombatSystem
        const result = this.combatSystem.attackTerritory(attackingTerritory, defendingTerritory);
        
        if (result.success) {
            console.log(`Territory captured! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            
            if (result.throneCapture) {
                console.log('üëë THRONE STAR CAPTURED!');
            }
            
            if (result.gameEnded) {
                this.endGame();
            }
        } else {
            if (result.reason) {
                console.log(`Attack failed: ${result.reason}`);
            } else {
                console.log(`Attack failed! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Enhanced attack method with custom army amount
    attackTerritoryWithAmount(attackingTerritory, defendingTerritory, attackingArmies) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Create ship animation for attack
        this.createShipAnimation(attackingTerritory, defendingTerritory, true);
        
        // Delegate to centralized CombatSystem with specific army count
        const result = this.combatSystem.attackTerritory(attackingTerritory, defendingTerritory, attackingArmies);
        
        if (result.success) {
            console.log(`Territory captured with custom attack! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            
            if (result.throneCapture) {
                console.log('üëë THRONE STAR CAPTURED!');
            }
            
            if (result.gameEnded) {
                this.endGame();
            }
        } else {
            if (result.reason) {
                console.log(`Custom attack failed: ${result.reason}`);
            } else {
                console.log(`Custom attack failed! Attack: ${result.attackPower.toFixed(1)} vs Defense: ${result.defensePower.toFixed(1)}`);
            }
        }
        
        // Update player stats
        this.players.forEach(player => player.updateStats());
    }
    
    // Touch event handlers for mobile
    handleTouchStart(e) {
        e.preventDefault();
        
        this.touchStartTime = Date.now();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchStart: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch - prepare for selection or pan
            const touch = e.touches[0];
            this.mousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            this.lastMousePos = { ...this.mousePos };
            this.isDragging = false;
            this.isMultiTouch = false;
            
            // Setup long press detection
            this.longPressStartPos = { ...this.mousePos };
            const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
            this.longPressTarget = this.findTerritoryAt(worldPos.x, worldPos.y);
            
            // Clear any existing long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
            }
            
            // Start long press timer
            this.longPressTimer = setTimeout(() => {
                this.handleLongPress();
            }, this.longPressThreshold);
            
            this.touchDebugInfo += `\nSingle: ${Math.round(this.mousePos.x)}, ${Math.round(this.mousePos.y)}`;
            
        } else if (e.touches.length === 2) {
            // Two touches - enhanced pinch zoom and pan
            this.isMultiTouch = true;
            this.isDragging = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Store initial touch positions for pan/zoom
            this.touchStartDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            this.pinchCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            this.lastMousePos = { ...this.pinchCenter };
            this.initialZoom = this.camera.zoom; // Store initial zoom for relative scaling
            this.lastPinchDistance = this.touchStartDistance; // Track for smooth updates
            
            this.touchDebugInfo += `\nPinch Start: dist ${Math.round(this.touchStartDistance)} zoom ${(this.initialZoom * 100).toFixed(0)}%`;
        }
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        
        this.touchDebugInfo = `TouchMove: ${e.touches.length} touches\nTime: ${new Date().toLocaleTimeString()}`;
        
        if (e.touches.length === 1) {
            // Single touch drag - pan
            const touch = e.touches[0];
            const currentPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            this.touchDebugInfo += `\nSingle: ${Math.round(currentPos.x)}, ${Math.round(currentPos.y)}`;
            
            if (this.lastMousePos) {
                const deltaX = currentPos.x - this.lastMousePos.x;
                const deltaY = currentPos.y - this.lastMousePos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Start dragging if moved more than 10 pixels
                if (!this.isDragging && distance > 10) {
                    this.isDragging = true;
                    this.touchDebugInfo += `\nStarted Pan`;
                    
                    // Cancel long press if we start dragging
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                }
                
                if (this.isDragging && !this.isMultiTouch) {
                    this.camera.pan(-deltaX, -deltaY);
                    this.touchDebugInfo += `\nPan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentPos;
            
        } else if (e.touches.length === 2) {
            // Two touches - pinch zoom and pan
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Calculate current distance for zoom
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            // Enhanced pinch-to-zoom with much higher sensitivity
            if (this.lastPinchDistance && Math.abs(currentDistance - this.lastPinchDistance) > 2) {
                // Use incremental scaling with higher sensitivity
                const distanceRatio = currentDistance / this.lastPinchDistance;
                
                // Apply incremental zoom change with dramatic sensitivity
                const zoomMultiplier = 1 + (distanceRatio - 1) * 1.5; // Dramatic scaling for responsive zoom
                const newZoom = Math.max(0.5, Math.min(3.0, this.camera.zoom * zoomMultiplier));
                
                // Calculate zoom center between the two fingers
                const centerX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                const centerY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
                
                // Apply zoom smoothly to the pinch center
                this.camera.zoomTo(newZoom, centerX, centerY);
                this.lastPinchDistance = currentDistance;
                this.lastZoomTime = Date.now();
                
                this.touchDebugInfo += `\nPinch Zoom: ${(newZoom * 100).toFixed(0)}% (dist: ${Math.round(currentDistance)})`;
            }
            
            // Enhanced two-finger pan with smoother movement
            const currentCenter = {
                x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
                y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
            };
            
            if (this.lastMousePos && Date.now() - this.lastZoomTime > 50) {
                const deltaX = currentCenter.x - this.lastMousePos.x;
                const deltaY = currentCenter.y - this.lastMousePos.y;
                
                // Smoother pan threshold for better control
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    this.camera.pan(-deltaX * 0.8, -deltaY * 0.8); // Damped panning
                    this.touchDebugInfo += `\nTwo-finger pan: ${Math.round(deltaX)}, ${Math.round(deltaY)}`;
                }
            }
            
            this.lastMousePos = currentCenter;
        }
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        const touchDuration = Date.now() - this.touchStartTime;
        console.log('Touch end:', e.touches.length, 'remaining touches, duration:', touchDuration);
        
        if (e.touches.length === 0) {
            // All fingers lifted
            if (!this.isDragging && touchDuration < 500 && this.mousePos) {
                // Quick tap - handle territory selection
                const worldPos = this.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
                this.handleTerritorySelection(worldPos);
                console.log('Territory selection at:', worldPos);
            }
            
            this.isDragging = false;
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            this.lastPinchDistance = null;
            this.lastMousePos = null;
            this.pinchCenter = null;
            this.lastZoomTime = 0;
            this.initialZoom = 1.0;
            
            // Cancel long press timer
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            
        } else if (e.touches.length === 1) {
            // One finger lifted during multi-touch - continue with single touch
            this.isMultiTouch = false;
            this.touchStartDistance = null;
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            this.lastMousePos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }
    }
    
    // Keyboard handling is now done by InputHandler module
    
    handleDoubleClick(targetTerritory) {
        // Double-click detected - create supply route between owned territories
        if (!this.selectedTerritory || !targetTerritory) {
            return;
        }
        
        const fromTerritory = this.selectedTerritory;
        const toTerritory = targetTerritory;
        
        // Both territories must be owned by human player
        if (fromTerritory.ownerId !== this.humanPlayer?.id || toTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Must be different territories
        if (fromTerritory.id === toTerritory.id) {
            return;
        }
        
        // Check if connected by owned territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (path && path.length > 0) {
            this.createSupplyRoute(fromTerritory, toTerritory);
            console.log(`Double-click: Supply route created from ${fromTerritory.id} to ${toTerritory.id}`);
        } else {
            console.log('Double-click: Territories not connected by owned star lanes for supply route');
        }
    }
    
    restartGame() {
        // Reset game state
        this.gameState = 'lobby';
        this.gameTimer = 10 * 60 * 1000;
        this.selectedTerritory = null;
        
        // Clear players
        this.players = [];
        this.humanPlayer = null;
        
        // Regenerate map and restart
        this.gameMap = new GameMap(2000, 1500, this.config); // Pass config to maintain connection distances
        this.startGame();
    }
    
    /**
     * Validates throne star assignments and fixes double throne star bugs
     */
    validateThroneStars() {
        // Count throne stars per player
        const playerThroneCount = new Map();
        
        for (const player of this.players) {
            playerThroneCount.set(player.id, 0);
        }
        
        // Count throne stars
        for (const territory of Object.values(this.gameMap.territories)) {
            if (territory.isThronestar && territory.ownerId !== null) {
                const currentCount = playerThroneCount.get(territory.ownerId) || 0;
                playerThroneCount.set(territory.ownerId, currentCount + 1);
            }
        }
        
        // Fix players with multiple throne stars
        for (const [playerId, throneCount] of playerThroneCount.entries()) {
            if (throneCount > 1) {
                const player = this.players.find(p => p.id === playerId);
                console.log(`üîß FIXING: Player ${player ? player.name : playerId} has ${throneCount} throne stars - removing extras`);
                
                // Find all throne stars for this player
                const playerThrones = [];
                for (const territory of Object.values(this.gameMap.territories)) {
                    if (territory.isThronestar && territory.ownerId === playerId) {
                        playerThrones.push(territory);
                    }
                }
                
                // Keep the first throne star, remove the rest
                for (let i = 1; i < playerThrones.length; i++) {
                    playerThrones[i].isThronestar = false;
                    console.log(`üîß Removed throne star flag from territory ${playerThrones[i].id}`);
                }
            }
        }
    }
}


===============================================================================
### COMPLETE DISCOVERYSYSTEM.JS CODE  
===============================================================================
import { GameUtils } from './utils.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants';

export class DiscoverySystem {
    constructor(game) {
        this.game = game;
        this.discoveries = {
            precursorWeapons: 0,
            precursorDrive: 0,
            precursorShield: 0,
            precursorNanotechnology: 0,
            factoryPlanets: [],
            richMinerals: 0,
            voidStorms: 0,
            ancientRuins: 0,
            hostileAliens: 0,
            friendlyAliens: 0
        };
        
        // Floating discovery announcements
        this.floatingDiscoveries = [];
        
        // Recent discovery log for UI panel
        this.recentDiscoveries = [];
    }

    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [

            {
                id: 'standard_planet',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.25,
                type: 'neutral',
                color: '#888888',
                icon: 'üåç'
            },
            {
                id: 'rich_minerals',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.15,
                type: 'positive',
                color: '#ffaa00',
                icon: 'üíé'
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons',
                description: 'Ancient weapon systems enhance your combat effectiveness!',
                probability: 0.10,
                type: 'empire_bonus',
                color: '#ff6666',
                icon: '‚öîÔ∏è'
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.10,
                type: 'empire_bonus',
                color: '#66ccff',
                icon: 'üöÄ'
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology strengthens your empire!',
                probability: 0.10,
                type: 'empire_bonus',
                color: '#66ff66',
                icon: 'üõ°Ô∏è'
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating technology spreads across your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                color: '#cc66ff',
                icon: 'üî¨'
            },
            {
                id: 'factory_complex',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facilities boost production!',
                probability: 0.05,
                type: 'planet_bonus',
                color: '#ffcc00',
                icon: 'üè≠'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.02,
                type: 'positive',
                color: '#00ff88',
                icon: 'üëæ'
            }
        ];
    }

    // Process discovery when conquering neutral territory
    processDiscovery(territory, player) {
        const discoveryTypes = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulativeProbability = 0;
        
        for (const discovery of discoveryTypes) {
            cumulativeProbability += discovery.probability;
            if (random <= cumulativeProbability) {
                return this.applyDiscovery(discovery, territory, player);
            }
        }
        
        // Fallback to standard planet if no discovery triggered
        const standardPlanet = discoveryTypes.find(d => d.id === 'standard_planet');
        return this.applyDiscovery(standardPlanet, territory, player);
    }

    // Apply discovery effects and track for player
    applyDiscovery(discovery, territory, player) {
        // Only track discoveries for human player in UI
        const isHumanPlayer = player.type === 'human';
        
        // Apply discovery effects
        switch (discovery.id) {
            case 'precursor_weapons':
                // Apply effect to all players
                if (isHumanPlayer) {
                    this.discoveries.precursorWeapons++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'precursor_drive':
                if (isHumanPlayer) {
                    this.discoveries.precursorDrive++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'precursor_shield':
                if (isHumanPlayer) {
                    this.discoveries.precursorShield++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'precursor_nanotech':
                if (isHumanPlayer) {
                    this.discoveries.precursorNanotechnology++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'factory_complex':
                territory.armyGenerationRate = GAME_CONSTANTS.ARMY_GENERATION_INTERVAL * 0.5; // 200% generation rate
                territory.hasFactory = true;
                if (isHumanPlayer) {
                    this.discoveries.factoryPlanets.push(territory.id);
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'rich_minerals':
                territory.armyGenerationRate = GAME_CONSTANTS.ARMY_GENERATION_INTERVAL * 0.67; // 150% generation rate
                if (isHumanPlayer) {
                    this.discoveries.richMinerals++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'friendly_aliens':
                territory.armySize += 50; // Instant fleet bonus
                if (isHumanPlayer) {
                    this.discoveries.friendlyAliens++;
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
                
            case 'standard_planet':
                if (isHumanPlayer) {
                    this.addFloatingDiscovery(territory, discovery);
                    this.addRecentDiscovery(discovery);
                }
                break;
        }
        
        return discovery; // Return the discovery object
    }

    // Add floating discovery announcement above territory
    addFloatingDiscovery(territory, discovery) {
        this.floatingDiscoveries.push({
            x: territory.x,
            y: territory.y - 40,
            text: discovery.name,
            icon: discovery.icon,
            color: discovery.color,
            opacity: 1.0,
            createdAt: Date.now(),
            duration: 4000
        });
    }

    // Add to recent discoveries log
    addRecentDiscovery(discovery) {
        this.recentDiscoveries.unshift({
            ...discovery,
            timestamp: Date.now()
        });
        
        // Keep only last 3 discoveries
        if (this.recentDiscoveries.length > 3) {
            this.recentDiscoveries = this.recentDiscoveries.slice(0, 3);
        }
    }

    // Update floating discovery animations
    updateFloatingDiscoveries() {
        const now = Date.now();
        this.floatingDiscoveries = this.floatingDiscoveries.filter(discovery => {
            const age = now - discovery.createdAt;
            if (age > discovery.duration) {
                return false; // Remove expired
            }
            
            // Fade out in last 1000ms
            if (age > discovery.duration - 1000) {
                discovery.opacity = (discovery.duration - age) / 1000;
            }
            
            // Float upward
            discovery.y -= 0.5;
            
            return true;
        });
    }

    // Render floating discovery announcements
    renderFloatingDiscoveries(ctx, camera) {
        for (const discovery of this.floatingDiscoveries) {
            const screenPos = camera.worldToScreen(discovery.x, discovery.y);
            
            if (screenPos.x < -100 || screenPos.x > camera.width + 100 ||
                screenPos.y < -100 || screenPos.y > camera.height + 100) {
                continue; // Skip off-screen discoveries
            }
            
            ctx.save();
            ctx.globalAlpha = discovery.opacity;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Icon
            ctx.font = '20px Arial';
            ctx.fillText(discovery.icon, screenPos.x, screenPos.y - 10);
            
            // Text
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = discovery.color;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeText(discovery.text, screenPos.x, screenPos.y + 10);
            ctx.fillText(discovery.text, screenPos.x, screenPos.y + 10);
            
            ctx.restore();
        }
    }

    // Get discovery bonuses for combat calculations
    getCombatBonuses() {
        return {
            attackBonus: this.discoveries.precursorWeapons * 0.1, // +10% per weapon discovery
            defenseBonus: this.discoveries.precursorShield * 0.1, // +10% per shield discovery
            speedBonus: this.discoveries.precursorDrive * 0.2 // +20% per drive discovery
        };
    }

    // Get army generation bonus
    getArmyGenerationBonus() {
        return this.discoveries.precursorNanotechnology * 0.1; // +10% per nanotech discovery
    }

    // Reset discoveries (for new games)
    reset() {
        this.discoveries = {
            precursorWeapons: 0,
            precursorDrive: 0,
            precursorShield: 0,
            precursorNanotechnology: 0,
            factoryPlanets: [],
            richMinerals: 0,
            voidStorms: 0,
            ancientRuins: 0,
            hostileAliens: 0,
            friendlyAliens: 0
        };
        this.floatingDiscoveries = [];
        this.recentDiscoveries = [];
    }

    // Get discoveries for UI display
    getDiscoveriesForUI() {
        return {
            ...this.discoveries,
            recentDiscoveries: this.recentDiscoveries
        };
    }
}

===============================================================================
### COMPLETE COMBATSYSTEM.JS CODE
===============================================================================
/**
 * Centralized Combat System for Star Throne
 * Handles all battle resolution, army transfers, and throne star mechanics
 * Features delayed combat with coin-flip battles and visual feedback
 */

import { GameUtils } from './utils.js';
import { gameEvents, GAME_EVENTS, EVENT_PRIORITY, EventHelpers } from './EventSystem.js';

export class CombatSystem {
    constructor(game) {
        this.game = game;
        this.pendingBattles = []; // Array of battles waiting for ships to arrive
        this.activeBattles = []; // Array of battles currently in progress
    }

    /**
     * Initiates a delayed attack - ships launch but combat waits until arrival
     * @param {Object} attackingTerritory - Source territory
     * @param {Object} defendingTerritory - Target territory
     * @param {number} armyCount - Number of attacking armies
     * @returns {Object} Attack initiation result
     */
    attackTerritory(attackingTerritory, defendingTerritory, armyCount) {
        // Validate attack
        if (!this.validateAttack(attackingTerritory, defendingTerritory)) {
            return { success: false, reason: 'Invalid attack' };
        }

        // Calculate attacking force - hardcoded 50% of available fleet
        const maxAttackers = Math.max(1, attackingTerritory.armySize - 1);
        const actualAttackers = Math.floor(maxAttackers * 0.5);
        
        // Get player objects
        const attacker = this.game.players[attackingTerritory.ownerId];
        const defender = defendingTerritory.ownerId ? this.game.players[defendingTerritory.ownerId] : null; // Neutral territories have no defender player
        
        console.log(`üéØ ATTACK DEBUG: Territory ${attackingTerritory.id} owned by player ID ${attackingTerritory.ownerId}, player name: ${attacker ? attacker.name : 'NOT FOUND'}`);
        
        if (!attacker) {
            return { success: false, reason: 'Invalid attacker' };
        }
        
        // For neutral territories, defender is null - that's okay

        // Deduct armies from attacking territory immediately
        attackingTerritory.armySize -= actualAttackers;

        // Create pending battle for when ships arrive
        const battle = {
            id: Date.now() + Math.random(), // Unique battle ID
            attackingTerritory: attackingTerritory,
            defendingTerritory: defendingTerritory,
            attackingArmies: actualAttackers,
            attacker: attacker,
            defender: defender,
            arrivalTime: Date.now() + 1000, // Ships arrive in 1 second
            status: 'pending'
        };

        this.pendingBattles.push(battle);
        


        return { 
            success: true, 
            attackingArmies: actualAttackers,
            battleId: battle.id
        };
    }

    /**
     * Updates the combat system, processing pending and active battles
     * @param {number} deltaTime - Time elapsed since last update
     */
    update(deltaTime) {
        const currentTime = Date.now();
        
        // Check for pending battles that should start
        for (let i = this.pendingBattles.length - 1; i >= 0; i--) {
            const battle = this.pendingBattles[i];
            
            if (currentTime >= battle.arrivalTime) {
                // Ships have arrived - start the battle
                this.startBattle(battle);
                this.pendingBattles.splice(i, 1);
            }
        }
        
        // Update active battles
        for (let i = this.activeBattles.length - 1; i >= 0; i--) {
            const battle = this.activeBattles[i];
            
            if (this.updateBattle(battle, currentTime)) {
                // Battle completed
                this.activeBattles.splice(i, 1);
            }
        }
    }

    /**
     * Starts a battle with coin-flip mechanics
     * @param {Object} battle - Battle object
     */
    startBattle(battle) {
        // Calculate combat odds based on discoveries
        const attackerBonus = this.calculateWeaponBonus(battle.attacker);
        const defenderBonus = battle.defender ? this.calculateDefenseBonus(battle.defender) : 0; // Neutral territories have no defense bonus
        
        // Base 50/50 odds adjusted by bonuses
        const attackerWinChance = Math.max(0.1, Math.min(0.9, 0.5 + attackerBonus - defenderBonus));
        
        battle.attackerWinChance = attackerWinChance;
        battle.attackersRemaining = battle.attackingArmies;
        battle.defendersRemaining = battle.defendingTerritory.armySize;
        battle.lastBattleTime = Date.now();
        battle.status = 'active';
        

        
        this.activeBattles.push(battle);
    }

    /**
     * Updates an active battle, processing coin-flip rounds
     * @param {Object} battle - Battle object
     * @param {number} currentTime - Current timestamp
     * @returns {boolean} True if battle is complete
     */
    updateBattle(battle, currentTime) {
        // Check if it's time for the next round (50ms per battle)
        if (currentTime - battle.lastBattleTime < 50) {
            return false;
        }
        
        // Check if battle should end before fighting
        if (battle.attackersRemaining <= 0 || battle.defendersRemaining <= 0) {
            this.completeBattle(battle);
            return true;
        }
        
        // Fight one round
        const attackerWins = Math.random() < battle.attackerWinChance;
        
        if (attackerWins) {
            // Attacker wins this round - defender loses one ship
            battle.defendersRemaining = Math.max(0, battle.defendersRemaining - 1);
            
            // Update the actual territory army count immediately
            battle.defendingTerritory.armySize = Math.max(0, battle.defendersRemaining);
            
            // Flash the defending planet with attacker's color (defender dies)
            this.flashPlanet(battle.defendingTerritory, battle.attacker.color);
            

        } else {
            // Defender wins this round - attacker loses one ship
            battle.attackersRemaining = Math.max(0, battle.attackersRemaining - 1);
            
            // Flash the defending planet with red (attacker dies)
            this.flashPlanet(battle.defendingTerritory, '#ff0000');
            

        }
        
        battle.lastBattleTime = currentTime;
        
        // Check if battle is over after this round
        if (battle.attackersRemaining <= 0 || battle.defendersRemaining <= 0) {
            this.completeBattle(battle);
            return true;
        }
        
        return false;
    }

    /**
     * Completes a battle and applies the results
     * @param {Object} battle - Battle object
     */
    completeBattle(battle) {
        const attackerWins = battle.attackersRemaining > 0 && battle.defendersRemaining <= 0;
        
        if (attackerWins) {
            // Territory captured
            const oldOwner = battle.defender;
            const survivingAttackers = Math.max(1, battle.attackersRemaining);
            const wasNeutral = !oldOwner; // Check if this was a neutral territory
            
            // Check for throne star capture before changing ownership
            const isThroneCapture = battle.defendingTerritory.isThronestar;
            console.log(`üè∞ THRONE CHECK: Territory ${battle.defendingTerritory.id} isThronestar: ${isThroneCapture}, defender: ${oldOwner ? oldOwner.name : 'neutral'}`);
            
            // Transfer territory
            battle.defendingTerritory.ownerId = battle.attackingTerritory.ownerId;
            battle.defendingTerritory.armySize = survivingAttackers;
            
            // Handle throne star capture
            if (isThroneCapture && oldOwner) {
                console.log(`üèÜ THRONE STAR CAPTURED! ${battle.attacker.name} captures throne from ${oldOwner.name}`);
                this.handleThroneStarCapture(battle.attacker, oldOwner, battle.defendingTerritory);
            } else if (isThroneCapture && !oldOwner) {
                console.log(`üè∞ THRONE STAR: Territory ${battle.defendingTerritory.id} is a throne star but was neutral - not triggering capture`);
            }
            
            // DISCOVERY: Trigger discovery when conquering neutral territory
            if (wasNeutral && this.game.discoverySystem) {
                console.log(`üî¨ Processing discovery for ${battle.attacker.name} conquering neutral planet ${battle.defendingTerritory.id}`);
                const discovery = this.game.discoverySystem.processDiscovery(battle.defendingTerritory, battle.attacker);
                if (discovery) {
                    console.log(`üîç Discovery on conquered planet ${battle.defendingTerritory.id}: ${discovery.name}`);
                } else {
                    console.log(`üîç No discovery on conquered planet ${battle.defendingTerritory.id}: Standard planet`);
                }
            }
            
            // Add floating combat text
            battle.defendingTerritory.floatingText = {
                text: `+${survivingAttackers}`,
                startTime: Date.now(),
                duration: 2000,
                startY: battle.defendingTerritory.y
            };
            

        } else {
            // Attack failed - ensure defenders have at least 1 army
            battle.defendingTerritory.armySize = Math.max(1, battle.defendersRemaining);
            
            // Add floating combat text
            battle.defendingTerritory.floatingText = {
                text: `Defended!`,
                startTime: Date.now(),
                duration: 2000,
                startY: battle.defendingTerritory.y
            };
            

        }
    }

    /**
     * Flash a planet with the attacker's color
     * @param {Object} territory - Territory to flash
     * @param {string} color - Color to flash
     */
    flashPlanet(territory, color) {
        territory.combatFlashTime = Date.now();
        territory.combatFlashColor = color;
        territory.combatFlashDuration = 100; // Brief flash
    }

    /**
     * Calculate weapon bonus from discoveries
     * @param {Object} player - Player object
     * @returns {number} Weapon bonus (0.0 to 0.4)
     */
    calculateWeaponBonus(player) {
        if (!player.discoveries || !player.discoveries.weaponTech) {
            return 0;
        }
        
        // Each weapon cache provides +5% attack chance
        return Math.min(0.4, player.discoveries.weaponTech * 0.05);
    }

    /**
     * Calculate defense bonus from discoveries
     * @param {Object} player - Player object
     * @returns {number} Defense bonus (0.0 to 0.4)
     */
    calculateDefenseBonus(player) {
        if (!player.discoveries || !player.discoveries.shieldTech) {
            return 0;
        }
        
        // Each shield matrix provides +5% defense chance
        return Math.min(0.4, player.discoveries.shieldTech * 0.05);
    }

    /**
     * Calculate battle odds for tooltip display
     * @param {Object} attacker - Attacking player
     * @param {Object} defender - Defending player
     * @returns {number} Win chance percentage (0-100)
     */
    calculateBattleOdds(attacker, defender) {
        const attackerBonus = this.calculateWeaponBonus(attacker);
        const defenderBonus = defender ? this.calculateDefenseBonus(defender) : 0; // Handle neutral territories
        
        // Base 50/50 odds adjusted by bonuses
        const attackerWinChance = Math.max(0.1, Math.min(0.9, 0.5 + attackerBonus - defenderBonus));
        
        return Math.round(attackerWinChance * 100);
    }

    /**
     * Validates if an attack is legal
     */
    validateAttack(attackingTerritory, defendingTerritory) {
        // Must have different owners
        if (attackingTerritory.ownerId === defendingTerritory.ownerId) {
            return false;
        }
        
        // Attacking territory must have more than 1 army
        if (attackingTerritory.armySize <= 1) {
            return false;
        }
        
        // Territories must be connected
        if (!attackingTerritory.neighbors.includes(defendingTerritory.id)) {
            return false;
        }
        
        return true;
    }

    /**
     * Resolves combat calculations with discovery bonuses
     */
    resolveCombat(attackingArmies, defendingArmies, attacker, defender) {
        // Get discovery bonuses
        const attackerDiscoveries = this.game.playerDiscoveries?.get(attacker.id) || {};
        const defenderDiscoveries = defender ? (this.game.playerDiscoveries?.get(defender.id) || {}) : {}; // Handle neutral territories
        
        // Calculate attack power with bonuses
        let attackBonus = 1.0;
        if (attackerDiscoveries.precursorWeapons > 0) {
            attackBonus += attackerDiscoveries.precursorWeapons * 0.1; // +10% per level
        }
        
        let attackPower = attackingArmies * (0.8 + Math.random() * 0.4) * attackBonus;
        
        // Calculate defense power with bonuses
        let defenseBonus = 1.0;
        if (defenderDiscoveries.precursorShield > 0) {
            defenseBonus += defenderDiscoveries.precursorShield * 0.1; // +10% per level
        }
        
        let defensePower = defendingArmies * (1.0 + Math.random() * 0.2) * defenseBonus;
        
        // Calculate casualties
        const attackerLosses = Math.floor(attackingArmies * (0.2 + Math.random() * 0.3));
        const defenderLosses = Math.floor(defendingArmies * (0.3 + Math.random() * 0.4));
        
        return {
            attackPower,
            defensePower,
            attackerLosses,
            defenderLosses
        };
    }

    /**
     * Handles throne star capture mechanics
     * @param {Object} attacker - Player who captured the throne
     * @param {Object} oldOwner - Player who lost the throne
     * @param {Object} throneTerritory - The throne star territory
     * @returns {boolean} True if game ended
     */
    handleThroneStarCapture(attacker, oldOwner, throneTerritory) {
        console.log(`üèÜ THRONE STAR CAPTURED! ${attacker.name} captures throne from ${oldOwner.name}`);
        
        // Transfer all territories from old owner to attacker
        const transferredTerritories = [];
        
        for (let territory of Object.values(this.game.gameMap.territories)) {
            if (territory.ownerId === oldOwner.id && territory.id !== throneTerritory.id) {
                territory.ownerId = attacker.id;
                transferredTerritories.push(territory);
            }
        }
        
        console.log(`Transferred ${transferredTerritories.length} territories to ${attacker.name}`);
        
        // Mark old owner as eliminated
        oldOwner.isEliminated = true;
        
        // Invalidate AI player cache since a player was eliminated
        if (this.game.aiManager) {
            this.game.aiManager.invalidatePlayerCache();
        }
        
        // Destroy the captured throne star (prevent multiple thrones in one empire)
        console.log(`üî• Destroying captured throne star ${throneTerritory.id} to prevent multiple thrones`);
        throneTerritory.isThronestar = false;
        
        // Add dramatic floating text
        const floatingText = {
            x: throneTerritory.x,
            y: throneTerritory.y - 30,
            text: 'THRONE CAPTURED!',
            color: '#FFD700',
            startTime: Date.now(),
            duration: 5000
        };
        
        if (!this.game.floatingTexts) this.game.floatingTexts = [];
        this.game.floatingTexts.push(floatingText);
        
        // Check if this was a human player
        if (oldOwner.type === 'human') {
            console.log(`Human player ${oldOwner.name} eliminated! Game ending...`);
            // Set the attacker as winner when human player's throne is captured
            this.game.endGame(attacker);
            return true; // Game should end
        }
        
        // Check overall win conditions
        return this.game.checkWinConditions();
    }

    /**
     * Transfers armies between friendly territories (hardcoded 50% of fleet)
     * @param {Object} fromTerritory - Source territory
     * @param {Object} toTerritory - Destination territory
     * @returns {boolean} Success status
     */
    transferArmies(fromTerritory, toTerritory) {
        // Validate transfer
        if (fromTerritory.ownerId !== toTerritory.ownerId) {
            return false;
        }
        
        if (fromTerritory.armySize <= 1) {
            return false;
        }
        
        // Calculate transfer amount - hardcoded 50% of available fleet
        const maxTransfer = fromTerritory.armySize - 1;
        const actualTransfer = Math.floor(maxTransfer * 0.5);
        
        if (actualTransfer <= 0) {
            return false;
        }
        
        // Execute transfer
        fromTerritory.armySize -= actualTransfer;
        toTerritory.armySize += actualTransfer;
        
        // Add visual feedback using territory floating text system
        toTerritory.floatingText = {
            text: `+${actualTransfer}`,
            startTime: Date.now(),
            duration: 2000,
            startY: toTerritory.y
        };
        
        console.log(`Transferred ${actualTransfer} armies (50%) from territory ${fromTerritory.id} to ${toTerritory.id}`);
        return true;
    }
}

===============================================================================
### COMPLETE GAMEUI.JS CODE (Discovery Panel Rendering)
===============================================================================
export class GameUI {
    constructor(canvas, camera) {
        this.canvas = canvas;
        this.camera = camera;
        
        // UI state
        this.showLeaderboard = true;
        this.showMinimap = true;
        this.showStats = true;
        this.showHelp = false;
        
        // Animation
        this.animationPhase = 0;
        
        // Colors with better contrast
        this.bgColor = 'rgba(0, 0, 0, 0.85)';
        this.textColor = '#ffffff';
        this.accentColor = '#00ddff';
        this.warningColor = '#ff4444';
        this.successColor = '#44ff44';
        this.shadowColor = 'rgba(0, 0, 0, 0.8)';
    }

    // Helper function to render text with shadow for better readability
    renderTextWithShadow(ctx, text, x, y, fillColor = this.textColor, shadowOffset = 2) {
        // Draw shadow
        ctx.fillStyle = this.shadowColor;
        ctx.fillText(text, x + shadowOffset, y + shadowOffset);
        
        // Draw main text
        ctx.fillStyle = fillColor;
        ctx.fillText(text, x, y);
    }
    
    // Method for FSM to update UI state
    setInputState(state, data = {}) {
        this.inputState = state;
        this.inputStateData = data;
        
        // Update cursor based on FSM state
        if (this.canvas) {
            const cursorModes = {
                'Default': 'default',
                'TerritorySelected': 'pointer',
                'ProbeTargeting': 'crosshair',
                'EnemySelected': 'help'
            };
            this.canvas.style.cursor = cursorModes[state] || 'default';
        }
    }
    
    render(ctx, gameData) {
        this.animationPhase += 0.02;
        
        // Render different UI elements based on game state
        switch (gameData.gameState) {
            case 'lobby':
                this.renderLobbyUI(ctx, gameData);
                break;
            case 'playing':
                this.renderGameUI(ctx, gameData);
                break;
            case 'ended':
                this.renderEndGameUI(ctx, gameData);
                break;
        }
    }
    
    renderLobbyUI(ctx, gameData) {
        // Title screen
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Star Throne', this.canvas.width / 2, this.canvas.height / 2 - 100);
        
        ctx.font = '24px Arial';
        ctx.fillText('Massive Multiplayer Strategy Game', this.canvas.width / 2, this.canvas.height / 2 - 50);
        
        ctx.font = '18px Arial';
        ctx.fillText('Click anywhere to start', this.canvas.width / 2, this.canvas.height / 2 + 50);
        
        // Animated dots
        const dots = '...'.substring(0, Math.floor(this.animationPhase * 3) % 4);
        ctx.fillText(`Loading${dots}`, this.canvas.width / 2, this.canvas.height / 2 + 100);
    }
    
    renderGameUI(ctx, gameData) {
        // Top bar with timer and game info
        this.renderTopBar(ctx, gameData);
        
        // Leaderboard
        if (this.showLeaderboard) {
            this.renderLeaderboard(ctx, gameData);
        }
        
        // All UI panels removed for minimal clean interface
        
        // Minimap (minimizable)
        if (this.showMinimap) {
            this.renderMinimap(ctx, gameData);
        }
        
        // Discovery panel showing empire bonuses
        this.renderDiscoveryPanel(ctx, gameData);
        
        // Performance panel (togglable with P key)
        this.renderPerformanceInfo(ctx, gameData);
        
        // Zoom controls removed - using mousewheel only
        
        // Tooltip for hovered territory
        this.renderTooltip(ctx, gameData);
        
        // Render notifications
        this.renderNotifications(ctx, gameData);
        
        // Floating discovery announcements at top center
        this.renderFloatingAnnouncements(ctx, gameData);
        
        // Game over screen for human player
        const humanPlayer = gameData.humanPlayer;
        if (humanPlayer && humanPlayer.territories.length === 0) {
            this.renderGameOverScreen(ctx, gameData);
        }
    }
    
    renderEndGameUI(ctx, gameData) {
        // Full opaque overlay for maximum readability
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title with dramatic shadow effect
        ctx.font = 'bold 64px Arial';
        ctx.textAlign = 'center';
        
        // Title shadow
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.fillText('Game Over!', this.canvas.width / 2 + 4, this.canvas.height / 2 - 146);
        
        // Main title
        ctx.fillStyle = '#ffffff';
        ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 150);
        
        // Final leaderboard
        this.renderFinalLeaderboard(ctx, gameData);
        
        // Larger, more prominent restart button
        const buttonWidth = 280;
        const buttonHeight = 60;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height - 120;
        
        // Button shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(buttonX + 4, buttonY + 4, buttonWidth, buttonHeight);
        
        // Restart button background
        ctx.fillStyle = '#00ddff';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border with glow effect
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Inner glow
        ctx.strokeStyle = '#00ddff';
        ctx.lineWidth = 1;
        ctx.strokeRect(buttonX + 2, buttonY + 2, buttonWidth - 4, buttonHeight - 4);
        
        // Button text with shadow
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        
        // Text shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText('PLAY AGAIN', this.canvas.width / 2 + 2, buttonY + 40);
        
        // Main text
        ctx.fillStyle = '#000000';
        ctx.fillText('PLAY AGAIN', this.canvas.width / 2, buttonY + 38);
        
        // Store button area for touch detection
        this.restartButton = {
            x: buttonX,
            y: buttonY,
            width: buttonWidth,
            height: buttonHeight
        };
    }
    
    renderTopBar(ctx, gameData) {
        const barHeight = 60;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(0, 0, this.canvas.width, barHeight);
        
        // Timer
        const timeLeft = Math.max(0, gameData.gameTimer);
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        ctx.fillStyle = timeLeft < 60000 ? this.warningColor : this.textColor;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(timeString, this.canvas.width / 2, 35);
        
        // Player count
        ctx.fillStyle = this.textColor;
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Players: ${gameData.currentPlayers}/${gameData.maxPlayers}`, 20, 25);
        
        // Game title
        ctx.textAlign = 'left';
        ctx.fillText('Star Throne', 20, 45);
        
        // Camera info
        ctx.textAlign = 'right';
        const zoom = (this.camera.zoom * 100).toFixed(0);
        ctx.fillText(`Zoom: ${zoom}%`, this.canvas.width - 20, 25);
    }
    
    renderLeaderboard(ctx, gameData) {
        const startX = this.canvas.width - 250;
        const startY = 80;
        const width = 230;
        const itemHeight = 25;
        
        if (gameData.leaderboardMinimized) {
            // Minimized leaderboard - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY, width, 35);
            
            ctx.fillStyle = this.accentColor;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Leaderboard (tap to expand)', startX + width / 2, startY + 22);
            
            // Add minimize indicator
            ctx.fillStyle = this.textColor;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('‚ñº', startX + width - 10, startY + 22);
            return;
        }
        
        // Sort players by score
        const sortedPlayers = gameData.players
            .filter(p => !p.isEliminated)
            .sort((a, b) => b.score - a.score)
            .slice(0, 10); // Top 10
        
        const height = 40 + sortedPlayers.length * itemHeight;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title with minimize indicator
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Leaderboard', startX + width / 2, startY + 20, this.accentColor);
        
        // Add minimize indicator
        ctx.font = '16px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '‚ñ≤', startX + width - 10, startY + 20, this.textColor);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 40 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            
            // Rank
            ctx.fillStyle = this.textColor;
            ctx.font = isHuman ? 'bold 14px Arial' : '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${index + 1}.`, startX + 10, y);
            
            // Player color indicator
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 35, y - 8, 12, 12);
            
            // Player name
            ctx.fillStyle = isHuman ? this.accentColor : this.textColor;
            ctx.textAlign = 'left';
            const name = player.name.length > 10 ? player.name.substring(0, 10) + '...' : player.name;
            ctx.fillText(name, startX + 55, y);
            
            // Territory count
            ctx.fillStyle = this.textColor;
            ctx.textAlign = 'right';
            ctx.fillText(player.territories.length.toString(), startX + width - 10, y);
        });
        
        // Eliminated count
        const eliminatedCount = gameData.players.filter(p => p.isEliminated).length;
        if (eliminatedCount > 0) {
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${eliminatedCount} eliminated`, startX + width / 2, startY + height + 15);
        }
    }
    
    renderTerritoryInfo(ctx, gameData) {
        const territory = gameData.selectedTerritory;
        const startX = 20;
        const startY = this.canvas.height - 150;
        const width = 200;
        const height = 120;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Territory ${territory.id}`, startX + 10, startY + 20);
        
        // Owner info
        if (territory.ownerId !== null) {
            const owner = gameData.players[territory.ownerId];
            if (owner) {
                ctx.fillStyle = owner.color;
                ctx.fillRect(startX + 10, startY + 30, 12, 12);
                
                ctx.fillStyle = this.textColor;
                ctx.font = '14px Arial';
                ctx.fillText(`Owner: ${owner.name}`, startX + 30, startY + 40);
            }
        } else {
            ctx.fillStyle = this.textColor;
            ctx.font = '14px Arial';
            ctx.fillText('Neutral Territory', startX + 10, startY + 40);
        }
        
        // Army count
        ctx.fillText(`Armies: ${territory.armySize}`, startX + 10, startY + 60);
        
        // Neighbors
        ctx.font = '12px Arial';
        ctx.fillText(`Neighbors: ${territory.neighbors.length}`, startX + 10, startY + 80);
        
        // Action hint
        if (territory.ownerId === gameData.humanPlayer.id) {
            ctx.fillStyle = this.successColor;
            ctx.fillText('Click neighbor to attack', startX + 10, startY + 100);
        } else if (gameData.selectedTerritory && 
                   gameData.selectedTerritory.ownerId === gameData.humanPlayer.id &&
                   gameData.selectedTerritory.neighbors.includes(territory.id)) {
            ctx.fillStyle = this.warningColor;
            ctx.fillText('Click to attack', startX + 10, startY + 100);
        }
    }
    
    renderPlayerStats(ctx, gameData) {
        const player = gameData.humanPlayer;
        const startX = 250;
        const startY = this.canvas.height - 100;
        const width = 200;
        const height = 80;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Player name
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(player.name, startX + 10, startY + 20);
        
        // Stats
        ctx.fillStyle = this.textColor;
        ctx.font = '14px Arial';
        ctx.fillText(`Territories: ${player.territories.length}`, startX + 10, startY + 40);
        ctx.fillText(`Total Armies: ${player.totalArmies}`, startX + 10, startY + 55);
        ctx.fillText(`Score: ${player.score}`, startX + 10, startY + 70);
    }
    
    renderSpectatorMessage(ctx) {
        const startX = this.canvas.width / 2 - 150;
        const startY = 100;
        const width = 300;
        const height = 60;
        
        // Background
        ctx.fillStyle = 'rgba(255, 68, 68, 0.9)';
        ctx.fillRect(startX, startY, width, height);
        
        // Message
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('You have been eliminated!', startX + width / 2, startY + 25);
        
        ctx.font = '14px Arial';
        ctx.fillText('Spectator Mode', startX + width / 2, startY + 45);
    }
    
    renderHelpPanel(ctx) {
        const startX = 20;
        const startY = 80;
        const width = 200;
        const height = 140;
        
        // Background
        ctx.fillStyle = this.bgColor;
        ctx.fillRect(startX, startY, width, height);
        
        // Title
        ctx.fillStyle = this.accentColor;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Controls', startX + 10, startY + 18);
        
        // Help text - mobile-friendly
        ctx.fillStyle = this.textColor;
        ctx.font = '12px Arial';
        const helpLines = [
            'Tap: Select/Attack',
            'Drag: Pan camera',
            'Pinch: Zoom in/out',
            'Two finger: Pan & zoom',
            'ESC: Deselect',
            'R: Restart (when ended)'
        ];
        
        helpLines.forEach((line, index) => {
            ctx.fillText(line, startX + 10, startY + 35 + index * 15);
        });
    }
    
    renderPerformanceInfo(ctx, gameData) {
        // Show detailed performance panel if enabled
        if (gameData.showPerformancePanel) {
            const x = this.canvas.width - 250;
            const y = 50;
            const width = 240;
            const height = 160;
            
            // Background with transparency
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - 10, y - 10, width, height);
            
            // Border
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 10, width, height);
            
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            
            // Performance metrics with color coding
            const fps = gameData.fps || 0;
            const fpsColor = fps > 50 ? '#00ff00' : fps > 30 ? '#ffff00' : '#ff0000';
            this.renderTextWithShadow(ctx, `FPS: ${fps}`, x, y, fpsColor);
            
            this.renderTextWithShadow(ctx, `Frame: ${(gameData.frameTime || 0).toFixed(1)}ms`, x, y + 20, this.textColor);
            this.renderTextWithShadow(ctx, `Render: ${(gameData.renderTime || 0).toFixed(1)}ms`, x, y + 40, this.textColor);
            this.renderTextWithShadow(ctx, `Update: ${(gameData.updateTime || 0).toFixed(1)}ms`, x, y + 60, this.textColor);
            
            // Game-specific metrics
            this.renderTextWithShadow(ctx, `Territories: ${gameData.territoryCount || 0}`, x, y + 80, this.textColor);
            this.renderTextWithShadow(ctx, `Rendered: ${gameData.visibleTerritories || 0}`, x, y + 100, this.textColor);
            this.renderTextWithShadow(ctx, `Probes: ${gameData.probeCount || 0}`, x, y + 120, this.textColor);
            
            // Toggle hint
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, 'Press P to toggle', x + width - 15, y + height - 15, '#888888');
        } else {
            // Simple FPS counter
            ctx.fillStyle = this.textColor;
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`FPS: ${gameData.fps}`, this.canvas.width - 20, this.canvas.height - 10);
        }
        
        // Mobile touch debug info
        if (gameData.touchDebugInfo && gameData.showTouchDebug) {
            ctx.fillStyle = this.accentColor;
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            const lines = gameData.touchDebugInfo.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, 10, this.canvas.height - 60 + (index * 16));
            });
        }
    }
    
    renderProbeNotification(ctx, gameData) {
        // Show temporary probe notification above discovery panel for 3 seconds
        const recentProbeResults = gameData.recentProbeResults || [];
        const now = Date.now();
        
        // Get most recent probe result for human player within last 3 seconds
        const latestProbe = recentProbeResults
            .filter(result => result.playerId === gameData.humanPlayer?.id && (now - result.timestamp) < 3000)
            .sort((a, b) => b.timestamp - a.timestamp)[0];
        
        if (!latestProbe) return;
        
        // Top center positioning
        const width = 400;
        const height = 50;
        const x = (this.canvas.width - width) / 2;
        const y = 20;
        
        // Background with transparency
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Border with probe result color
        const borderColor = latestProbe.success ? '#00ff88' : '#ff4444';
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Probe notification text
        ctx.fillStyle = borderColor;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        
        const probeText = latestProbe.success 
            ? `‚úì Probe succeeded: ${latestProbe.discoveryName}`
            : `‚úó Probe failed: ${latestProbe.discoveryName}`;
            
        ctx.fillText(probeText, x + 10, y + 25);
        
        // Fade out effect
        const age = now - latestProbe.timestamp;
        if (age > 2000) { // Start fading after 2 seconds
            const fadeAlpha = 1 - ((age - 2000) / 1000); // Fade over 1 second
            ctx.globalAlpha = Math.max(0, fadeAlpha);
            ctx.fillText(probeText, x + 10, y + 25);
            ctx.globalAlpha = 1; // Reset alpha
        }
    }
    
    renderDiscoveryPanel(ctx, gameData) {
        // Only show human player's discoveries
        if (!gameData.playerDiscoveries || !gameData.humanPlayer) {
            console.log('üîç DEBUG: No playerDiscoveries or humanPlayer', {
                playerDiscoveries: !!gameData.playerDiscoveries,
                humanPlayer: !!gameData.humanPlayer
            });
            return;
        }
        
        const discoveries = gameData.playerDiscoveries.get(gameData.humanPlayer.id);
        if (!discoveries) {
            console.log('üîç DEBUG: No discoveries for human player', {
                humanPlayerId: gameData.humanPlayer.id,
                playerDiscoveriesKeys: Array.from(gameData.playerDiscoveries.keys())
            });
            return;
        }
        
        console.log('üîç DEBUG: Human player discoveries found:', discoveries);
        
        // Count active discoveries (with safety checks)
        let discoveryCount = 0;
        if (discoveries && discoveries.precursorWeapons > 0) discoveryCount++;
        if (discoveries && discoveries.precursorDrive > 0) discoveryCount++;
        if (discoveries && discoveries.precursorShield > 0) discoveryCount++;
        if (discoveries && discoveries.precursorNanotech > 0) discoveryCount++;
        if (discoveries && discoveries.ancientRuins > 0) discoveryCount++;
        if (discoveries && discoveries.friendlyAliens > 0) discoveryCount++;
        if (discoveries && discoveries.richMinerals > 0) discoveryCount++;
        
        // Always show panel if player has any discoveries
        if (discoveryCount === 0) {
            // Show empty panel if human player has made any probe attempts
            const humanPlayer = gameData.humanPlayer;
            if (!humanPlayer || humanPlayer.territories.length === 0) return;
        }
        
        const x = 20;
        const width = 280;
        const lineHeight = 20;
        const padding = 10;
        const discoveryHeight = discoveryCount * lineHeight;
        const titleHeight = 25;
        const height = Math.max(80, titleHeight + discoveryHeight + padding * 2);
        const y = this.canvas.height - height - 20; // Bottom left positioning
        
        // Background with transparency
        ctx.fillStyle = 'rgba(0, 20, 40, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery theme color
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Title
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        this.renderTextWithShadow(ctx, 'üî¨ Empire Discoveries', x + padding, y + 20, '#4CAF50');
        
        let currentY = y + 40; // Start showing permanent bonuses
        
        // Show empire-wide bonuses only (no temporary notifications)
        ctx.font = '12px Arial';
        
        // Show empire-wide bonuses (with safety checks)
        if (discoveries && discoveries.precursorWeapons > 0) {
            this.renderTextWithShadow(ctx, `‚öîÔ∏è Weapons Lvl ${discoveries.precursorWeapons}: +${discoveries.precursorWeapons * 10}% Attack`, x + padding, currentY, '#FF6B6B');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorDrive > 0) {
            this.renderTextWithShadow(ctx, `üöÄ Drive Lvl ${discoveries.precursorDrive}: +${discoveries.precursorDrive * 20}% Speed`, x + padding, currentY, '#4ECDC4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorShield > 0) {
            this.renderTextWithShadow(ctx, `üõ°Ô∏è Shield Lvl ${discoveries.precursorShield}: +${discoveries.precursorShield * 10}% Defense`, x + padding, currentY, '#45B7D1');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.precursorNanotech > 0) {
            this.renderTextWithShadow(ctx, `üî¨ Nanotech Lvl ${discoveries.precursorNanotech}: +${discoveries.precursorNanotech * 10}% Generation`, x + padding, currentY, '#96CEB4');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.factoryPlanets && discoveries.factoryPlanets.size > 0) {
            this.renderTextWithShadow(ctx, `üè≠ Factory Worlds: ${discoveries.factoryPlanets.size} (+100% each)`, x + padding, currentY, '#FECA57');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.friendlyAliens > 0) {
            this.renderTextWithShadow(ctx, `üëΩ Friendly Aliens: +${discoveries.friendlyAliens * 50} Fleet Strength`, x + padding, currentY, '#9B59B6');
            currentY += lineHeight;
        }
        
        if (discoveries && discoveries.richMinerals > 0) {
            this.renderTextWithShadow(ctx, `üíé Rich Minerals: ${discoveries.richMinerals} Worlds (+50% each)`, x + padding, currentY, '#F39C12');
            currentY += lineHeight;
        }
        
        // Discovery count summary
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, `Total: ${discoveryCount} discoveries`, x + width - padding, y + height - 5, '#888888');
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 255, g: 255, b: 255};
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': 'üíÄ',
            'extra_fleet': 'üëΩ',
            'precursor_weapons': '‚öîÔ∏è',
            'precursor_drive': 'üöÄ',
            'precursor_shield': 'üõ°Ô∏è',
            'precursor_nanotech': 'üî¨',
            'factory_complex': 'üè≠',
            'mineral_deposits': 'üíé',
            'void_storm': '‚ö°',
            'ancient_ruins': 'üèõÔ∏è'
        };
        return icons[effect] || 'üîç';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'precursor_weapons': '#ff6b6b',
            'precursor_drive': '#4ecdc4',
            'precursor_shield': '#45b7d1',
            'precursor_nanotech': '#96ceb4',
            'factory_complex': '#feca57',
            'mineral_deposits': '#ff9ff3',
            'void_storm': '#a55eea',
            'ancient_ruins': '#ffa726'
        };
        return colors[effect] || '#ffffff';
    }
    
    renderFloatingAnnouncements(ctx, gameData) {
        if (!gameData.discoveryLog || !gameData.humanPlayer) return;
        
        const now = Date.now();
        const humanPlayerId = gameData.humanPlayer.id;
        const announcements = gameData.discoveryLog.filter(entry => {
            const age = (now - entry.timestamp) / 1000;
            return age <= 3 && entry.playerId === humanPlayerId; // Only show human player discoveries for 3 seconds
        });
        
        // Show only the most recent announcement at top center
        if (announcements.length === 0) return;
        
        const latestAnnouncement = announcements.sort((a, b) => b.timestamp - a.timestamp)[0];
        const age = (now - latestAnnouncement.timestamp) / 1000;
        const fadeProgress = age / 3; // Fade over 3 seconds
        const opacity = Math.max(0, 1 - fadeProgress);
        
        // Get discovery info
        const icon = this.getDiscoveryIcon(latestAnnouncement.discovery.effect);
        const color = this.getDiscoveryColor(latestAnnouncement.discovery.effect);
        
        // Apply opacity
        const rgb = this.hexToRgb(color);
        const fadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
        
        // Top center positioning
        const width = 400;
        const height = 50;
        const x = (this.canvas.width - width) / 2;
        const y = 20;
        
        // Background with transparency
        ctx.fillStyle = `rgba(0, 0, 0, ${0.9 * opacity})`;
        ctx.fillRect(x, y, width, height);
        
        // Border with discovery color
        ctx.strokeStyle = fadeColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Discovery text
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        const text = `${icon} ${latestAnnouncement.discovery.name}`;
        this.renderTextWithShadow(ctx, text, x + width/2, y + height/2 + 5, fadeColor);
    }
    
    renderMinimap(ctx, gameData) {
        const size = 150;
        const startX = this.canvas.width - size - 20;
        const startY = this.canvas.height - size - 20;
        
        if (gameData.minimapMinimized) {
            // Minimized minimap - just show title bar
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(startX, startY + size - 30, size, 30);
            
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            this.renderTextWithShadow(ctx, 'Map (tap to expand)', startX + size / 2, startY + size - 12, this.accentColor);
            
            // Add expand indicator
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            this.renderTextWithShadow(ctx, '‚ñ≤', startX + size - 10, startY + size - 12, this.textColor);
            return;
        }
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(startX, startY, size, size);
        
        // Border
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, size, size);
        
        // Calculate scale
        const mapWidth = 2000; // From GameMap
        const mapHeight = 1500;
        const scaleX = size / mapWidth;
        const scaleY = size / mapHeight;
        
        // Draw territories on minimap
        Object.values(gameData.players).forEach(player => {
            if (player.isEliminated) return;
            
            ctx.fillStyle = player.color;
            player.territories.forEach(territoryId => {
                const territory = gameData.selectedTerritory ? 
                    (gameData.selectedTerritory.id === territoryId ? gameData.selectedTerritory : null) : null;
                // This is a simplified version - in real implementation we'd access territories from gameMap
                
                if (territory) {
                    const x = startX + territory.x * scaleX;
                    const y = startY + territory.y * scaleY;
                    const radius = Math.max(1, territory.radius * scaleX * 0.5);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });
        
        // Draw camera viewport
        if (this.camera) {
            const viewBounds = this.camera.getViewBounds();
            const viewX = startX + viewBounds.left * scaleX;
            const viewY = startY + viewBounds.top * scaleY;
            const viewWidth = (viewBounds.right - viewBounds.left) * scaleX;
            const viewHeight = (viewBounds.bottom - viewBounds.top) * scaleY;
            
            ctx.strokeStyle = this.accentColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(viewX, viewY, viewWidth, viewHeight);
        }
        
        // Minimap title with minimize indicator
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'Map', startX + size / 2, startY - 5, this.textColor);
        
        // Add minimize indicator
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        this.renderTextWithShadow(ctx, '‚ñº', startX + size - 5, startY - 5, this.textColor);
    }
    
    renderTooltip(ctx, gameData) {
        if (!gameData.hoveredTerritory || !gameData.mousePos) {
            return;
        }
        

        
        const territory = gameData.hoveredTerritory;
        const mouseX = gameData.mousePos.x;
        const mouseY = gameData.mousePos.y;
        
        // Get territory information
        let ownerName = 'Neutral';
        let territoryColor = '#666666';
        
        if (territory.ownerId !== null && gameData.players[territory.ownerId]) {
            const owner = gameData.players[territory.ownerId];
            ownerName = owner.name;
            territoryColor = owner.color;
        }
        
        // Prepare tooltip text
        let tooltipLines = [];
        if (territory.isColonizable) {
            tooltipLines.push(`Unexplored System`);
            
            // Only show "Click to probe" if player has a valid selected territory that can reach it
            const canProbe = gameData.selectedTerritory && 
                            gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id &&
                            gameData.selectedTerritory.armySize >= 10; // Need 10 fleets for probe
            
            if (canProbe) {
                tooltipLines.push(`Click to probe (10 fleets)`);
            } else if (gameData.selectedTerritory && gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id) {
                tooltipLines.push(`Need 10 fleets to probe`);
            } else {
                tooltipLines.push(`Select owned territory first`);
            }
        } else {
            // FOG OF WAR: Check if this is a mysterious territory
            const humanPlayerId = gameData.humanPlayer?.id;
            const isNeutralMystery = territory.ownerId === null && !territory.neighbors.some(neighborId => {
                const neighbor = gameData.territories?.[neighborId];
                return neighbor && neighbor.ownerId === humanPlayerId;
            });
            
            const isEnemyMystery = territory.ownerId !== null && territory.ownerId !== humanPlayerId && !territory.neighbors.some(neighborId => {
                const neighbor = gameData.territories?.[neighborId];
                return neighbor && neighbor.ownerId === humanPlayerId;
            });
            
            const isMysteriousTerritory = isNeutralMystery || isEnemyMystery;
            
            if (isMysteriousTerritory && territory.ownerId !== null) {
                // Mysterious enemy territory - only show player name
                tooltipLines.push(`${ownerName}`);
                tooltipLines.push(`Unknown forces`);
            } else if (isNeutralMystery) {
                // Mysterious neutral territory - show as unexplored
                tooltipLines.push(`Unexplored System`);
                tooltipLines.push(`Unknown garrison`);
            } else {
                // Visible territory - show full information
                tooltipLines.push(`${ownerName}`);
                
                // Calculate generation rate including supply bonuses
                let generationRate = 0;
                let fleetDisplay = `${territory.armySize} Fleets`;
                
                if (territory.ownerId !== null) {
                    // Base generation rate (1 fleet per 3 seconds = 0.33/s)
                    generationRate = 1000 / (territory.armyGenerationRate || 3000);
                    
                    // Add supply route bonuses
                    if (gameData.supplySystem && gameData.supplySystem.supplyRoutes) {
                        const incomingRoutes = gameData.supplySystem.supplyRoutes.filter(route => route.to === territory.id);
                        generationRate += incomingRoutes.length * (1000 / 3000); // Each supply route adds base rate
                    }
                    
                    // Format generation rate with proper precision
                    if (generationRate > 0) {
                        const rateText = generationRate >= 1 ? 
                            `+${generationRate.toFixed(1)}/s` : 
                            `+${generationRate.toFixed(2)}/s`;
                        fleetDisplay += ` (${rateText})`;
                    }
                }
                
                tooltipLines.push(fleetDisplay);
                
                if (territory.isThronestar) {
                    tooltipLines.push(`üëë Throne Star`);
                }
                
                // Show supply route information if this territory is supplying another
                if (gameData.supplySystem && gameData.supplySystem.supplyRoutes) {
                    const outgoingRoutes = gameData.supplySystem.supplyRoutes.filter(route => route.from === territory.id);
                    if (outgoingRoutes.length > 0) {
                        outgoingRoutes.forEach(route => {
                            const targetTerritory = gameData.territories[route.to];
                            if (targetTerritory) {
                                tooltipLines.push(`Reinforcing star ${route.to}`);
                            }
                        });
                    }
                }
            }
            
            // Show battle odds if player has selected territory and this is an enemy
            if (gameData.selectedTerritory && 
                gameData.selectedTerritory.ownerId === gameData.humanPlayer?.id &&
                territory.ownerId !== gameData.humanPlayer?.id &&
                territory.ownerId !== null) {
                

                
                // Check if territories are connected by star lane
                const isAdjacent = gameData.selectedTerritory.neighbors && 
                                 gameData.selectedTerritory.neighbors.includes(territory.id);
                

                
                if (isAdjacent && gameData.combatSystem) {
                    const attacker = gameData.humanPlayer;
                    const defender = gameData.players[territory.ownerId];
                    

                    
                    if (attacker && defender) {
                        const winChance = gameData.combatSystem.calculateBattleOdds(attacker, defender);

                        tooltipLines.push(`Battle Odds: ${winChance}% win`);
                    }
                }
            }
        }
        
        // Tooltip dimensions
        const padding = 8;
        const lineHeight = 16;
        const fontSize = 12;
        ctx.font = `${fontSize}px Arial`;
        
        const maxWidth = Math.max(...tooltipLines.map(line => ctx.measureText(line).width));
        const tooltipWidth = maxWidth + padding * 2;
        const tooltipHeight = tooltipLines.length * lineHeight + padding * 2;
        
        // Position tooltip near mouse but keep it on screen
        let tooltipX = mouseX + 15;
        let tooltipY = mouseY - tooltipHeight - 10;
        
        if (tooltipX + tooltipWidth > this.canvas.width) {
            tooltipX = mouseX - tooltipWidth - 15;
        }
        if (tooltipY < 0) {
            tooltipY = mouseY + 15;
        }
        
        // Draw tooltip background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip border
        ctx.strokeStyle = territoryColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip text
        ctx.fillStyle = '#ffffff';
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'left';
        
        tooltipLines.forEach((line, index) => {
            ctx.fillText(
                line,
                tooltipX + padding,
                tooltipY + padding + (index + 1) * lineHeight - 4
            );
        });
    }
    
    renderZoomControls(ctx, gameData) {
        const buttonSize = 50;
        const margin = 20;
        const spacing = 5;
        
        // Position in bottom left
        const zoomInX = margin;
        const zoomInY = this.canvas.height - margin - buttonSize;
        const zoomOutX = margin;
        const zoomOutY = this.canvas.height - margin - (buttonSize * 2) - spacing;
        
        // Current zoom percentage
        const zoomPercent = Math.round(gameData.camera?.zoom * 100) || 40;
        
        // Zoom Out button (-)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomOutX, zoomOutY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '-', zoomOutX + buttonSize/2, zoomOutY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom In button (+)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(zoomInX, zoomInY, buttonSize, buttonSize);
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(zoomInX, zoomInY, buttonSize, buttonSize);
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, '+', zoomInX + buttonSize/2, zoomInY + buttonSize/2 + 8, '#ffffff');
        
        // Zoom level display
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, `${zoomPercent}%`, zoomOutX + buttonSize/2, zoomOutY - 8, this.textColor);
    }
    
    renderGameOverScreen(ctx, gameData) {
        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Game Over title
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 100, '#ff4444');
        
        // Subtitle
        ctx.font = '24px Arial';
        this.renderTextWithShadow(ctx, 'All your territories have been conquered!', this.canvas.width / 2, this.canvas.height / 2 - 50, this.textColor);
        
        // Spectator message
        ctx.font = '18px Arial';
        this.renderTextWithShadow(ctx, 'You can continue watching the game...', this.canvas.width / 2, this.canvas.height / 2, this.textColor);
        
        // Play Again button
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = this.canvas.width / 2 - buttonWidth / 2;
        const buttonY = this.canvas.height / 2 + 50;
        
        // Button background
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        // Button text
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        this.renderTextWithShadow(ctx, 'PLAY AGAIN', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2 + 7, '#ffffff');
    }
    
    renderFinalLeaderboard(ctx, gameData) {
        const startX = this.canvas.width / 2 - 250;
        const startY = this.canvas.height / 2 - 50;
        const width = 500;
        const itemHeight = 35;
        
        // Sort all players by score and show only top 10 for better readability
        const sortedPlayers = [...gameData.players]
            .sort((a, b) => b.score - a.score)
            .slice(0, 10);
        const height = 80 + sortedPlayers.length * itemHeight;
        
        // Background with shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(startX + 4, startY + 4, width, height);
        
        // Main background
        ctx.fillStyle = 'rgba(0, 20, 40, 0.95)';
        ctx.fillRect(startX, startY, width, height);
        
        // Border
        ctx.strokeStyle = '#00ddff';
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, width, height);
        
        // Title with shadow
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        
        // Title shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText('Final Results', startX + width / 2 + 2, startY + 42);
        
        // Main title
        ctx.fillStyle = '#00ddff';
        ctx.fillText('Final Results', startX + width / 2, startY + 40);
        
        // Player entries
        sortedPlayers.forEach((player, index) => {
            const y = startY + 80 + index * itemHeight;
            const isHuman = player === gameData.humanPlayer;
            const isWinner = index === 0 && !player.isEliminated;
            
            // Background for winner or human player
            if (isWinner) {
                ctx.fillStyle = 'rgba(68, 255, 68, 0.15)';
                ctx.fillRect(startX + 5, y - 22, width - 10, itemHeight - 2);
            } else if (isHuman) {
                ctx.fillStyle = 'rgba(0, 221, 255, 0.1)';
                ctx.fillRect(startX + 5, y - 22, width - 10, itemHeight - 2);
            }
            
            // Rank with shadow
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            
            // Rank shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(`${index + 1}.`, startX + 22, y + 2);
            
            // Main rank
            ctx.fillStyle = isWinner ? '#44ff44' : '#ffffff';
            ctx.fillText(`${index + 1}.`, startX + 20, y);
            
            // Player color indicator (larger)
            ctx.fillStyle = player.color;
            ctx.fillRect(startX + 60, y - 12, 20, 20);
            
            // Player name with shadow
            ctx.font = isHuman ? 'bold 18px Arial' : '18px Arial';
            
            // Name shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(player.name, startX + 92, y + 2);
            
            // Main name
            ctx.fillStyle = isHuman ? '#00ddff' : (isWinner ? '#44ff44' : '#ffffff');
            ctx.fillText(player.name, startX + 90, y);
            
            // Stats with shadow
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            
            // Stats shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillText(`${player.territories.length} territories`, startX + width - 102, y - 3);
            ctx.fillText(`${player.score} points`, startX + width - 102, y + 15);
            
            // Main stats
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`${player.territories.length} territories`, startX + width - 100, y - 5);
            ctx.fillText(`${player.score} points`, startX + width - 100, y + 13);
            
            // Status
            if (player.isEliminated) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillText('Eliminated', startX + width - 22, y + 2);
                ctx.fillStyle = '#ff4444';
                ctx.fillText('Eliminated', startX + width - 20, y);
            } else if (isWinner) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillText('Winner!', startX + width - 22, y + 2);
                ctx.fillStyle = '#44ff44';
                ctx.fillText('Winner!', startX + width - 20, y);
            }
        });
    }
    
    // Render notification messages for discoveries
    renderNotifications(ctx, gameData) {
        if (!gameData.notifications || gameData.notifications.length === 0) return;
        
        const notifications = gameData.notifications;
        const startY = 150; // Start below top UI elements
        const lineHeight = 40;
        const padding = 15;
        const maxWidth = 400;
        
        notifications.forEach((notification, index) => {
            const y = startY + index * lineHeight;
            const x = this.canvas.width - maxWidth - 20; // Right side of screen
            
            // Background with fade
            ctx.globalAlpha = notification.opacity;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Border based on notification type
            ctx.strokeStyle = notification.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - padding, y - 25, maxWidth + padding * 2, 35);
            
            // Text
            ctx.fillStyle = notification.color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(notification.text, x, y);
            
            ctx.globalAlpha = 1.0; // Reset opacity
        });
    }
}


===============================================================================
### COMPLETE UTILS.JS CODE (Discovery Processing)
===============================================================================
/**
 * Centralized utility functions for Star Throne game
 * Eliminates code duplication across game modules
 */

import { GAME_CONSTANTS } from '../../../common/gameConstants';

export class GameUtils {
    /**
     * Centralized error logging that respects debug mode
     * @param {string} message - Error message to log
     * @param {Error} error - Error object to log
     */
    static logError(message, error) {
        if (GAME_CONSTANTS.DEBUG_MODE) {
            console.error(message, error);
        }
        // In non-debug mode, we could send these errors to a server or store them if needed,
        // but avoid spamming the console.
    }
    
    /**
     * Centralized debug logging that respects debug mode
     * @param {string} message - Debug message to log
     * @param {...any} args - Additional arguments to log
     */
    static logDebug(message, ...args) {
        if (GAME_CONSTANTS.DEBUG_MODE) {
            console.log(message, ...args);
        }
    }
    
    /**
     * Generate random integer between min and max (inclusive)
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random integer
     */
    static randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    /**
     * Generate random float between min and max
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random float
     */
    static randomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }
    
    /**
     * Get random element from array
     * @param {Array} array - Array to select from
     * @returns {*} Random element from array
     */
    static getRandomElement(array) {
        if (!array || array.length === 0) {
            this.logError('getRandomElement called with empty or null array');
            return null;
        }
        return array[Math.floor(Math.random() * array.length)];
    }
    
    /**
     * Validate that a value is a number and within optional bounds
     * @param {*} value - Value to validate
     * @param {number} min - Optional minimum value
     * @param {number} max - Optional maximum value
     * @returns {boolean} True if valid number within bounds
     */
    static isValidNumber(value, min = null, max = null) {
        if (typeof value !== 'number' || isNaN(value)) {
            return false;
        }
        if (min !== null && value < min) return false;
        if (max !== null && value > max) return false;
        return true;
    }
    
    /**
     * Safe array access with bounds checking
     * @param {Array} array - Array to access
     * @param {number} index - Index to access
     * @returns {*} Element at index or null if invalid
     */
    static safeArrayAccess(array, index) {
        if (!array || !Array.isArray(array) || index < 0 || index >= array.length) {
            return null;
        }
        return array[index];
    }
    
    /**
     * Process discovery effects for a player
     * Centralized discovery logic used by both client and server
     */
    static processDiscovery(discoveryType, playerId, territoryId, playerDiscoveries, game) {
        // Get existing discoveries (should already be initialized)
        let discoveries = playerDiscoveries.get(playerId);
        if (!discoveries) {
            console.error(`Discoveries not initialized for player ${playerId}`);
            return { success: false, effectText: 'Discovery system error', icon: '‚ùå' };
        }
        
        let effectText = '';
        let icon = '';

        switch (discoveryType) {
            case 'precursor_weapons':
                discoveries.precursorWeapons++;
                effectText = `‚öîÔ∏è Precursor Weapons Level ${discoveries.precursorWeapons}! Empire attack increased by ${discoveries.precursorWeapons * 10}%`;
                icon = '‚öîÔ∏è';
                break;

            case 'precursor_drive':
                discoveries.precursorDrive++;
                effectText = `üöÄ Precursor Drive Level ${discoveries.precursorDrive}! Empire speed increased by ${discoveries.precursorDrive * 20}%`;
                icon = 'üöÄ';
                break;

            case 'precursor_shield':
                discoveries.precursorShield++;
                effectText = `üõ°Ô∏è Precursor Shield Level ${discoveries.precursorShield}! Empire defense increased by ${discoveries.precursorShield * 10}%`;
                icon = 'üõ°Ô∏è';
                break;

            case 'precursor_nanotech':
                discoveries.precursorNanotech++;
                effectText = `üî¨ Precursor Nanotech Level ${discoveries.precursorNanotech}! Empire generation increased by ${discoveries.precursorNanotech * 10}%`;
                icon = 'üî¨';
                break;

            case 'precursor_factory':
                discoveries.richMinerals++; // Track factory count since factoryPlanets doesn't exist
                effectText = `üè≠ Precursor Factory discovered! Planet ${territoryId} has 200% generation rate`;
                icon = 'üè≠';
                break;

            case 'friendly_aliens':
                discoveries.friendlyAliens++;
                effectText = `üëΩ Friendly aliens provide 50 fleet strength!`;
                icon = 'üëΩ';
                // Apply immediate fleet bonus if game instance available
                if (game && territoryId !== undefined) {
                    const territory = game.gameMap?.territories[territoryId];
                    if (territory) {
                        territory.armySize += 50;
                    }
                }
                break;

            case 'mineral_deposits':
                discoveries.richMinerals++;
                effectText = `üíé Rich minerals found! Planet ${territoryId} has 150% generation rate`;
                icon = 'üíé';
                break;

            case 'void_storm':
                discoveries.voidStorms++;
                effectText = `‚ö° Void storm remnants! Planet ${territoryId} has 75% generation rate`;
                icon = '‚ö°';
                break;

            case 'ancient_ruins':
                discoveries.ancientRuins++;
                effectText = `üèõÔ∏è Ancient ruins discovered on planet ${territoryId}`;
                icon = 'üèõÔ∏è';
                break;

            case 'hostile_aliens':
                discoveries.hostileAliens++;
                effectText = `üíÄ Probe lost to hostile aliens! Planet ${territoryId} remains unexplored.`;
                icon = 'üíÄ';
                return { success: false, effectText, icon }; // Probe failed

            case 'standard_planet':
            default:
                effectText = `üåç Standard planet colonized: ${territoryId}`;
                icon = 'üåç';
                break;
        }

        return { success: true, effectText, icon, discoveries };
    }

    /**
     * Get discovery probabilities based on game constants
     */
    static getDiscoveryProbabilities() {
        return {
            hostile_aliens: 0.15,      // 15% chance probe fails
            friendly_aliens: 0.08,     // 8% chance for bonus fleet
            precursor_weapons: 0.06,   // 6% chance for weapons
            precursor_drive: 0.06,     // 6% chance for drive
            precursor_shield: 0.06,    // 6% chance for shield
            precursor_nanotech: 0.06,  // 6% chance for nanotech
            precursor_factory: 0.05,   // 5% chance for factory
            rich_minerals: 0.10,       // 10% chance for minerals
            void_storm: 0.08,          // 8% chance for void storm
            ancient_ruins: 0.05,       // 5% chance for ruins
            standard_planet: 0.25      // 25% chance for standard (remainder)
        };
    }

    /**
     * Calculate combat result using centralized logic
     */
    static calculateCombatResult(attackPower, defensePower, attackerDiscoveries, defenderDiscoveries) {
        // Apply discovery bonuses
        if (attackerDiscoveries?.precursorWeapons > 0) {
            attackPower *= (1 + attackerDiscoveries.precursorWeapons * 0.1);
        }
        if (defenderDiscoveries?.precursorShield > 0) {
            defensePower *= (1 + defenderDiscoveries.precursorShield * 0.1);
        }

        // Add randomness for combat uncertainty
        const attackRoll = attackPower * (0.8 + Math.random() * 0.4);
        const defenseRoll = defensePower * (0.8 + Math.random() * 0.4);

        return attackRoll > defenseRoll;
    }

    /**
     * Generate army generation rate with discovery bonuses
     */
    static calculateArmyGenerationRate(baseRate, discoveries) {
        let rate = baseRate;
        
        if (discoveries?.precursorNanotech > 0) {
            rate *= (1 + discoveries.precursorNanotech * 0.1);
        }
        
        return rate;
    }

    /**
     * Calculate probe speed with discovery bonuses
     */
    static calculateProbeSpeed(baseSpeed, discoveries) {
        let speed = baseSpeed;
        
        if (discoveries?.precursorDrive > 0) {
            speed *= (1 + discoveries.precursorDrive * 0.2);
        }
        
        return speed;
    }

    /**
     * Validate territory connection distance
     */
    static isValidConnection(territory1, territory2, maxDistance = 80) {
        const distance = Math.sqrt(
            (territory1.x - territory2.x) ** 2 + 
            (territory1.y - territory2.y) ** 2
        );
        return distance <= maxDistance;
    }

    /**
     * Generate AI player name with variety
     */
    static generateAIName(index) {
        const firstNames = [
            'Alex', 'Blake', 'Casey', 'Dana', 'Emma', 'Felix', 'Grace', 'Hunter',
            'Iris', 'Jack', 'Kai', 'Luna', 'Max', 'Nova', 'Owen', 'Piper',
            'Quinn', 'Riley', 'Sage', 'Tara', 'Uma', 'Val', 'Wade', 'Xara',
            'York', 'Zara', 'Ace', 'Bay', 'Cora', 'Drew', 'Eve', 'Fox',
            'Gem', 'Hope', 'Ion', 'Jazz', 'Kit', 'Lee', 'Mae', 'Neo'
        ];

        const clans = [
            'StarForge', 'VoidHunters', 'NebulaRise', 'CosmicFury', 'SolarFlare',
            'AstroLegion', 'GalaxyGuard', 'StellarWolves', 'NovaClan', 'OrbitStorm',
            'CubClan', 'DarkMatter', 'PhotonLords', 'QuantumKnights', 'StarShards'
        ];

        const ranks = [
            'Admiral', 'Captain', 'Commander', 'Colonel', 'General', 'Marshal',
            'Commodore', 'Major', 'Lieutenant', 'Sergeant', 'Chief', 'Director'
        ];

        // 25% clan format, 25% rank format, 50% simple names
        const nameType = Math.random();
        const firstName = firstNames[index % firstNames.length];
        
        if (nameType < 0.25) {
            const clan = clans[Math.floor(index / firstNames.length) % clans.length];
            return `[${clan}] ${firstName}`;
        } else if (nameType < 0.5) {
            const rank = ranks[Math.floor(index / firstNames.length) % ranks.length];
            return `${rank} ${firstName}`;
        } else {
            return firstName;
        }
    }

    /**
     * Generate player colors with good contrast
     */
    static generatePlayerColors(count) {
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
            '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#F4D03F',
            '#D7BDE2', '#A3E4D7', '#FAD7A0', '#D5A6BD', '#A9DFBF'
        ];
        
        const result = [];
        for (let i = 0; i < count; i++) {
            result.push(colors[i % colors.length]);
        }
        return result;
    }

    /**
     * Format time display
     */
    static formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    /**
     * Clamp value between min and max
     */
    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    /**
     * Linear interpolation
     */
    static lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    /**
     * Calculate distance between two points
     */
    static distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    /**
     * Generate random color
     */
    static randomColor() {
        return `hsl(${Math.random() * 360}, 70%, 60%)`;
    }

    /**
     * Shuffle array in place
     */
    static shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
}

export default GameUtils;

===============================================================================
### COMPLETE TERRITORY.JS CODE (Army Generation and Discovery Triggers)
===============================================================================
export class Territory {
    constructor(id, x, y, radius = 25, isColonizable = false) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.neighbors = [];
        this.hiddenNeighbors = []; // Legacy - no longer used with new visibility system
        this.ownerId = null; // null for neutral, or player ID
        
        // All territories start with neutral garrisons (1-30 armies)
        this.armySize = Math.floor(Math.random() * 30) + 1;
        this.isColonizable = false; // No longer needed with new visibility system
        
        // Visual properties
        this.baseColor = '#444444';
        this.neutralColor = '#666666'; // Standard neutral color
        this.strokeColor = '#888888'; // Standard stroke for all territories
        
        // Animation
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.lastArmyGeneration = 0;
        this.armyGenerationRate = 3000; // Generate army every 3 seconds (matches GAME_CONSTANTS)
        
        // Combat flash effect
        this.combatFlashTime = 0;
        this.combatFlashDuration = 800; // Flash for 800ms
        
        // Probe launch visual feedback
        this.probeFlashTime = 0;
        this.probeFlashDuration = 1000; // Flash for 1 second
        this.floatingText = null; // For floating "-10" text
    }
    
    addNeighbor(territoryId) {
        if (!this.neighbors.includes(territoryId)) {
            this.neighbors.push(territoryId);
        }
    }
    
    addHiddenNeighbor(territoryId) {
        if (!this.hiddenNeighbors.includes(territoryId)) {
            this.hiddenNeighbors.push(territoryId);
        }
    }
    
    revealConnections() {
        // Move hidden connections to visible neighbors when colonized
        this.neighbors.push(...this.hiddenNeighbors);
        this.hiddenNeighbors = [];
        this.isColonizable = false; // No longer colonizable
    }
    
    isNeutral() {
        return this.ownerId === null;
    }
    
    triggerCombatFlash() {
        this.combatFlashTime = Date.now();
    }
    
    triggerProbeFlash() {
        this.probeFlashTime = Date.now();
        this.floatingText = {
            text: '-10',
            startTime: Date.now(),
            duration: 1000,
            startY: this.y - this.radius - 10,
            color: '#ff4444'
        };
    }
    
    generateArmies(deltaTime, player, gameSpeed = 1.0, game = null) {
        // Neutral territories have fixed army sizes and don't generate armies
        if (this.ownerId === null) return;
        
        // Don't generate armies until a few seconds after game start to prevent initialization issues
        if (game && game.gameStartTime && (Date.now() - game.gameStartTime) < 5000) {
            return;
        }
        
        // Apply game speed multiplier to army generation timing
        const speedAdjustedDelta = deltaTime * gameSpeed;
        this.lastArmyGeneration += speedAdjustedDelta;
        
        // Calculate generation rate with discovery bonuses
        let effectiveGenerationRate = this.armyGenerationRate;
        
        // Apply planet-specific bonuses
        if (this.discoveryBonus === 'factory') {
            effectiveGenerationRate *= 0.5; // 200% speed (half the time)
        } else if (this.discoveryBonus === 'minerals') {
            effectiveGenerationRate *= 0.67; // 150% speed
        } else if (this.discoveryBonus === 'void_storm') {
            effectiveGenerationRate *= 1.33; // 75% speed
        }
        
        // Apply empire-wide nanotech bonus
        if (game && game.discoveries && game.discoveries.precursorNanotech > 0) {
            const nanotechBonus = 1 + (game.discoveries.precursorNanotech * 0.1);
            effectiveGenerationRate /= nanotechBonus;
        }
        
        if (this.lastArmyGeneration >= effectiveGenerationRate) {
            const armiesGenerated = Math.floor(this.lastArmyGeneration / effectiveGenerationRate);
            this.lastArmyGeneration = this.lastArmyGeneration % effectiveGenerationRate;
            
            // Check if this territory has an active supply route
            if (game && game.supplySystem && game.supplySystem.isSupplySource(this.id)) {
                const destinationId = game.supplySystem.getSupplyDestination(this.id);
                const destinationTerritory = game.gameMap.territories[destinationId];
                
                if (destinationTerritory && destinationTerritory.ownerId === this.ownerId) {
                    // Redirect army generation to destination
                    destinationTerritory.armySize += armiesGenerated;
                    // Supply route redirection (logging disabled for cleaner console output)
                    
                    // Visual feedback disabled to prevent text spam on heavily reinforced territories
                } else {
                    // Route broken, generate locally
                    this.armySize += armiesGenerated;
                }
            } else {
                // Normal army generation
                this.armySize += armiesGenerated;
            }
            
            if (player) {
                player.totalArmies += armiesGenerated;
            }
        }
    }
    
    render(ctx, players, selectedTerritory, gameData, hoveredTerritory = null) {
        const isSelected = selectedTerritory && selectedTerritory.id === this.id;
        const isHovered = hoveredTerritory && hoveredTerritory.id === this.id;
        
        // Determine territory color
        let fillColor = this.neutralColor;
        if (this.ownerId !== null && players[this.ownerId]) {
            fillColor = players[this.ownerId].color;
        }
        
        // Add home system flashing effect for human player
        if (gameData && gameData.humanPlayer && this.ownerId === gameData.humanPlayer.id && 
            gameData.homeSystemFlashStart && gameData.humanPlayer.territories.includes(this.id)) {
            const currentTime = Date.now();
            const elapsed = currentTime - gameData.homeSystemFlashStart;
            
            if (elapsed < gameData.homeSystemFlashDuration) {
                // Flash every 300ms for 3 seconds
                const flashCycle = Math.floor(elapsed / 300) % 2;
                if (flashCycle === 1) {
                    fillColor = '#ffffff'; // Flash to white
                }
            }
        }
        
        // Add combat flash effect
        const currentTime = Date.now();
        if (this.combatFlashTime > 0 && currentTime - this.combatFlashTime < this.combatFlashDuration) {
            const flashProgress = (currentTime - this.combatFlashTime) / this.combatFlashDuration;
            const flashIntensity = Math.sin(flashProgress * Math.PI * 6) * (1 - flashProgress);
            if (flashIntensity > 0 && this.combatFlashColor) {
                // Use attacker's color for combat flash
                fillColor = this.combatFlashColor;
            } else if (flashIntensity > 0) {
                // Fallback to red if no color specified
                fillColor = this.adjustColorBrightness('#ff4444', 1 + flashIntensity * 0.8);
            }
        }
        
        // Add selection highlighting
        if (isSelected) {
            // Pulsing selection effect
            this.pulsePhase += 0.1;
            const pulseIntensity = Math.sin(this.pulsePhase) * 0.3 + 0.7;
            fillColor = this.adjustColorBrightness(fillColor, pulseIntensity);
        }
        
        // Optimize rendering with batch operations
        ctx.save();
        
        // FOG OF WAR: Check if this is a mysterious territory
        const humanPlayerId = gameData?.humanPlayer?.id;
        const isNeutralMystery = this.ownerId === null && !this.neighbors.some(neighborId => {
            const neighbor = gameData?.gameMap?.territories?.[neighborId];
            return neighbor && neighbor.ownerId === humanPlayerId;
        });
        
        const isEnemyMystery = this.ownerId !== null && this.ownerId !== humanPlayerId && !this.neighbors.some(neighborId => {
            const neighbor = gameData?.gameMap?.territories?.[neighborId];
            return neighbor && neighbor.ownerId === humanPlayerId;
        });
        
        const isMysteriousTerritory = isNeutralMystery || isEnemyMystery;
        
        // Adjust rendering for mysterious territories
        const renderRadius = isMysteriousTerritory ? this.radius * 0.8 : this.radius;
        const renderAlpha = isMysteriousTerritory ? 0.6 : 1.0;
        
        // Add hover glow effect (reduced for mysterious territories)
        if (isHovered && !isSelected) {
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = isMysteriousTerritory ? 8 : 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Apply mystery transparency
        ctx.globalAlpha = renderAlpha;
        
        // Draw territory circle and border in single operation
        ctx.beginPath();
        ctx.arc(this.x, this.y, renderRadius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        
        // Clear shadow for subsequent rendering
        ctx.shadowBlur = 0;
        
        // Optimize player lookup using direct access
        const player = this.ownerId ? players[this.ownerId] : null;
        const isHumanPlayer = player && player.type === 'human';
        
        // Set stroke properties based on state
        if (isSelected) {
            // Pulsating selection outline
            const pulseIntensity = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulseIntensity})`;
            ctx.lineWidth = 4;
        } else if (isHovered) {
            // Bright white hover outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
        } else if (isHumanPlayer) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
        } else {
            ctx.strokeStyle = this.strokeColor;
            ctx.lineWidth = 1;
        }
        ctx.stroke();
        
        // Action confirmation flash
        if (this.lastActionFlash && (currentTime - this.lastActionFlash) < 300) {
            const flashProgress = (currentTime - this.lastActionFlash) / 300;
            const flashIntensity = 1 - flashProgress;
            ctx.strokeStyle = `rgba(0, 255, 0, ${flashIntensity})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Add extra ring for player territories
        if (this.ownerId !== null && player) {
            // Draw outer ring for all player territories
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 4, 0, Math.PI * 2);
            
            if (isHumanPlayer) {
                // Bright cyan outer ring for human player
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 6;
            } else {
                // Player color outer ring for AI players
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 3;
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        // Draw flag for human player territories
        if (isHumanPlayer) {
            this.renderHumanFlag(ctx);
        }
        
        // Draw crown for throne star territories (only if not mysterious)
        if (this.isThronestar && this.ownerId !== null && !isMysteriousTerritory) {
            this.renderCrown(ctx);
        }
        
        // Draw factory icon for Precursor Factory discoveries
        if (this.hasFactory) {
            this.renderFactoryIcon(ctx);
        }
        
        // Draw explosion animation for failed probes
        if (this.explosionTime && Date.now() - this.explosionTime < this.explosionDuration) {
            this.renderExplosion(ctx);
        }
        
        // Draw army count for neutral territories with fog of war
        if (this.ownerId === null) {
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            // FOG OF WAR: Check if adjacent to player-owned territory
            const humanPlayerId = gameData?.humanPlayer?.id;
            const isAdjacentToPlayer = this.neighbors.some(neighborId => {
                const neighbor = gameData?.gameMap?.territories?.[neighborId];
                return neighbor && neighbor.ownerId === humanPlayerId;
            });
            
            if (this.isColonizable) {
                // Simple yellow question mark for colonizable planets
                ctx.fillStyle = '#ffff00'; // Yellow text
                ctx.font = 'bold 16px Arial';
                
                const displayText = '?';
                ctx.fillText(displayText, this.x, this.y + 5);
                
                // Subtle pulsing border effect (reduced intensity)
                const pulseIntensity = 0.7 + 0.2 * Math.sin(Date.now() * 0.002 + this.pulsePhase);
                ctx.strokeStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            } else if (!isAdjacentToPlayer) {
                // Mysterious neutral territory - yellow question mark with smaller, translucent appearance
                ctx.fillStyle = '#ffff00'; // Yellow text for mystery
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)'; // Yellow outline
                ctx.lineWidth = 2;
                ctx.font = 'bold 16px Arial';
                
                const displayText = '?';
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            } else {
                // Visible neutral territory - show army count normally
                ctx.fillStyle = '#000000'; // Black text
                ctx.strokeStyle = '#ffffff'; // White outline for contrast
                ctx.lineWidth = 2;
                
                const displayText = this.armySize.toString();
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            }
        }
        
        // Draw territory ID (for debugging)
        if (isSelected) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`T${this.id}`, this.x, this.y - this.radius - 8);
        }
        
        // Draw army count for owned territories with probe flash effect (only if not mysterious)
        if (this.ownerId !== null && !isMysteriousTerritory) {
            const player = players[this.ownerId];
            if (player) {
                // Check for probe flash effect
                const currentTime = Date.now();
                const isProbeFlashing = (currentTime - this.probeFlashTime) < this.probeFlashDuration;
                
                let textColor = '#000000'; // Default black text
                if (isProbeFlashing) {
                    // Red flash effect for probe launch
                    const flashProgress = (currentTime - this.probeFlashTime) / this.probeFlashDuration;
                    const flashIntensity = Math.sin(flashProgress * Math.PI * 4) * 0.5 + 0.5;
                    textColor = `rgb(${255 * flashIntensity}, 0, 0)`;
                }
                
                ctx.fillStyle = textColor;
                ctx.strokeStyle = '#ffffff'; // White outline for better readability
                ctx.lineWidth = 2;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                
                let displayText = this.armySize.toString();
                
                // Add black dot indicator for reinforcing stars
                // Access supply system through global game reference
                if (window.game?.supplySystem?.isSupplySource(this.id)) {
                    displayText = `‚óè ${displayText}`;
                }
                
                ctx.strokeText(displayText, this.x, this.y + 4);
                ctx.fillText(displayText, this.x, this.y + 4);
            }
        }
        
        // Draw floating "-10" text for probe launches
        if (this.floatingText) {
            const currentTime = Date.now();
            const elapsed = currentTime - this.floatingText.startTime;
            
            if (elapsed < this.floatingText.duration) {
                const progress = elapsed / this.floatingText.duration;
                const alpha = 1 - progress;
                const yOffset = progress * 30; // Float upward
                
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    this.floatingText.text,
                    this.x,
                    this.floatingText.startY - yOffset
                );
            } else {
                this.floatingText = null; // Remove when done
            }
        }
        
        // Highlight potential targets if this territory is selected
        if (isSelected && this.ownerId !== null) {
            this.renderPotentialTargets(ctx, players);
        }
        
        // Restore alpha for subsequent rendering
        ctx.globalAlpha = 1.0;
        
        ctx.restore();
    }
    
    renderHumanFlag(ctx) {
        // Small flag pole and flag for human territories
        const flagX = this.x + this.radius * 0.6;
        const flagY = this.y - this.radius * 0.8;
        const poleHeight = this.radius * 0.7;
        const flagWidth = this.radius * 0.4;
        const flagHeight = this.radius * 0.25;
        
        // Draw flag pole
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX, flagY + poleHeight);
        ctx.stroke();
        
        // Draw flag
        ctx.fillStyle = '#00ffff';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(flagX, flagY);
        ctx.lineTo(flagX + flagWidth, flagY + flagHeight / 2);
        ctx.lineTo(flagX, flagY + flagHeight);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Add small star on flag
        ctx.fillStyle = '#ffffff';
        ctx.font = `${Math.max(8, this.radius * 0.3)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('‚òÖ', flagX + flagWidth * 0.4, flagY + flagHeight * 0.7);
    }
    
    renderCrown(ctx) {
        // Crown positioned above the planet
        const crownX = this.x;
        const crownY = this.y - this.radius - 15;
        const crownSize = Math.max(12, this.radius * 0.8);
        
        ctx.save();
        
        // Crown shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${crownSize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üëë', crownX + 1, crownY + 1);
        
        // Main crown - golden color
        ctx.fillStyle = '#FFD700';
        ctx.font = `bold ${crownSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üëë', crownX, crownY);
        
        ctx.restore();
    }
    
    renderFactoryIcon(ctx) {
        // Factory icon positioned to the right of the planet
        const factoryX = this.x + this.radius + 10;
        const factoryY = this.y;
        const factorySize = Math.max(10, this.radius * 0.6);
        
        ctx.save();
        
        // Factory shadow for visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.font = `bold ${factorySize + 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üè≠', factoryX + 1, factoryY + 1);
        
        // Main factory icon - orange/industrial color
        ctx.fillStyle = '#FF8C00';
        ctx.font = `bold ${factorySize}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('üè≠', factoryX, factoryY);
        
        ctx.restore();
    }
    
    renderExplosion(ctx) {
        const elapsed = Date.now() - this.explosionTime;
        const progress = elapsed / this.explosionDuration;
        
        if (progress >= 1) return; // Animation finished
        
        ctx.save();
        
        // Multiple explosion rings expanding outward
        const maxRadius = this.radius * 3;
        const numRings = 3;
        
        for (let i = 0; i < numRings; i++) {
            const ringProgress = Math.max(0, progress - i * 0.2);
            const radius = ringProgress * maxRadius;
            const opacity = Math.max(0, 1 - ringProgress * 2);
            
            if (radius > 0 && opacity > 0) {
                // Orange/red explosion colors
                const colors = ['#ff4444', '#ff8800', '#ffaa00'];
                ctx.strokeStyle = colors[i % colors.length];
                ctx.globalAlpha = opacity;
                ctx.lineWidth = Math.max(1, 4 - ringProgress * 3);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Central flash effect
        if (progress < 0.3) {
            const flashOpacity = (0.3 - progress) / 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity * 0.8})`;
            ctx.globalAlpha = flashOpacity;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    renderPotentialTargets(ctx, players) {
        // Show attackable neighbors with red outline
        this.neighbors.forEach(neighborId => {
            const neighbor = this.gameMap?.territories[neighborId];
            if (neighbor && neighbor.ownerId !== this.ownerId) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(neighbor.x, neighbor.y, neighbor.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }
    
    adjustColorBrightness(hex, factor) {
        if (hex.startsWith('#')) {
            hex = hex.slice(1);
        }
        
        const num = parseInt(hex, 16);
        const r = Math.min(255, Math.floor((num >> 16) * factor));
        const g = Math.min(255, Math.floor(((num >> 8) & 0x00FF) * factor));
        const b = Math.min(255, Math.floor((num & 0x0000FF) * factor));
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    getDistanceTo(otherTerritory) {
        const dx = this.x - otherTerritory.x;
        const dy = this.y - otherTerritory.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    isNeighborOf(otherTerritory) {
        return this.neighbors.includes(otherTerritory.id);
    }
    
    // Serialize territory data for network transmission (future multiplayer)
    serialize() {
        return {
            id: this.id,
            x: this.x,
            y: this.y,
            radius: this.radius,
            neighbors: this.neighbors,
            ownerId: this.ownerId,
            armySize: this.armySize
        };
    }
    
    // Deserialize territory data from network (future multiplayer)
    static deserialize(data) {
        const territory = new Territory(data.id, data.x, data.y, data.radius);
        territory.neighbors = data.neighbors || [];
        territory.ownerId = data.ownerId;
        territory.armySize = data.armySize || 0;
        return territory;
    }
}


===============================================================================
### COMPLETE GAMEMAP.JS CODE (Territory Distribution and Throne Assignment)
===============================================================================
import { Territory } from './Territory.js';
import MapGenerator from './MapGenerator.js';

export class GameMap {
    constructor(width, height, config = {}) {
        this.width = width * 1.4; // Expand width by 40%
        this.height = height * 1.4; // Expand height by 40%
        this.territories = {};
        this.nebulas = []; // Purple nebula clouds
        this.gridSize = 150; // Increased space between territory centers for less crowding
        
        // Spatial indexing for O(1) territory lookups instead of O(n)
        this.spatialGridSize = 100; // Grid cell size in pixels
        this.spatialGrid = new Map(); // Map of "x,y" -> Territory[]
        this.spatialIndexEnabled = true;
        
        // Advanced configuration options
        this.layout = config.layout || 'organic'; // Layout type: organic, clusters, spiral, core, ring, binary
        this.connectionDistance = config.connectionRange || 60; // Max distance for territory connections - prevent long-distance warp lanes
        this.warpLaneDensity = config.warpLaneDensity || 80; // Percentage density for connections
        this.nebulaCount = config.nebulaCount !== undefined ? config.nebulaCount : 10; // Number of nebula fields
        this.nebulaSlowdown = config.nebulaSlowdown !== undefined ? config.nebulaSlowdown : true;
        this.supplyRoutes = config.supplyRoutes !== undefined ? config.supplyRoutes : true;
        this.probeColonization = config.probeColonization !== undefined ? config.probeColonization : true;
    }
    
    // Helper function to check if a point is within organic galaxy boundaries
    isWithinGalaxyBounds(x, y) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Calculate normalized position (0 to 1 from center)
        const normalizedX = (x - centerX) / (this.width / 2);
        const normalizedY = (y - centerY) / (this.height / 2);
        
        // Create organic galaxy shape using multiple sine waves for irregular edges
        const baseRadius = 0.85; // Base galaxy size (85% of max)
        
        // Use angle from center for perlin-like noise effect
        const angle = Math.atan2(normalizedY, normalizedX);
        
        // Create multiple frequency sine waves for organic edge variation
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        // Calculate distance from center
        const distanceFromCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        
        // Organic boundary with variation
        const maxDistance = baseRadius + edgeVariation;
        
        return distanceFromCenter <= maxDistance;
    }

    // Helper function to get max radius at a specific angle for organic boundary
    getMaxRadiusAtAngle(angle) {
        const baseRadius = 0.85; // Base galaxy size (85% of max)
        
        // Create organic edge variation using the same formula as boundary check
        const edgeVariation = 
            0.15 * Math.sin(angle * 3.7) + // Large bumps
            0.08 * Math.sin(angle * 7.2) + // Medium bumps  
            0.05 * Math.sin(angle * 11.8) + // Small bumps
            0.03 * Math.sin(angle * 17.3); // Fine detail
        
        return baseRadius + edgeVariation;
    }

    // Helper function to check if a point is too close to existing points
    isValidPosition(x, y, existingPoints, minDistance = this.gridSize) {
        // First check if within organic galaxy boundaries
        if (!this.isWithinGalaxyBounds(x, y)) return false;
        
        // Then check minimum distance from other territories
        for (const point of existingPoints) {
            const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
            if (dist < minDistance) return false;
        }
        return true;
    }

    generateTerritories(count) {
        console.log(`üåå Generating ${count} territories using advanced ${this.layout} layout...`);
        
        // Use the advanced MapGenerator for sophisticated galaxy layouts
        const generatedTerritories = MapGenerator.generateMap(count, this.layout, 20); // Assume 20 players for cluster generation
        
        // Update map dimensions from MapGenerator
        this.width = MapGenerator.mapWidth;
        this.height = MapGenerator.mapHeight;
        
        // Convert generated territories to our game format - ALL have neutral garrisons
        generatedTerritories.forEach((territory, index) => {
            // Set up neutral garrison (1-30 armies visible)
            territory.isColonizable = false;
            territory.armySize = Math.floor(Math.random() * 30) + 1; // Visible garrison size
            territory.ownerId = null; // Neutral until captured
            
            // All connections are visible from the start (no hidden neighbors)
            // territory.neighbors already set by MapGenerator - keep them visible
            territory.hiddenNeighbors = []; // No hidden connections with new visibility system
            
            this.territories[index] = territory;
            
            // Spatial indexing for performance
            this.addToSpatialIndex(territory);
        });
        
        console.log(`‚ú® Generated ${count} territories with advanced ${this.layout} galaxy layout`);
        console.log(`üìê Map dimensions: ${this.width} x ${this.height}`);
        console.log(`üîó Sophisticated warp lane network with planar connectivity`);
        
        // Generate nebula fields AFTER territories to avoid overlaps
        this.generateNebulas();
    }
    
    generateNebulas() {
        // Use configurable nebula count (0-20)
        const nebulaCount = this.nebulaCount;
        
        for (let i = 0; i < nebulaCount; i++) {
            let attempts = 0;
            let x, y;
            
            // Find positions within organic galaxy boundaries
            do {
                x = Math.random() * this.width;
                y = Math.random() * this.height;
                attempts++;
            } while (!this.isWithinGalaxyBounds(x, y) && attempts < 50);
            
            // If we couldn't find a valid position after many attempts, skip this nebula
            if (attempts >= 50) continue;
            
            const nebula = {
                x: x,
                y: y,
                radius: 80 + Math.random() * 120, // Size varies from 80 to 200
                opacity: 0.3 + Math.random() * 0.4, // Opacity varies from 0.3 to 0.7
                color: `rgba(147, 51, 234, ${0.3 + Math.random() * 0.4})` // Purple with varying opacity
            };
            this.nebulas.push(nebula);
        }
        
        console.log(`Generated ${nebulaCount} nebula fields (configured: ${this.nebulaCount})`);
    }
    


    // ===== OBSOLETE METHODS REMOVED =====
    // The following legacy layout generation methods have been replaced by the advanced MapGenerator class:
    // - poissonDiskSampling() - replaced by MapGenerator.generateMap() with organic layout
    // - generateClusterLayout() - replaced by MapGenerator cluster algorithm with Delaunay triangulation
    // - generateSpiralLayout() - replaced by MapGenerator spiral algorithm with force-directed relaxation
    // - generateCoreLayout() - replaced by MapGenerator core algorithm with MST connectivity
    // - generateRingLayout() - replaced by MapGenerator ring algorithm with optimal spacing
    // - generateBinaryLayout() - replaced by MapGenerator binary algorithm with planar connections
    // - connectTerritoriesForLayout() - replaced by MapGenerator's sophisticated warp lane networks
    //
    // All map generation now uses the advanced MapGenerator class which provides:
    // ‚úÖ Delaunay triangulation for planar connectivity (no crossing warp lanes)
    // ‚úÖ Minimum Spanning Tree algorithms for optimal path networks
    // ‚úÖ Force-directed relaxation for natural territory spacing
    // ‚úÖ Collision detection preventing lanes from cutting through territories
    // ‚úÖ Six distinct galaxy layouts with unique characteristics
    

    

    
    generateRingLayout(count) {
        const points = [];
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const rings = 4 + Math.floor(Math.random() * 3); // 4-6 rings
        const planetsPerRing = Math.floor(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = 60 + ring * 70; // Rings spaced 70 units apart
            const ringPlanets = ring === rings - 1 ? 
                count - (planetsPerRing * ring) : planetsPerRing;
            
            for (let i = 0; i < ringPlanets; i++) {
                let attempts = 0;
                let validPoint = false;
                
                while (!validPoint && attempts < 100) {
                    const angle = (i / ringPlanets) * 2 * Math.PI + (Math.random() - 0.5) * 0.3;
                    const ringRadius = radius + (Math.random() - 0.5) * 30; // Slight radius variation
                    
                    const x = centerX + Math.cos(angle) * ringRadius;
                    const y = centerY + Math.sin(angle) * ringRadius;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        validPoint = true;
                    }
                    attempts++;
                }
                
                // Fallback: random placement if ring placement fails
                if (!validPoint) {
                    for (let j = 0; j < 50; j++) {
                        const x = Math.random() * (this.width - 60) + 30;
                        const y = Math.random() * (this.height - 60) + 30;
                        
                        if (this.isValidPosition(x, y, points)) {
                            points.push({ x, y });
                            break;
                        }
                    }
                }
            }
        }
        
        return points;
    }
    
    generateBinaryLayout(count) {
        const points = [];
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        const systemRadius = Math.min(this.width, this.height) * 0.25;
        
        // Split planets between two major systems
        const leftCount = Math.floor(count / 2);
        const rightCount = count - leftCount;
        
        // Left system
        for (let i = 0; i < leftCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = leftCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        // Right system
        for (let i = 0; i < rightCount; i++) {
            let attempts = 0;
            let validPoint = false;
            
            while (!validPoint && attempts < 100) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * systemRadius;
                const x = rightCenterX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (this.isValidPosition(x, y, points)) {
                    points.push({ x, y });
                    validPoint = true;
                }
                attempts++;
            }
            
            // Fallback: random placement if system placement fails
            if (!validPoint) {
                for (let j = 0; j < 50; j++) {
                    const x = Math.random() * (this.width - 60) + 30;
                    const y = Math.random() * (this.height - 60) + 30;
                    
                    if (this.isValidPosition(x, y, points)) {
                        points.push({ x, y });
                        break;
                    }
                }
            }
        }
        
        return points;
    }
    
    connectTerritoriesForLayout() {
        // Different connection strategies based on layout
        switch (this.layout) {
            case 'clusters':
                this.connectClusters();
                break;
            case 'spiral':
                this.connectSpiral();
                break;
            case 'core':
                this.connectCore();
                break;
            case 'ring':
                this.connectRings();
                break;
            case 'binary':
                this.connectBinary();
                break;
            case 'organic':
            default:
                this.connectTerritories();
                break;
        }
    }
    
    connectClusters() {
        const territoryList = Object.values(this.territories);
        
        // First connect within clusters (short distance connections)
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const closeNeighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) { // Close cluster connections
                    closeNeighbors.push({ territory: other, distance });
                }
            }
            
            closeNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, closeNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = closeNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Then add bridge connections between clusters
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const bridgeTargets = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance > this.connectionDistance * 0.8 && distance <= this.connectionDistance * 1.5) { // Bridge connections
                    bridgeTargets.push({ territory: other, distance });
                }
            }
            
            if (bridgeTargets.length > 0) {
                bridgeTargets.sort((a, b) => a.distance - b.distance);
                const neighbor = bridgeTargets[0].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectSpiral() {
        const territoryList = Object.values(this.territories);
        
        // Connect along spiral arms and between nearby arms
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, neighbors.length); // Fewer connections for spiral
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectCore() {
        const territoryList = Object.values(this.territories);
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        // Identify core territories (close to center)
        const coreTerritories = territoryList.filter(t => {
            const distToCenter = Math.sqrt((t.x - centerX) ** 2 + (t.y - centerY) ** 2);
            return distToCenter <= 100;
        });
        
        // Dense connections in core
        for (const territory of coreTerritories) {
            const coreNeighbors = [];
            
            for (const other of coreTerritories) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    coreNeighbors.push({ territory: other, distance });
                }
            }
            
            coreNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(5, coreNeighbors.length); // Dense core
            
            for (let k = 0; k < connections; k++) {
                const neighbor = coreNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Radial connections from core to shells
        for (const territory of territoryList) {
            if (coreTerritories.includes(territory)) continue;
            
            const radialNeighbors = [];
            for (const other of territoryList) {
                if (territory.id === other.id) continue;
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    radialNeighbors.push({ territory: other, distance });
                }
            }
            
            radialNeighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(3, radialNeighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = radialNeighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectRings() {
        const territoryList = Object.values(this.territories);
        
        // Connect within rings and between adjacent rings
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const neighbors = [];
            
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance) {
                    neighbors.push({ territory: other, distance });
                }
            }
            
            neighbors.sort((a, b) => a.distance - b.distance);
            const connections = Math.min(4, neighbors.length);
            
            for (let k = 0; k < connections; k++) {
                const neighbor = neighbors[k].territory;
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
    }
    
    connectBinary() {
        const territoryList = Object.values(this.territories);
        const leftCenterX = this.width * 0.3;
        const rightCenterX = this.width * 0.7;
        const centerY = this.height / 2;
        
        // Identify left and right system territories
        const leftSystem = territoryList.filter(t => t.x < this.width / 2);
        const rightSystem = territoryList.filter(t => t.x >= this.width / 2);
        
        // Connect within each system
        [leftSystem, rightSystem].forEach(system => {
            for (const territory of system) {
                const systemNeighbors = [];
                
                for (const other of system) {
                    if (territory.id === other.id) continue;
                    const distance = territory.getDistanceTo(other);
                    
                    if (distance <= this.connectionDistance) {
                        systemNeighbors.push({ territory: other, distance });
                    }
                }
                
                systemNeighbors.sort((a, b) => a.distance - b.distance);
                const connections = Math.min(4, systemNeighbors.length);
                
                for (let k = 0; k < connections; k++) {
                    const neighbor = systemNeighbors[k].territory;
                    territory.addNeighbor(neighbor.id);
                    neighbor.addNeighbor(territory.id);
                }
            }
        });
        
        // Add bridge connections between systems
        const bridgeConnections = Math.min(3, Math.min(leftSystem.length, rightSystem.length));
        for (let i = 0; i < bridgeConnections; i++) {
            const leftTerr = leftSystem[Math.floor(Math.random() * leftSystem.length)];
            const rightTerr = rightSystem[Math.floor(Math.random() * rightSystem.length)];
            
            leftTerr.addNeighbor(rightTerr.id);
            rightTerr.addNeighbor(leftTerr.id);
        }
    }
    
    // Check if a line between two territories passes through any other territory or existing warp lanes
    linePassesThroughTerritory(from, to, allTerritories, existingConnections = []) {
        // Check collision with other territories
        for (const territory of allTerritories) {
            if (territory.id === from.id || territory.id === to.id) continue;
            
            // Calculate distance from territory center to line segment
            const A = from.x;
            const B = from.y;
            const C = to.x;
            const D = to.y;
            const E = territory.x;
            const F = territory.y;
            
            // Vector from from to to
            const dx = C - A;
            const dy = D - B;
            
            // Vector from from to territory
            const ex = E - A;
            const ey = F - B;
            
            // Project territory onto line
            const dot = ex * dx + ey * dy;
            const lenSquared = dx * dx + dy * dy;
            
            if (lenSquared === 0) continue; // Line has no length
            
            const t = Math.max(0, Math.min(1, dot / lenSquared));
            
            // Closest point on line segment
            const closestX = A + t * dx;
            const closestY = B + t * dy;
            
            // Distance from territory to closest point on line
            const distToLine = Math.sqrt((E - closestX) ** 2 + (F - closestY) ** 2);
            
            // If line passes too close to territory (within its radius + larger margin)
            if (distToLine < territory.radius + 30) { // Increased margin from 15 to 30
                return true;
            }
        }
        
        // Check collision with existing warp lanes
        for (const connection of existingConnections) {
            if (this.linesIntersect(from, to, connection.from, connection.to)) {
                return true;
            }
        }
        
        return false;
    }
    
    // Check if two line segments intersect
    linesIntersect(line1Start, line1End, line2Start, line2End) {
        const x1 = line1Start.x, y1 = line1Start.y;
        const x2 = line1End.x, y2 = line1End.y;
        const x3 = line2Start.x, y3 = line2Start.y;
        const x4 = line2End.x, y4 = line2End.y;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return false; // Lines are parallel
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        // Check if intersection point is within both line segments
        if (t >= 0.1 && t <= 0.9 && u >= 0.1 && u <= 0.9) { // Added small margin to avoid endpoint intersections
            return true;
        }
        
        return false;
    }

    connectTerritories() {
        const territoryList = Object.values(this.territories);
        const existingConnections = []; // Track existing warp lanes to prevent intersections
        
        // Use Delaunay triangulation approximation for natural connections
        for (let i = 0; i < territoryList.length; i++) {
            const territory = territoryList[i];
            const nearbyTerritories = [];
            
            // Find all territories within connection distance
            for (let j = 0; j < territoryList.length; j++) {
                if (i === j) continue;
                
                const other = territoryList[j];
                const distance = territory.getDistanceTo(other);
                
                if (distance <= this.connectionDistance && !this.linePassesThroughTerritory(territory, other, territoryList, existingConnections)) {
                    nearbyTerritories.push({ territory: other, distance });
                }
            }
            
            // Sort by distance and connect to closest neighbors
            nearbyTerritories.sort((a, b) => a.distance - b.distance);
            
            // Connect to 2-6 closest neighbors, influenced by warp lane density
            const baseDensity = this.warpLaneDensity / 100; // Convert percentage to decimal
            const maxConnections = Math.min(6, Math.max(2, nearbyTerritories.length));
            const adjustedConnections = Math.max(1, Math.floor(maxConnections * baseDensity));
            const numConnections = Math.min(adjustedConnections, 2 + Math.floor(Math.random() * 3));
            
            for (let k = 0; k < numConnections && k < nearbyTerritories.length; k++) {
                const neighbor = nearbyTerritories[k].territory;
                
                // Additional density check - some connections may be skipped based on density
                if (Math.random() * 100 > this.warpLaneDensity) continue;
                
                // Track this connection to prevent future intersections
                existingConnections.push({
                    from: territory,
                    to: neighbor
                });
                
                // All connections are now regular neighbors (no hidden connections)
                territory.addNeighbor(neighbor.id);
                neighbor.addNeighbor(territory.id);
            }
        }
        
        // Ensure connectivity by connecting isolated territories
        this.ensureConnectivity();
    }
    
    ensureConnectivity() {
        const visited = new Set();
        const territoryIds = Object.keys(this.territories);
        
        if (territoryIds.length === 0) return;
        
        // BFS to find connected components
        const bfs = (startId) => {
            const queue = [startId];
            const component = [];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                if (visited.has(currentId)) continue;
                
                visited.add(currentId);
                component.push(currentId);
                
                const territory = this.territories[currentId];
                territory.neighbors.forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        queue.push(neighborId);
                    }
                });
            }
            
            return component;
        };
        
        const components = [];
        
        // Find all connected components
        territoryIds.forEach(id => {
            if (!visited.has(id)) {
                components.push(bfs(id));
            }
        });
        
        // Connect isolated components
        while (components.length > 1) {
            const comp1 = components[0];
            const comp2 = components[1];
            
            // Find closest territories between components
            let minDistance = Infinity;
            let bestConnection = null;
            
            comp1.forEach(id1 => {
                const territory1 = this.territories[id1];
                comp2.forEach(id2 => {
                    const territory2 = this.territories[id2];
                    const distance = territory1.getDistanceTo(territory2);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestConnection = { territory1, territory2 };
                    }
                });
            });
            
            // Connect the closest territories
            if (bestConnection) {
                bestConnection.territory1.addNeighbor(bestConnection.territory2.id);
                bestConnection.territory2.addNeighbor(bestConnection.territory1.id);
            }
            
            // Merge components
            components[0] = comp1.concat(comp2);
            components.splice(1, 1);
        }
    }
    
    // Get territories within a rectangular area (for culling)
    getTerritoriesInBounds(bounds) {
        const result = [];
        
        Object.values(this.territories).forEach(territory => {
            if (territory.x + territory.radius >= bounds.left &&
                territory.x - territory.radius <= bounds.right &&
                territory.y + territory.radius >= bounds.top &&
                territory.y - territory.radius <= bounds.bottom) {
                result.push(territory);
            }
        });
        
        return result;
    }
    
    // Find nearest territory to a point
    findNearestTerritory(x, y) {
        let nearest = null;
        let minDistance = Infinity;
        
        Object.values(this.territories).forEach(territory => {
            const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = territory;
            }
        });
        
        return nearest;
    }
    
    // Get map statistics
    getMapStats() {
        const territoryCount = Object.keys(this.territories).length;
        let totalConnections = 0;
        let neutralTerritories = 0;
        
        Object.values(this.territories).forEach(territory => {
            totalConnections += territory.neighbors.length;
            if (territory.ownerId === null) {
                neutralTerritories++;
            }
        });
        
        return {
            territories: territoryCount,
            connections: totalConnections / 2, // Each connection counted twice
            averageConnections: totalConnections / territoryCount,
            neutralTerritories: neutralTerritories,
            width: this.width,
            height: this.height
        };
    }
    
    // Serialize map data for network transmission (future multiplayer)
    serialize() {
        const serializedTerritories = {};
        
        Object.keys(this.territories).forEach(id => {
            serializedTerritories[id] = this.territories[id].serialize();
        });
        
        return {
            width: this.width,
            height: this.height,
            territories: serializedTerritories
        };
    }
    
    // Deserialize map data from network (future multiplayer)
    static deserialize(data) {
        const map = new GameMap(data.width, data.height);
        
        Object.keys(data.territories).forEach(id => {
            map.territories[id] = Territory.deserialize(data.territories[id]);
        });
        
        return map;
    }
    
    isInNebula(x, y) {
        // Check if a point is inside any nebula
        for (const nebula of this.nebulas) {
            const distance = Math.sqrt((x - nebula.x) ** 2 + (y - nebula.y) ** 2);
            if (distance <= nebula.radius) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Add territory to spatial index for O(1) lookups
     */
    addToSpatialIndex(territory) {
        if (!this.spatialIndexEnabled) return;
        
        const gridX = Math.floor(territory.x / this.spatialGridSize);
        const gridY = Math.floor(territory.y / this.spatialGridSize);
        const key = `${gridX},${gridY}`;
        
        if (!this.spatialGrid.has(key)) {
            this.spatialGrid.set(key, []);
        }
        this.spatialGrid.get(key).push(territory);
    }
    
    /**
     * Find territory at coordinates using spatial indexing (O(1) vs O(n))
     */
    findTerritoryAt(x, y) {
        if (!this.spatialIndexEnabled) {
            // Fallback to linear search
            return Object.values(this.territories).find(territory => {
                const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                return distance <= territory.radius;
            });
        }
        
        // Spatial index lookup - check only nearby cells
        const gridX = Math.floor(x / this.spatialGridSize);
        const gridY = Math.floor(y / this.spatialGridSize);
        
        // Check current cell and adjacent cells (3x3 grid)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${gridX + dx},${gridY + dy}`;
                const cellTerritories = this.spatialGrid.get(key);
                
                if (cellTerritories) {
                    for (const territory of cellTerritories) {
                        const distance = Math.sqrt((x - territory.x) ** 2 + (y - territory.y) ** 2);
                        if (distance <= territory.radius) {
                            return territory;
                        }
                    }
                }
            }
        }
        return null;
    }
    
    /**
     * Build spatial index for all territories
     */
    buildSpatialIndex() {
        if (!this.spatialIndexEnabled) return;
        
        this.spatialGrid.clear();
        Object.values(this.territories).forEach(territory => {
            this.addToSpatialIndex(territory);
        });
    }
}


===============================================================================  
### ANALYSIS SUMMARY AND DEBUGGING RECOMMENDATIONS
===============================================================================

ISSUE #1: DOUBLE THRONE STAR BUG
- Problem: validateThroneStars() function exists but throneStarValidationTimer not incrementing
- Root cause: Timer logic in update() method but validation not being called
- Fix needed: Check if update() method is calling throne validation properly

ISSUE #2: DISCOVERY SYSTEM UI ZEROS  
- Problem: processDiscovery() in GameUtils vs DiscoverySystem.processDiscovery() confusion
- Discovery data structure initialized correctly but not incremented during conquest
- Fix needed: Ensure CombatSystem calls the correct discovery processing function

ISSUE #3: 10-SECOND BLACK SCREEN
- Problem: Likely in game initialization sequence - map generation or modular system setup
- Background image loading, spatial indexing, or starfield generation may be blocking
- Fix needed: Add timing logs to identify bottleneck in init() sequence

CRITICAL DEBUGGING STEPS:
1. Add console.log timestamps to init() method to identify slow operations
2. Verify throneStarValidationTimer increment in update() method  
3. Check which discovery processing function CombatSystem is actually calling
4. Ensure GameUtils.processDiscovery() properly increments playerDiscoveries values
5. Verify renderDiscoveryPanel() is being called from main render loop
