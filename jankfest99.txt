# JANKFEST 99 - STAR THRONE COMPLETE CODEBASE
# Comprehensive Code Collation and Architecture Documentation
# Generated: January 1, 2025

## SYSTEM ARCHITECTURE OVERVIEW

Star Throne is a browser-based real-time strategy game supporting up to 100 players in massive multiplayer battles. The game features probe-only colonization, hidden army mechanics, atmospheric nebula systems, and Supreme Commander-style strategic controls.

### Core Technologies
- **Frontend**: React 18 + TypeScript, HTML5 Canvas rendering
- **Backend**: Express.js + Socket.IO WebSocket server
- **Game Engine**: Custom vanilla JavaScript engine
- **State Management**: Zustand for lightweight state
- **UI Framework**: Radix UI components with Tailwind CSS
- **Build System**: Vite with hot module replacement

### Key Architectural Decisions
1. **Canvas-Based Rendering**: Chosen over DOM for performance with 100+ entities
2. **Client-Server Hybrid**: Real-time multiplayer with authoritative validation
3. **Probe-Only Colonization**: All neutral planets require exploration probes
4. **Organic Galaxy Generation**: Poisson disk sampling with density clustering
5. **Performance Optimization**: Viewport culling, object pooling, staggered AI updates

## FILE STRUCTURE AND COMPONENTS

### Client-Side Game Engine (/client/src/game/)

#### StarThrone.js - Main Game Controller
```javascript
export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Input handling
        this.mousePos = { x: 0, y: 0 };
        this.selectedTerritory = null;
        this.hoveredTerritory = null;
        this.isDragging = false;
        this.lastMousePos = { x: 0, y: 0 };
        this.cursorMode = 'default'; // 'default', 'attack', 'transfer', 'probe'
        
        // Fleet command system
        this.isProportionalDrag = false;
        this.proportionalDragStart = null;
        this.fleetPercentage = 0.5; // Default 50%
        this.proportionalDragThreshold = 15; // pixels
        this.proportionalDragDelay = 300; // ms
        this.dragStartTime = 0;
        
        // Transfer preview system
        this.transferPreview = null;
        this.hoveredTerritory = null;
        
        // Context-sensitive modifier key tracking
        this.modifierKeys = {
            shift: false,
            ctrl: false,
            alt: false
        };
        
        // Enhanced mobile controls
        this.isMultiTouch = false;
        this.touchStartDistance = 0;
        this.pinchCenter = { x: 0, y: 0 };
        this.lastPinchDistance = 0;
        this.pinchThreshold = 2; // Reduced for better sensitivity
        this.initialZoom = 1.0;
        
        // Long press functionality
        this.longPressTimer = null;
        this.longPressThreshold = 800; // 800ms for long press
        this.longPressTarget = null;
        this.longPressStartPos = null;
        
        // Performance tracking
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        this.frameCount = 0;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.fpsUpdateTimer = 0;
        
        // Visibility culling for performance
        this.visibleTerritories = [];
        this.lastVisibilityUpdate = 0;
        
        // Ship animations with object pooling
        this.shipAnimations = [];
        this.shipAnimationPool = [];
        
        // Supply route system
        this.supplyRoutes = [];
        this.supplyRouteAnimations = [];
        
        // Probe system
        this.probes = [];
        
        // Floating text animations
        this.floatingTexts = [];
        
        // Touch debug information
        this.touchDebugInfo = '';
        this.showTouchDebug = false;
        
        // UI state
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Start minimized for cleaner interface
        this.showPerformancePanel = false;
        
        // Parallax starfield system
        this.starfield = {
            farStars: [],      // Slowest moving, smallest stars
            midStars: [],      // Medium speed, medium stars  
            nearStars: [],     // Fastest moving, larger stars
            initialized: false
        };
        
        // Discovery system for planet colonization
        this.discoveries = {
            // Empire-wide bonuses (levels stack)
            precursorWeapons: 0,    // +10% attack per level
            precursorDrive: 0,      // +20% probe/ship speed per level
            precursorShield: 0,     // +10% defense per level
            precursorNanotech: 0,   // +10% empire-wide generation per level
            
            // Planet-specific bonuses
            factoryPlanets: new Set(), // Planets with 200% generation
            
            // Discovery history for display
            discoveryLog: []
        };
        
        // Notification system
        this.notifications = [];
        
        // Bonus panel state
        this.showBonusPanel = true;
        
        this.init();
    }
    
    // Add notification to display queue
    addNotification(text, color = '#44ff44', duration = 4000) {
        this.notifications.push({
            text: text,
            color: color,
            createdAt: Date.now(),
            duration: duration,
            opacity: 1.0
        });
    }
    
    // Update and clean up notifications
    updateNotifications() {
        const now = Date.now();
        this.notifications = this.notifications.filter(notification => {
            const age = now - notification.createdAt;
            if (age > notification.duration) {
                return false; // Remove expired notifications
            }
            
            // Fade out in the last 500ms
            if (age > notification.duration - 500) {
                notification.opacity = (notification.duration - age) / 500;
            }
            
            return true;
        });
    }
    
    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.gameMap = new GameMap(2000, 1500, this.config); // Large map with advanced configuration
        this.gameMap.game = this; // Reference for AI animations
        this.camera = new Camera(this.canvas.width, this.canvas.height);
        
        // Update camera map boundaries to match actual expanded map size
        this.camera.mapWidth = this.gameMap.width;
        this.camera.mapHeight = this.gameMap.height;
        
        // Center camera on map and set appropriate zoom
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2); // Center of expanded map
        this.camera.targetZoom = 0.25; // Zoom out further to see more territories
        this.camera.zoom = 0.25;
        
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Initialize parallax starfield
        this.initializeStarfield();
        
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            // Precursor technology discoveries (30% total)
            { id: 'precursor_weapons', name: 'Precursor Weapons Cache', description: 'Ancient weapon technology discovered!', effect: 'attack_bonus', probability: 0.08 },
            { id: 'precursor_drive', name: 'Precursor Drive System', description: 'Advanced propulsion technology found!', effect: 'speed_bonus', probability: 0.06 },
            { id: 'precursor_shield', name: 'Precursor Shield Matrix', description: 'Defensive technology enhances your empire!', effect: 'defense_bonus', probability: 0.08 },
            { id: 'precursor_nanotech', name: 'Precursor Nanotechnology', description: 'Self-replicating technology spreads across your empire!', effect: 'generation_bonus', probability: 0.08 },
            
            // Hostile encounters (15%)
            { id: 'hostile_aliens', name: 'Hostile Aliens', description: 'Hostile alien life destroys your probe!', effect: 'probe_lost', probability: 0.15 },
            
            // Beneficial discoveries (25% total)
            { id: 'friendly_aliens', name: 'Friendly Aliens', description: 'Friendly aliens join your empire!', effect: 'extra_fleet', bonus: 50, probability: 0.10 },
            { id: 'rich_minerals', name: 'Rich Mineral Deposits', description: 'Valuable resources boost this planet\'s output!', effect: 'mineral_planet', probability: 0.08 },
            { id: 'precursor_factory', name: 'Precursor Factory Complex', description: 'Ancient manufacturing facility still operational!', effect: 'factory_planet', probability: 0.07 },
            
            // Negative discoveries (10%)
            { id: 'void_storm', name: 'Void Storm Remnants', description: 'Dangerous energy storms reduce planet effectiveness.', effect: 'reduced_generation', probability: 0.10 },
            
            // Neutral/cosmetic discoveries (10%)
            { id: 'ancient_ruins', name: 'Ancient Ruins', description: 'Mysterious structures provide no immediate benefit.', effect: 'cosmetic', probability: 0.08 },
            
            // Standard planets (10%)
            { id: 'standard', name: 'Standard Planet', description: 'A typical world with no special features.', effect: 'none', probability: 0.10 }
        ];
    }
    
    // Initialize three-layer parallax starfield
    initializeStarfield() {
        if (this.starfield.initialized) return;
        
        // Expand starfield to cover larger area for seamless parallax
        const starfieldWidth = this.gameMap.width * 1.5;
        const starfieldHeight = this.gameMap.height * 1.5;
        const offsetX = -starfieldWidth * 0.25;
        const offsetY = -starfieldHeight * 0.25;
        
        // Far layer: 300 small dim stars (slowest parallax)
        for (let i = 0; i < 300; i++) {
            this.starfield.farStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1 + 0.5,
                brightness: Math.random() * 0.3 + 0.1,
                twinkle: Math.random() * 0.2 + 0.8
            });
        }
        
        // Mid layer: 150 medium stars (moderate parallax)
        for (let i = 0; i < 150; i++) {
            this.starfield.midStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 1.5 + 1.0,
                brightness: Math.random() * 0.4 + 0.2,
                twinkle: Math.random() * 0.3 + 0.7
            });
        }
        
        // Near layer: 80 large bright stars (strongest parallax)
        for (let i = 0; i < 80; i++) {
            this.starfield.nearStars.push({
                x: Math.random() * starfieldWidth + offsetX,
                y: Math.random() * starfieldHeight + offsetY,
                size: Math.random() * 2 + 1.5,
                brightness: Math.random() * 0.5 + 0.3,
                twinkle: Math.random() * 0.4 + 0.6
            });
        }
        
        this.starfield.initialized = true;
        console.log('Parallax starfield initialized with 530 stars across 3 layers');
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Process discovery when a planet is successfully colonized
    processDiscovery(territory, discovery, playerId) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log
        this.discoveries.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`🔍 Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Apply discovery effects
        switch (discovery.effect) {
            case 'probe_lost':
                // Probe is destroyed, planet remains unexplored
                territory.isColonizable = true;
                territory.ownerId = null;
                territory.armySize = territory.hiddenArmySize || Math.floor(Math.random() * 50) + 1;
                console.log(`💀 Probe lost to hostile aliens! Planet ${territory.id} remains unexplored.`);
                return false; // Colonization failed
                
            case 'extra_fleet':
                // Friendly aliens boost fleet strength
                territory.armySize = discovery.bonus;
                const friendlyMessage = `👽 Friendly aliens provide ${discovery.bonus} fleet strength!`;
                console.log(friendlyMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(friendlyMessage, '#44ff44');
                }
                break;
                
            case 'attack_bonus':
                // Empire-wide attack bonus
                this.discoveries.precursorWeapons++;
                const weaponMessage = `⚔️ Precursor Weapons Level ${this.discoveries.precursorWeapons}! Empire attack increased by 10%`;
                console.log(weaponMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(weaponMessage, '#ff6600');
                }
                break;
                
            case 'speed_bonus':
                // Empire-wide speed bonus
                this.discoveries.precursorDrive++;
                const driveMessage = `🚀 Precursor Drive Level ${this.discoveries.precursorDrive}! Empire speed increased by 20%`;
                console.log(driveMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(driveMessage, '#00ddff');
                }
                break;
                
            case 'defense_bonus':
                // Empire-wide defense bonus
                this.discoveries.precursorShield++;
                const shieldMessage = `🛡️ Precursor Shield Level ${this.discoveries.precursorShield}! Empire defense increased by 10%`;
                console.log(shieldMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(shieldMessage, '#0088ff');
                }
                break;
                
            case 'factory_planet':
                // Planet gets double generation rate
                this.discoveries.factoryPlanets.add(territory.id);
                territory.discoveryBonus = 'factory';
                const factoryMessage = `🏭 Precursor Factory discovered! Planet ${territory.id} has 200% generation rate`;
                console.log(factoryMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(factoryMessage, '#ff8800');
                }
                break;
                
            case 'generation_bonus':
                // Empire-wide generation bonus
                this.discoveries.precursorNanotech++;
                const nanotechMessage = `🔬 Precursor Nanotech Level ${this.discoveries.precursorNanotech}! Empire generation increased by 10%`;
                console.log(nanotechMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(nanotechMessage, '#aa00ff');
                }
                break;
                
            case 'mineral_planet':
                // Planet gets +50% generation
                territory.discoveryBonus = 'minerals';
                const mineralMessage = `💎 Rich minerals found! Planet ${territory.id} has 150% generation rate`;
                console.log(mineralMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(mineralMessage, '#ffdd00');
                }
                break;
                
            case 'reduced_generation':
                // Planet gets reduced generation
                territory.discoveryBonus = 'void_storm';
                const stormMessage = `⚡ Void storm remnants! Planet ${territory.id} has 75% generation rate`;
                console.log(stormMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(stormMessage, '#ff4444');
                }
                break;
                
            case 'cosmetic':
                // Ancient ruins - cosmetic only
                territory.discoveryBonus = 'ruins';
                const ruinsMessage = `🏛️ Ancient ruins discovered on planet ${territory.id}`;
                console.log(ruinsMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(ruinsMessage, '#888888');
                }
                break;
                
            default:
                // No special effect
                const standardMessage = `🌍 Standard planet colonized: ${territory.id}`;
                console.log(standardMessage);
                if (playerId === this.humanPlayer?.id) {
                    this.addNotification(standardMessage, '#aaaaaa');
                }
                break;
        }
        
        return true; // Colonization successful
    }
    
    // Main game loop with performance optimization
    gameLoop(currentTime = 0) {
        const frameStart = performance.now();
        const deltaTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        // Update FPS counter
        this.frameCount++;
        this.fpsUpdateTimer += deltaTime;
        if (this.fpsUpdateTimer >= 1000) {
            this.fps = Math.round(this.frameCount * 1000 / this.fpsUpdateTimer);
            this.frameCount = 0;
            this.fpsUpdateTimer = 0;
        }
        
        if (this.gameState === 'playing') {
            this.update(deltaTime);
        }
        
        this.render();
        
        // Track frame performance
        this.performanceStats.frameTime = performance.now() - frameStart;
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    // Game update logic with performance optimizations
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update game timer
        this.gameTimer -= deltaTime;
        
        if (this.gameTimer <= 0) {
            this.endGame();
            return;
        }
        
        // Optimized AI updates with staggered processing
        const playersPerFrame = Math.max(1, Math.ceil(this.players.length / 4)); // Update 1/4 of players per frame
        const startIndex = (this.frameCount % 4) * playersPerFrame;
        const endIndex = Math.min(startIndex + playersPerFrame, this.players.length);
        
        for (let i = startIndex; i < endIndex; i++) {
            const player = this.players[i];
            if (player && !player.isEliminated) {
                player.update(deltaTime, this.gameMap, this.config.gameSpeed, this);
            }
        }
        
        // Update ship animations and probes with normal delta time (speed applied internally)
        this.updateShipAnimations(deltaTime);
        this.updateProbes(deltaTime);
        
        // Update notifications
        this.updateNotifications();
        
        // Throttled heavy operations for better performance
        if (this.frameCount % 45 === 0) { // Every 45 frames (~0.75 seconds)
            this.validateSupplyRoutes();
        }
        if (this.frameCount % 90 === 0) { // Every 90 frames (~1.5 seconds)
            this.processSupplyRoutes(this.config.gameSpeed);
        }
        
        // Check for player elimination (throttled)
        if (this.frameCount % 20 === 0) {
            this.checkPlayerElimination();
        }
        
        // Check win conditions (throttled)
        if (this.frameCount % 30 === 0) {
            this.checkWinConditions();
        }
        
        // Update camera with edge panning
        this.camera.update(deltaTime);
        
        // Edge panning when mouse is near screen edges (desktop only)
        if (this.mousePos && !this.isDragging && !this.isMultiTouch) {
            this.camera.updateEdgePanning(this.mousePos.x, this.mousePos.y, deltaTime);
        }
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    // Comprehensive rendering pipeline with optimizations
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render parallax starfield behind everything
        this.renderParallaxStarfield();
        
        // Render game world with optimizations
        this.renderNebulas();
        this.renderTerritories();
        this.renderConnections();
        this.renderSupplyRoutes();
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        this.renderShipAnimations();
        this.renderProbes();
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    renderUI() {
        if (this.ui) {
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: this.selectedTerritory,
                hoveredTerritory: this.hoveredTerritory,
                mousePos: this.mousePos,
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                probeCount: this.probes.length,
                notifications: this.notifications,
                discoveries: this.discoveries,
                showBonusPanel: this.showBonusPanel
            });
        }
    }
    
    // Territory selection and fleet command handling
    handleTerritorySelection(worldPos) {
        // Find clicked territory
        const clickedTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);
        
        if (!clickedTerritory) {
            this.selectedTerritory = null;
            return;
        }
        
        // Check if we can probe BEFORE changing selection
        console.log(`Click analysis: clicked=${clickedTerritory?.id}, isColonizable=${clickedTerritory?.isColonizable}, selected=${this.selectedTerritory?.id}, selectedOwner=${this.selectedTerritory?.ownerId}, humanPlayer=${this.humanPlayer?.id}`);
        
        // Handle probe launches to colonizable planets
        if (clickedTerritory.isColonizable && this.selectedTerritory && 
            this.selectedTerritory.ownerId === this.humanPlayer.id) {
            
            console.log(`Attempting to probe: from territory ${this.selectedTerritory.id} (armies: ${this.selectedTerritory.armySize}) to planet ${clickedTerritory.id}`);
            this.launchProbe(this.selectedTerritory, clickedTerritory);
            // Keep selection so player can launch multiple probes
            return;
        }
        
        // If clicking on own territory
        if (clickedTerritory.ownerId === this.humanPlayer.id) {
            // If we already have a territory selected and clicking another owned territory
            if (this.selectedTerritory && 
                this.selectedTerritory.ownerId === this.humanPlayer.id &&
                this.selectedTerritory.id !== clickedTerritory.id &&
                this.selectedTerritory.neighbors.includes(clickedTerritory.id)) {
                
                // Transfer half the fleet from selected to clicked territory
                this.transferFleet(this.selectedTerritory, clickedTerritory);
                this.selectedTerritory = null;
                return;
            }
            
            this.selectedTerritory = clickedTerritory;
            return;
        }
        
        // For all other cases (including colonizable planets when no valid selection)
        this.selectedTerritory = clickedTerritory;
    }
}
```

#### Camera.js - Strategic Camera System
```javascript
export class Camera {
    constructor(viewportWidth, viewportHeight) {
        this.x = 0;
        this.y = 0;
        this.zoom = 1;
        this.targetX = 0;
        this.targetY = 0;
        this.targetZoom = 1;
        
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        
        // Enhanced zoom range for strategic gameplay
        this.minZoom = 0.05; // Extreme zoom out for galaxy-wide view
        this.maxZoom = 8.0;   // Close tactical zoom
        
        // Map boundaries
        this.mapWidth = 2000;
        this.mapHeight = 1500;
        
        // Smooth camera interpolation
        this.smoothFactor = 0.08;
        this.zoomSmoothFactor = 0.06;
        
        // Inertial panning system
        this.velocity = { x: 0, y: 0 };
        this.friction = 0.85;
        this.maxVelocity = 8.0;
        
        // Edge panning for RTS-style controls
        this.edgePanSpeed = 200; // pixels per second
        this.edgePanMargin = 50; // pixels from edge to trigger
        
        // Animation system
        this.animationState = {
            active: false,
            startPos: { x: 0, y: 0 },
            targetPos: { x: 0, y: 0 },
            startZoom: 1,
            targetZoom: 1,
            duration: 1000,
            elapsed: 0,
            easing: 'easeInOutCubic'
        };
    }
    
    update(deltaTime) {
        // Handle camera animations
        if (this.animationState.active) {
            this.updateAnimation(deltaTime);
            return;
        }
        
        // Apply velocity for inertial movement
        this.targetX += this.velocity.x;
        this.targetY += this.velocity.y;
        
        // Apply friction to velocity
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        
        // Stop very small velocities
        if (Math.abs(this.velocity.x) < 0.1) this.velocity.x = 0;
        if (Math.abs(this.velocity.y) < 0.1) this.velocity.y = 0;
        
        // Smooth interpolation to target position and zoom
        const deltaX = this.targetX - this.x;
        const deltaY = this.targetY - this.y;
        const deltaZoom = this.targetZoom - this.zoom;
        
        this.x += deltaX * this.smoothFactor;
        this.y += deltaY * this.smoothFactor;
        this.zoom += deltaZoom * this.zoomSmoothFactor;
        
        // Apply constraints
        this.applyConstraints();
    }
    
    updateEdgePanning(mouseX, mouseY, deltaTime) {
        const panSpeed = this.edgePanSpeed * (deltaTime / 1000);
        
        // Check edges and apply panning
        if (mouseX < this.edgePanMargin) {
            this.addVelocity(-panSpeed, 0);
        } else if (mouseX > this.viewportWidth - this.edgePanMargin) {
            this.addVelocity(panSpeed, 0);
        }
        
        if (mouseY < this.edgePanMargin) {
            this.addVelocity(0, -panSpeed);
        } else if (mouseY > this.viewportHeight - this.edgePanMargin) {
            this.addVelocity(0, panSpeed);
        }
    }
    
    addVelocity(vx, vy) {
        this.velocity.x = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.velocity.x + vx));
        this.velocity.y = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.velocity.y + vy));
    }
    
    zoomTo(newZoom, screenX, screenY) {
        const worldPos = this.screenToWorld(screenX, screenY);
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
        
        // Adjust position to zoom towards the specified point
        const newWorldPos = this.screenToWorld(screenX, screenY);
        this.targetX += worldPos.x - newWorldPos.x;
        this.targetY += worldPos.y - newWorldPos.y;
        
        this.applyConstraints();
    }
    
    animateTo(worldX, worldY, zoomLevel = null, duration = 1000) {
        this.animationState = {
            active: true,
            startPos: { x: this.x, y: this.y },
            targetPos: { x: worldX, y: worldY },
            startZoom: this.zoom,
            targetZoom: zoomLevel !== null ? zoomLevel : this.zoom,
            duration: duration,
            elapsed: 0,
            easing: 'easeInOutCubic'
        };
    }
    
    frameRegion(territories, padding = 150) {
        if (!territories || territories.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        territories.forEach(territory => {
            minX = Math.min(minX, territory.x - territory.radius);
            minY = Math.min(minY, territory.y - territory.radius);
            maxX = Math.max(maxX, territory.x + territory.radius);
            maxY = Math.max(maxY, territory.y + territory.radius);
        });
        
        const regionWidth = maxX - minX + padding * 2;
        const regionHeight = maxY - minY + padding * 2;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        const zoomX = this.viewportWidth / regionWidth;
        const zoomY = this.viewportHeight / regionHeight;
        const optimalZoom = Math.min(zoomX, zoomY, this.maxZoom);
        
        this.animateTo(centerX, centerY, optimalZoom, 1500);
    }
}
```

#### GameMap.js - Procedural Galaxy Generation
```javascript
export class GameMap {
    constructor(width, height, config = {}) {
        this.width = width;
        this.height = height;
        this.config = config;
        this.territories = {};
        this.nebulas = [];
        this.connections = [];
        this.game = null; // Reference to main game for AI animations
    }
    
    generateTerritories(count) {
        console.log(`Generating ${count} territories using ${this.config.layout} layout on ${this.width}x${this.height} map...`);
        
        // Generate base positions using Poisson disk sampling
        const positions = this.generatePoissonDiskPositions(count);
        
        // Apply layout-specific modifications
        const finalPositions = this.applyLayoutPattern(positions, this.config.layout);
        
        // Create territory objects
        this.createTerritoryObjects(finalPositions);
        
        // Generate connections based on layout
        this.generateConnections(this.config.layout);
        
        // Generate nebula fields
        this.generateNebulas();
        
        console.log(`Generated ${Object.keys(this.territories).length} territories with ${this.config.layout} layout`);
        console.log(`Generated ${this.nebulas.length} nebula clouds`);
        console.log('All territories are colonizable planets requiring probes');
    }
    
    generatePoissonDiskPositions(count) {
        const positions = [];
        const radius = Math.sqrt((this.width * this.height) / count) / 2;
        const k = 30; // Maximum attempts
        const grid = [];
        const cellSize = radius / Math.sqrt(2);
        const gridWidth = Math.ceil(this.width / cellSize);
        const gridHeight = Math.ceil(this.height / cellSize);
        
        // Initialize grid
        for (let i = 0; i < gridWidth * gridHeight; i++) {
            grid[i] = -1;
        }
        
        // Start with random point
        const firstPoint = {
            x: Math.random() * this.width,
            y: Math.random() * this.height
        };
        positions.push(firstPoint);
        
        const active = [0];
        const gridX = Math.floor(firstPoint.x / cellSize);
        const gridY = Math.floor(firstPoint.y / cellSize);
        grid[gridY * gridWidth + gridX] = 0;
        
        while (active.length > 0 && positions.length < count) {
            const randomIndex = Math.floor(Math.random() * active.length);
            const pointIndex = active[randomIndex];
            const point = positions[pointIndex];
            
            let found = false;
            for (let i = 0; i < k; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = radius + Math.random() * radius;
                const newX = point.x + Math.cos(angle) * distance;
                const newY = point.y + Math.sin(angle) * distance;
                
                if (newX >= 0 && newX < this.width && newY >= 0 && newY < this.height) {
                    const newGridX = Math.floor(newX / cellSize);
                    const newGridY = Math.floor(newY / cellSize);
                    
                    let valid = true;
                    for (let dy = -2; dy <= 2 && valid; dy++) {
                        for (let dx = -2; dx <= 2 && valid; dx++) {
                            const gx = newGridX + dx;
                            const gy = newGridY + dy;
                            if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
                                const gridIndex = gy * gridWidth + gx;
                                if (grid[gridIndex] !== -1) {
                                    const neighbor = positions[grid[gridIndex]];
                                    const dist = Math.hypot(newX - neighbor.x, newY - neighbor.y);
                                    if (dist < radius) {
                                        valid = false;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (valid) {
                        const newPoint = { x: newX, y: newY };
                        positions.push(newPoint);
                        active.push(positions.length - 1);
                        grid[newGridY * gridWidth + newGridX] = positions.length - 1;
                        found = true;
                        break;
                    }
                }
            }
            
            if (!found) {
                active.splice(randomIndex, 1);
            }
        }
        
        return positions;
    }
    
    applyLayoutPattern(positions, layout) {
        switch (layout) {
            case 'clusters':
                return this.generateClusterLayout(positions);
            case 'spiral':
                return this.generateSpiralLayout(positions);
            case 'core':
                return this.generateCoreLayout(positions);
            case 'rings':
                return this.generateRingsLayout(positions);
            case 'binary':
                return this.generateBinaryLayout(positions);
            case 'organic':
            default:
                return this.generateOrganicLayout(positions);
        }
    }
    
    generateOrganicLayout(positions) {
        // Organic distribution with density clustering
        const densityClusters = Math.floor(Math.random() * 8) + 8; // 8-15 clusters
        const clusterCenters = [];
        
        // Generate cluster centers
        for (let i = 0; i < densityClusters; i++) {
            clusterCenters.push({
                x: Math.random() * this.width,
                y: Math.random() * this.height,
                strength: Math.random() * 0.8 + 0.2 // 0.2 to 1.0
            });
        }
        
        // Apply density-based clustering to existing positions
        const clusteredPositions = positions.map(pos => {
            // Find closest cluster center
            let closestCluster = clusterCenters[0];
            let minDistance = Infinity;
            
            clusterCenters.forEach(cluster => {
                const distance = Math.hypot(pos.x - cluster.x, pos.y - cluster.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestCluster = cluster;
                }
            });
            
            // Pull position slightly toward cluster center based on strength
            const pullFactor = closestCluster.strength * 0.15; // Max 15% pull
            const dx = closestCluster.x - pos.x;
            const dy = closestCluster.y - pos.y;
            
            return {
                x: Math.max(50, Math.min(this.width - 50, pos.x + dx * pullFactor)),
                y: Math.max(50, Math.min(this.height - 50, pos.y + dy * pullFactor))
            };
        });
        
        console.log(`Created ${densityClusters} density clusters for natural star formation`);
        return clusteredPositions;
    }
    
    createTerritoryObjects(positions) {
        positions.forEach((pos, index) => {
            const territory = new Territory(index, pos.x, pos.y);
            
            // All territories start as colonizable planets
            territory.isColonizable = true;
            territory.ownerId = null;
            territory.armySize = 0;
            territory.hiddenArmySize = Math.floor(Math.random() * 50) + 1; // 1-50 hidden armies
            
            this.territories[index] = territory;
        });
        
        console.log(`Generated ${positions.length} territories out of ${positions.length} requested using density-based clustering`);
    }
    
    generateNebulas() {
        const nebulaCount = this.config.nebulaCount || 10;
        this.nebulas = [];
        
        for (let i = 0; i < nebulaCount; i++) {
            const nebula = {
                x: Math.random() * this.width,
                y: Math.random() * this.height,
                radius: Math.random() * 120 + 80, // 80-200 radius
                color: `hsl(${280 + Math.random() * 40}, 70%, 50%)`, // Purple hues
                opacity: Math.random() * 0.3 + 0.1, // 0.1-0.4 opacity
                pulseSpeed: Math.random() * 0.02 + 0.01 // Slow pulsing
            };
            this.nebulas.push(nebula);
        }
        
        console.log(`Generated ${nebulaCount} nebula fields (configured: ${this.config.nebulaCount})`);
    }
}
```

#### Territory.js - Individual Territory Logic
```javascript
export class Territory {
    constructor(id, x, y) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.ownerId = null;
        this.armySize = 0;
        this.hiddenArmySize = 0; // For colonizable planets
        
        // Colonization system
        this.isColonizable = true; // All territories start as colonizable
        this.neighbors = [];
        this.hiddenNeighbors = []; // Connections revealed after colonization
        
        // Visual effects
        this.lastCombatFlash = 0;
        this.selectionPulse = 0;
        this.homeSystemFlash = 0;
        
        // Special properties
        this.isThronestar = false;
        this.discoveryBonus = null; // 'factory', 'minerals', 'void_storm', 'ruins'
        
        // Generation rates (affected by discoveries)
        this.baseGenerationRate = 3000; // 3 seconds base
        this.generationMultiplier = 1.0;
        this.lastGeneration = Date.now();
    }
    
    update(deltaTime, gameSpeed = 1.0) {
        if (!this.ownerId || this.isColonizable) return;
        
        // Army generation with discovery bonuses
        const now = Date.now();
        const adjustedRate = this.baseGenerationRate / gameSpeed;
        const effectiveRate = adjustedRate / this.generationMultiplier;
        
        if (now - this.lastGeneration >= effectiveRate) {
            this.armySize++;
            this.lastGeneration = now;
        }
        
        // Update visual effects
        this.selectionPulse += deltaTime * 0.003;
        if (this.selectionPulse > Math.PI * 2) {
            this.selectionPulse = 0;
        }
    }
    
    revealConnections() {
        // Reveal all hidden connections when territory is colonized
        this.neighbors = this.neighbors.concat(this.hiddenNeighbors);
        this.hiddenNeighbors = [];
    }
    
    applyDiscoveryBonus(bonusType) {
        switch (bonusType) {
            case 'factory':
                this.generationMultiplier = 2.0; // 200% generation
                break;
            case 'minerals':
                this.generationMultiplier = 1.5; // 150% generation
                break;
            case 'void_storm':
                this.generationMultiplier = 0.75; // 75% generation
                break;
            case 'ruins':
                // Cosmetic only - no effect
                break;
        }
        this.discoveryBonus = bonusType;
    }
}
```

#### Player.js - AI Player Logic
```javascript
export class Player {
    constructor(id, name, color, type = 'human') {
        this.id = id;
        this.name = name;
        this.color = color;
        this.type = type;
        
        // Game state
        this.territories = [];
        this.armyGenRate = 1; // Armies per second
        this.totalArmies = 0;
        this.territoriesOwned = 0;
        this.isEliminated = false;
        this.score = 0;
        this.throneStarId = null; // ID of this player's throne star
        
        // AI behavior
        this.strategy = this.generateStrategy();
        this.lastAction = 0;
        this.thinkingInterval = Math.random() * 3000 + 2000; // 2-5 seconds between actions
        this.probeChance = 0.2; // 20% chance to probe each turn
        
        // AI state machine
        this.aiState = 'expansion'; // 'expansion', 'consolidation', 'aggressive', 'defensive'
        this.stateTimer = 0;
        this.stateChangeCooldown = 5000; // 5 seconds minimum between state changes
    }
    
    generateStrategy() {
        const strategies = ['aggressive', 'defensive', 'expansionist', 'opportunistic'];
        return strategies[Math.floor(Math.random() * strategies.length)];
    }
    
    update(deltaTime, gameMap, gameSpeed, game) {
        if (this.type === 'human' || this.isEliminated) return;
        
        this.updateStats();
        
        // AI decision making with state machine
        this.updateAIState(deltaTime);
        
        // Throttled AI actions for performance
        const now = Date.now();
        if (now - this.lastAction > this.thinkingInterval) {
            this.makeAIDecision(gameMap, game);
            this.lastAction = now;
            
            // Randomize next thinking interval
            this.thinkingInterval = Math.random() * 3000 + 2000;
        }
    }
    
    updateAIState(deltaTime) {
        this.stateTimer += deltaTime;
        
        if (this.stateTimer > this.stateChangeCooldown) {
            const territoryRatio = this.territories.length / Object.keys(gameMap?.territories || {}).length;
            const armyStrength = this.totalArmies;
            
            // State transitions based on game situation
            if (territoryRatio < 0.1) {
                this.aiState = 'expansion';
            } else if (territoryRatio > 0.3) {
                this.aiState = 'aggressive';
            } else if (armyStrength < 50) {
                this.aiState = 'consolidation';
            } else {
                this.aiState = 'defensive';
            }
            
            this.stateTimer = 0;
        }
    }
    
    makeAIDecision(gameMap, game) {
        if (!gameMap || !game) return;
        
        const myTerritories = this.territories.map(id => gameMap.territories[id]).filter(t => t);
        if (myTerritories.length === 0) return;
        
        // Limit AI actions per update for performance
        const maxActionsPerUpdate = 2;
        let actionsPerformed = 0;
        
        switch (this.aiState) {
            case 'expansion':
                actionsPerformed += this.attemptExpansion(myTerritories, gameMap, game);
                break;
            case 'consolidation':
                actionsPerformed += this.attemptConsolidation(myTerritories, gameMap, game);
                break;
            case 'aggressive':
                actionsPerformed += this.attemptAggression(myTerritories, gameMap, game);
                break;
            case 'defensive':
                actionsPerformed += this.attemptDefense(myTerritories, gameMap, game);
                break;
        }
        
        // Always consider probing for new territories
        if (actionsPerformed < maxActionsPerUpdate && Math.random() < this.probeChance) {
            this.attemptProbeColonization(myTerritories, gameMap, game);
        }
    }
    
    attemptExpansion(myTerritories, gameMap, game) {
        // Focus on acquiring new territories and building economy
        const strongTerritories = myTerritories.filter(t => t.armySize > 15);
        
        for (const territory of strongTerritories) {
            // Look for colonizable planets first
            const colonizableTargets = territory.neighbors
                .map(id => gameMap.territories[id])
                .filter(t => t && t.isColonizable);
            
            if (colonizableTargets.length > 0 && territory.armySize >= 10) {
                const target = colonizableTargets[0];
                game.launchProbe(territory, target);
                console.log(`AI ${this.name} launched probe from territory ${territory.id} to colonizable planet ${target.id}`);
                return 1;
            }
            
            // Then look for weak enemy territories
            const weakEnemies = territory.neighbors
                .map(id => gameMap.territories[id])
                .filter(t => t && t.ownerId !== this.id && t.ownerId !== null && t.armySize < territory.armySize / 2);
            
            if (weakEnemies.length > 0) {
                const target = weakEnemies[0];
                game.attackTerritory(territory, target);
                console.log(`AI ${this.name} attacking territory ${target.id} from ${territory.id}`);
                return 1;
            }
        }
        
        return 0;
    }
    
    updateStats() {
        this.territoriesOwned = this.territories.length;
        this.totalArmies = this.territories.reduce((sum, territoryId) => {
            const territory = gameMap?.territories[territoryId];
            return sum + (territory ? territory.armySize : 0);
        }, 0);
        this.score = this.territoriesOwned * 10 + this.totalArmies;
    }
}
```

### Frontend UI Components (/client/src/components/)

#### GameConfigScreen.tsx - Configuration Interface
```typescript
import { useState } from 'react';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

export interface GameConfig {
  mapSize: number;
  aiPlayerCount: number;
  playerName: string;
  gameSpeed: number;
  layout: string;
  warpLaneDensity: number;
  connectionRange: number;
  nebulaCount: number;
  probeSpeed: number;
  nebulaSlowdown: boolean;
  supplyRoutes: boolean;
  probeColonization: boolean;
}

interface GameConfigScreenProps {
  onStartGame: (config: GameConfig) => void;
  onBack: () => void;
}

export function GameConfigScreen({ onStartGame, onBack }: GameConfigScreenProps) {
  const [mapSize, setMapSize] = useState(80);
  const [aiPlayerCount, setAiPlayerCount] = useState(19);
  const [playerName, setPlayerName] = useState('Player');
  const [gameSpeed, setGameSpeed] = useState(100);
  const [layout, setLayout] = useState('organic');

  const handleStartGame = () => {
    const config: GameConfig = {
      mapSize,
      aiPlayerCount,
      playerName,
      gameSpeed: gameSpeed / 100,
      layout,
      warpLaneDensity: 0.3,
      connectionRange: 200,
      nebulaCount: 10,
      probeSpeed: 25,
      nebulaSlowdown: true,
      supplyRoutes: true,
      probeColonization: true
    };
    
    onStartGame(config);
  };

  const getMapDescription = () => {
    if (mapSize <= 50) return "Small galaxy - quick games";
    if (mapSize <= 80) return "Medium galaxy - balanced gameplay";
    if (mapSize <= 120) return "Large galaxy - epic battles";
    return "Massive galaxy - marathon sessions";
  };

  const getSpeedDescription = () => {
    if (gameSpeed <= 25) return "Ultra Slow - deep strategy";
    if (gameSpeed <= 75) return "Slow - tactical gameplay";
    if (gameSpeed <= 125) return "Normal - balanced pace";
    return "Fast - action-packed";
  };

  const layoutDescriptions = {
    organic: "Natural scattered distribution across the galaxy",
    clusters: "Grouped stellar regions with bridge connections",
    spiral: "Galactic arms with sparse interconnections",
    core: "Dense central core with concentric shells",
    rings: "Concentric stellar rings throughout the galaxy",
    binary: "Two major systems with limited bridges"
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 text-white p-4">
      <div className="max-w-4xl mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold mb-2">Star Throne</h1>
          <p className="text-xl text-slate-300">Configure Your Galaxy</p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Configuration Panel */}
          <Card className="bg-slate-800 border-slate-700">
            <CardHeader>
              <CardTitle>Galaxy Configuration</CardTitle>
              <CardDescription>Customize your strategic experience</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              {/* Player Name */}
              <div>
                <label className="block text-sm font-medium mb-2">Your Name</label>
                <Input
                  value={playerName}
                  onChange={(e) => setPlayerName(e.target.value)}
                  className="bg-slate-700 border-slate-600"
                  placeholder="Enter your name"
                />
              </div>

              {/* Map Size */}
              <div>
                <label className="block text-sm font-medium mb-2">
                  Galaxy Size: {mapSize} systems
                </label>
                <Slider
                  value={[mapSize]}
                  onValueChange={([value]) => setMapSize(value)}
                  min={30}
                  max={150}
                  step={10}
                  className="mb-2"
                />
                <p className="text-sm text-slate-400">{getMapDescription()}</p>
              </div>

              {/* AI Players */}
              <div>
                <label className="block text-sm font-medium mb-2">
                  AI Opponents: {aiPlayerCount}
                </label>
                <Slider
                  value={[aiPlayerCount]}
                  onValueChange={([value]) => setAiPlayerCount(value)}
                  min={5}
                  max={99}
                  step={1}
                  className="mb-2"
                />
                <p className="text-sm text-slate-400">
                  {aiPlayerCount <= 10 && "Few opponents - focused conflicts"}
                  {aiPlayerCount > 10 && aiPlayerCount <= 30 && "Moderate chaos - tactical challenges"}
                  {aiPlayerCount > 30 && aiPlayerCount <= 60 && "High intensity - complex alliances"}
                  {aiPlayerCount > 60 && "Maximum chaos - survival mode"}
                </p>
              </div>

              {/* Game Speed */}
              <div>
                <label className="block text-sm font-medium mb-2">
                  Game Speed: {gameSpeed}%
                </label>
                <Slider
                  value={[gameSpeed]}
                  onValueChange={([value]) => setGameSpeed(value)}
                  min={1}
                  max={200}
                  step={25}
                  className="mb-2"
                />
                <p className="text-sm text-slate-400">{getSpeedDescription()}</p>
              </div>

              {/* Galaxy Layout */}
              <div>
                <label className="block text-sm font-medium mb-2">Galaxy Layout</label>
                <Select value={layout} onValueChange={setLayout}>
                  <SelectTrigger className="bg-slate-700 border-slate-600">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent className="bg-slate-700 border-slate-600">
                    <SelectItem value="organic">Organic</SelectItem>
                    <SelectItem value="clusters">Clusters</SelectItem>
                    <SelectItem value="spiral">Spiral</SelectItem>
                    <SelectItem value="core">Core</SelectItem>
                    <SelectItem value="rings">Rings</SelectItem>
                    <SelectItem value="binary">Binary</SelectItem>
                  </SelectContent>
                </Select>
                <p className="text-sm text-slate-400 mt-1">
                  {layoutDescriptions[layout]}
                </p>
              </div>
            </CardContent>
          </Card>

          {/* Preview Panel */}
          <Card className="bg-slate-800 border-slate-700">
            <CardHeader>
              <CardTitle>Game Preview</CardTitle>
              <CardDescription>Your configured galaxy</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="bg-slate-700 p-4 rounded-lg">
                  <h3 className="font-semibold mb-2">Galaxy Overview</h3>
                  <ul className="text-sm space-y-1 text-slate-300">
                    <li>• {mapSize} star systems to explore</li>
                    <li>• {aiPlayerCount + 1} total players (you + {aiPlayerCount} AI)</li>
                    <li>• {layout} galaxy formation</li>
                    <li>• {gameSpeed}% speed multiplier</li>
                  </ul>
                </div>

                <div className="bg-slate-700 p-4 rounded-lg">
                  <h3 className="font-semibold mb-2">Game Features</h3>
                  <ul className="text-sm space-y-1 text-slate-300">
                    <li>• Probe-based exploration system</li>
                    <li>• Dynamic discovery mechanics</li>
                    <li>• Strategic throne star conquest</li>
                    <li>• Real-time fleet management</li>
                    <li>• Atmospheric nebula effects</li>
                  </ul>
                </div>

                <div className="bg-slate-700 p-4 rounded-lg">
                  <h3 className="font-semibold mb-2">Victory Conditions</h3>
                  <ul className="text-sm space-y-1 text-slate-300">
                    <li>• Capture any enemy throne star</li>
                    <li>• Inherit their entire empire</li>
                    <li>• Survive until time runs out</li>
                    <li>• Control the most territories</li>
                  </ul>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-center gap-4 mt-8">
          <Button 
            onClick={onBack}
            variant="outline"
            size="lg"
            className="border-slate-600 text-slate-300 hover:bg-slate-700"
          >
            Back
          </Button>
          <Button 
            onClick={handleStartGame}
            size="lg"
            className="bg-blue-600 hover:bg-blue-700"
          >
            Launch Galaxy
          </Button>
        </div>
      </div>
    </div>
  );
}
```

#### GameModeSelector.tsx - Main Menu
```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { GameConfigScreen, GameConfig } from './GameConfigScreen';

interface GameModeSelectorProps {
  onModeSelected: (mode: 'single' | 'multiplayer', data?: any) => void;
}

export function GameModeSelector({ onModeSelected }: GameModeSelectorProps) {
  const [showConfig, setShowConfig] = useState(false);

  const handleConfigStart = (config: GameConfig) => {
    onModeSelected('single', {
      playerName: config.playerName,
      aiCount: config.aiPlayerCount,
      mapSize: config.mapSize,
      gameSpeed: config.gameSpeed,
      layout: config.layout
    });
  };

  if (showConfig) {
    return (
      <GameConfigScreen 
        onStartGame={handleConfigStart}
        onBack={() => setShowConfig(false)}
      />
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 text-white flex items-center justify-center p-4">
      <div className="max-w-4xl w-full">
        {/* Title */}
        <div className="text-center mb-12">
          <h1 className="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
            Star Throne
          </h1>
          <p className="text-2xl text-slate-300 mb-2">
            Massive Multiplayer Strategy Game
          </p>
          <p className="text-lg text-slate-400">
            Conquer the galaxy through strategic exploration and tactical warfare
          </p>
        </div>

        {/* Game Mode Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">
          {/* Single Player */}
          <Card className="bg-slate-800 border-slate-700 hover:border-blue-500 transition-all duration-300 cursor-pointer group">
            <CardHeader>
              <CardTitle className="text-2xl group-hover:text-blue-400 transition-colors">
                Single Player
              </CardTitle>
              <CardDescription className="text-lg">
                Battle AI opponents in customizable galaxy
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="text-slate-300 space-y-2 mb-6">
                <li>• Configure galaxy size and AI difficulty</li>
                <li>• Choose from 6 unique galaxy layouts</li>
                <li>• Adjustable game speed (1% - 200%)</li>
                <li>• 5-99 AI opponents with unique strategies</li>
                <li>• Immediate start with full customization</li>
              </ul>
              <Button 
                onClick={() => setShowConfig(true)}
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 text-lg"
                size="lg"
              >
                Configure & Play
              </Button>
            </CardContent>
          </Card>

          {/* Multiplayer */}
          <Card className="bg-slate-800 border-slate-700 hover:border-green-500 transition-all duration-300 cursor-pointer group">
            <CardHeader>
              <CardTitle className="text-2xl group-hover:text-green-400 transition-colors">
                Multiplayer
              </CardTitle>
              <CardDescription className="text-lg">
                Join or create rooms with other players
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="text-slate-300 space-y-2 mb-6">
                <li>• Up to 100 players per game</li>
                <li>• Real-time strategic combat</li>
                <li>• Create private rooms with friends</li>
                <li>• Join quick matches instantly</li>
                <li>• Cross-platform compatible</li>
              </ul>
              <Button 
                onClick={() => onModeSelected('multiplayer')}
                className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 text-lg"
                size="lg"
              >
                Find Players
              </Button>
            </CardContent>
          </Card>
        </div>

        {/* Features */}
        <div className="mt-16 text-center">
          <h2 className="text-2xl font-semibold mb-6 text-slate-200">Key Features</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
              <h3 className="text-lg font-semibold mb-2 text-blue-400">Probe Exploration</h3>
              <p className="text-slate-300">Send probes to discover new worlds and unlock hidden territories</p>
            </div>
            <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
              <h3 className="text-lg font-semibold mb-2 text-purple-400">Strategic Zoom</h3>
              <p className="text-slate-300">Supreme Commander-style camera with tactical to strategic views</p>
            </div>
            <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
              <h3 className="text-lg font-semibold mb-2 text-green-400">Throne Conquest</h3>
              <p className="text-slate-300">Capture enemy throne stars to instantly inherit their empire</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### Backend Server (/server/)

#### index.ts - Express Server Setup
```typescript
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic } from "./vite";
import { createServer } from "http";
import { GameServer } from "./gameServer";

const app = express();
app.use(express.json());

// Create HTTP server for Socket.IO
const server = createServer(app);

// Initialize game server with WebSocket support
const gameServer = new GameServer(server);

app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  const status = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";

  res.status(status).json({ message });
});

async function startServer() {
  const { httpServer } = await registerRoutes(app, server);
  
  const port = Number(process.env.PORT) || 5000;
  httpServer.listen(port, "0.0.0.0", () => {
    console.log(`Server with WebSocket support running on port ${port}`);
  });
}

if (process.env.NODE_ENV === "development") {
  await setupVite(app, server);
} else {
  serveStatic(app);
}

startServer().catch(console.error);
```

#### gameServer.ts - Multiplayer Server Logic
```typescript
import { Server as SocketServer } from 'socket.io';
import { Server } from 'http';
import { GameEngine } from './GameEngine';
import { ClientCommand, GameStateUpdate, CommandType } from '../common/types';

interface Player {
  id: string;
  name: string;
  color: string;
  type: 'human' | 'ai';
  socketId?: string;
  territories: number[];
  armyGenRate: number;
  totalArmies: number;
  territoriesOwned: number;
  isEliminated: boolean;
}

interface GameRoom {
  id: string;
  name: string;
  players: Map<string, Player>;
  gameEngine: GameEngine | null;
  gameLoop: NodeJS.Timeout | null;
  isStarted: boolean;
  maxPlayers: number;
  aiPlayerCount: number;
  gameMode: 'single' | 'multiplayer';
  lastUpdate: number;
  tickRate: number;
}

export class GameServer {
  private io: SocketServer;
  private rooms: Map<string, GameRoom> = new Map();
  private playerToRoom: Map<string, string> = new Map();

  constructor(server: Server) {
    this.io = new SocketServer(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });

    this.setupSocketHandlers();
  }

  private setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`Player connected: ${socket.id}`);

      socket.on('create-room', (data: { roomName: string; playerName: string; gameMode: 'single' | 'multiplayer'; config?: any }) => {
        const roomId = this.generateRoomId();
        
        const room: GameRoom = {
          id: roomId,
          name: data.roomName,
          players: new Map(),
          gameEngine: null,
          gameLoop: null,
          isStarted: false,
          maxPlayers: data.gameMode === 'single' ? 1 : 100,
          aiPlayerCount: data.config?.aiCount || 19,
          gameMode: data.gameMode,
          lastUpdate: Date.now(),
          tickRate: 20 // 20 TPS
        };

        this.rooms.set(roomId, room);
        this.joinRoom(socket, roomId, data.playerName);

        if (data.gameMode === 'single') {
          // Auto-start single player games
          this.startGame(roomId, data.config?.mapSize, data.config?.gameSpeed);
        }

        socket.emit('room-created', { roomId, room: this.getRoomInfo(room) });
      });

      socket.on('join-room', (data: { roomId: string; playerName: string }) => {
        const room = this.rooms.get(data.roomId);
        if (room && !room.isStarted && room.players.size < room.maxPlayers) {
          this.joinRoom(socket, data.roomId, data.playerName);
          socket.emit('room-joined', { roomId: data.roomId, room: this.getRoomInfo(room) });
          this.io.to(data.roomId).emit('room-update', this.getRoomInfo(room));
        } else {
          socket.emit('room-error', { message: 'Room not found or full' });
        }
      });

      socket.on('start-game', (data: { roomId: string; mapSize?: number; gameSpeed?: number }) => {
        const room = this.rooms.get(data.roomId);
        if (room && !room.isStarted) {
          this.startGame(data.roomId, data.mapSize, data.gameSpeed);
        }
      });

      socket.on('player-command', (command: ClientCommand) => {
        const roomId = this.playerToRoom.get(socket.id);
        const room = this.rooms.get(roomId);
        
        if (room && room.gameEngine && room.isStarted) {
          const result = room.gameEngine.executeCommand(socket.id, command);
          
          if (result) {
            // Broadcast command result to all players in room
            this.io.to(roomId).emit('command-result', result);
          }
        }
      });

      socket.on('disconnect', () => {
        console.log(`Player disconnected: ${socket.id}`);
        this.handleDisconnect(socket);
      });
    });
  }

  private joinRoom(socket: any, roomId: string, playerName: string) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    socket.join(roomId);
    this.playerToRoom.set(socket.id, roomId);

    const player: Player = {
      id: socket.id,
      name: playerName,
      color: this.generatePlayerColor(room.players.size),
      type: 'human',
      socketId: socket.id,
      territories: [],
      armyGenRate: 1,
      totalArmies: 0,
      territoriesOwned: 0,
      isEliminated: false
    };

    room.players.set(socket.id, player);
  }

  private startGame(roomId: string, mapSize: number = 200, gameSpeed: number = 1.0) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    // Create game engine with configuration
    room.gameEngine = new GameEngine({
      mapSize: mapSize,
      tickRate: room.tickRate,
      gameSpeed: gameSpeed
    });

    // Add human players
    room.players.forEach((player, id) => {
      room.gameEngine.addPlayer(id, player.name, player.color, 'human');
    });

    // Add AI players for single player mode
    if (room.gameMode === 'single') {
      for (let i = 0; i < room.aiPlayerCount; i++) {
        const aiId = `ai-${i}`;
        const aiName = this.generateAIName(i);
        const aiColor = this.generatePlayerColor(room.players.size + i);
        room.gameEngine.addPlayer(aiId, aiName, aiColor, 'ai');
      }
    }

    // Start the game
    room.gameEngine.startGame();
    room.isStarted = true;

    // Start game loop
    this.startGameLoop(roomId);

    // Notify all players
    this.io.to(roomId).emit('game-started', {
      message: 'Game has started!',
      gameState: room.gameEngine.getGameState()
    });
  }

  private startGameLoop(roomId: string) {
    const room = this.rooms.get(roomId);
    if (!room || !room.gameEngine) return;

    const targetInterval = 1000 / room.tickRate; // 50ms for 20 TPS

    room.gameLoop = setInterval(() => {
      const now = Date.now();
      const deltaTime = now - room.lastUpdate;
      room.lastUpdate = now;

      // Update game state
      room.gameEngine.update(deltaTime);

      // Broadcast state to all players
      this.broadcastGameStateUpdate(roomId, room.gameEngine.getGameState());

      // Check for game end conditions
      const gameState = room.gameEngine.getGameState();
      if (gameState.winner) {
        this.endGame(roomId);
      }
    }, targetInterval);
  }

  private broadcastGameStateUpdate(roomId: string, gameState: any) {
    const update: GameStateUpdate = {
      type: 'FULL_STATE',
      gameState: gameState,
      timestamp: Date.now()
    };

    this.io.to(roomId).emit('game-state-update', update);
  }

  private endGame(roomId: string) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    if (room.gameLoop) {
      clearInterval(room.gameLoop);
      room.gameLoop = null;
    }

    this.io.to(roomId).emit('game-ended', {
      winner: room.gameEngine?.getGameState().winner,
      finalState: room.gameEngine?.getGameState()
    });
  }

  private generateRoomId(): string {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
  }

  private generatePlayerColor(index: number): string {
    const colors = [
      '#00DDFF', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
      '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9', '#F8C471'
    ];
    return colors[index % colors.length];
  }

  private generateAIName(index: number): string {
    const names = [
      'Commander Alpha', 'Admiral Beta', 'General Gamma', 'Captain Delta',
      'Colonel Echo', 'Major Foxtrot', 'Lieutenant Golf', 'Sergeant Hotel'
    ];
    return names[index % names.length];
  }
}
```

### Shared Type Definitions (/common/types/)

#### index.ts - Game State Types
```typescript
export interface PlayerState {
  id: string;
  name: string;
  color: string;
  type: 'human' | 'ai';
  socketId?: string;
  territories: number[];
  armyGenRate: number;
  totalArmies: number;
  territoriesOwned: number;
  isEliminated: boolean;
}

export interface TerritoryState {
  id: number;
  ownerId: string | null;
  armySize: number;
  x: number;
  y: number;
  radius: number;
  neighbors: number[];
  hiddenNeighbors: number[];
  isColonizable: boolean;
  hiddenArmySize: number;
  lastCombatFlash: number;
}

export interface ProbeState {
    id: number;
    fromTerritoryId: number;
    toTerritoryId: number;
    playerId: string;
    playerColor: string;
    progress: number; // 0.0 to 1.0
    startTime: number;
    duration: number;
}

export interface GameState {
    territories: Record<number, TerritoryState>;
    players: Record<string, PlayerState>;
    probes: ProbeState[];
    supplyRoutes: SupplyRoute[];
    gamePhase: 'lobby' | 'playing' | 'ended';
    winner: string | null;
    tick: number;
    lastUpdate: number;
}

export enum CommandType {
    ATTACK_TERRITORY = 'ATTACK_TERRITORY',
    TRANSFER_ARMIES = 'TRANSFER_ARMIES',
    LAUNCH_PROBE = 'LAUNCH_PROBE',
    CREATE_SUPPLY_ROUTE = 'CREATE_SUPPLY_ROUTE',
    SELECT_TERRITORY = 'SELECT_TERRITORY',
}

export interface ClientCommand {
  type: CommandType;
  payload: any;
  timestamp: number;
}

export interface GameStateUpdate {
  type: 'FULL_STATE' | 'DELTA_STATE';
  gameState: Partial<GameState>;
  timestamp: number;
}
```

### Performance Constants (/common/gameConstants.ts)

```typescript
export const GAME_CONSTANTS = {
  // Performance optimizations
  VISIBLE_TERRITORIES_UPDATE_INTERVAL_MS: 100,
  TERRITORY_VISIBILITY_PADDING: 50,
  SHIP_ANIMATION_POOL_SIZE: 100,
  AI_UPDATES_PER_FRAME_DIVISOR: 4,
  
  // Game balance
  DEFAULT_MAP_SIZE_TERRITORIES: 80,
  DEFAULT_SINGLE_PLAYER_AI_COUNT: 19,
  PROBE_FLEET_COST: 10,
  ARMY_GENERATION_RATE_MS: 3000,
  STARTING_ARMIES: 50,
  
  // Discovery system
  HOSTILE_ALIEN_PROBABILITY: 0.15,
  PRECURSOR_TECH_TOTAL_PROBABILITY: 0.30,
  FRIENDLY_DISCOVERY_PROBABILITY: 0.25,
  
  // Camera system
  STRATEGIC_ZOOM_MIN: 0.05,
  TACTICAL_ZOOM_MAX: 8.0,
  EDGE_PAN_SPEED: 200,
  CAMERA_SMOOTH_FACTOR: 0.08
};
```

## BUILD AND DEPLOYMENT CONFIGURATION

### package.json - Dependencies and Scripts
```json
{
  "name": "star-throne",
  "private": true,
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "npm run build:frontend && npm run build:backend",
    "build:frontend": "vite build",
    "build:backend": "esbuild server/index.ts --bundle --platform=node --outfile=dist/server.js",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "@neondatabase/serverless": "^0.10.3",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-select": "^2.1.2",
    "@tanstack/react-query": "^5.59.0",
    "drizzle-orm": "^0.36.1",
    "express": "^4.21.1",
    "express-session": "^1.18.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "tailwindcss": "^3.4.15",
    "typescript": "^5.6.3",
    "vite": "^6.0.1",
    "wouter": "^3.3.5",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/node": "^22.9.0",
    "@types/react": "^18.3.12",
    "@vitejs/plugin-react": "^4.3.3",
    "drizzle-kit": "^0.28.1",
    "esbuild": "^0.24.0",
    "tsx": "^4.19.2"
  }
}
```

### vite.config.ts - Frontend Build Configuration
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./client/src"),
    },
  },
  build: {
    outDir: "dist/public",
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@radix-ui/react-dialog', '@radix-ui/react-slider'],
          game: ['socket.io-client', 'zustand']
        }
      }
    }
  },
  server: {
    proxy: {
      "/api": "http://localhost:5000",
      "/socket.io": {
        target: "http://localhost:5000",
        ws: true
      }
    }
  }
});
```

## CURRENT STATE AND KNOWN ISSUES

### Working Features
- ✅ Probe-based colonization system with discovery mechanics
- ✅ Supreme Commander-style strategic camera with zoom levels
- ✅ Comprehensive fleet command system with modifier keys
- ✅ Real-time multiplayer architecture with WebSocket server
- ✅ Atmospheric parallax starfield and nebula systems
- ✅ Throne star conquest mechanics for instant empire takeover
- ✅ Performance optimizations: viewport culling, object pooling
- ✅ Mobile touch controls with pinch-to-zoom and edge panning
- ✅ Six galaxy layout types: Organic, Clusters, Spiral, Core, Rings, Binary

### Current Issues ("Jankfest")
1. **Probe Selection Bug**: Territory selection gets overwritten before probe logic executes
2. **Notification System**: Discovery notifications not displaying on screen despite being implemented
3. **Territory Selection Conflicts**: Supply routes and fleet transfers interfere with probe commands
4. **Discovery Panel**: Bonus tracking exists but persistent display needs implementation
5. **Mobile Control Conflicts**: Long press, drag, and tap gestures sometimes interfere

### Architecture Strengths
- Clean separation between client game engine and server validation
- Modular component system with well-defined interfaces
- Performance-optimized rendering with culling and pooling
- Scalable multiplayer infrastructure supporting 100+ players
- Comprehensive type safety with shared TypeScript definitions

### Technical Debt
- Mixed JavaScript/TypeScript codebase needs standardization
- Event handling conflicts between different input modes
- UI state management could be more centralized
- Performance monitoring tools need better integration
- Error handling and recovery mechanisms need improvement

## FUTURE ENHANCEMENTS

### Planned Features
- Enhanced discovery system with more bonus types
- Persistent bonus panel showing empire upgrades
- Improved AI with faction-based behaviors
- Campaign mode with progressive difficulty
- Spectator mode for eliminated players
- Replay system for strategy analysis
- Custom galaxy editor for players

### Performance Targets
- Maintain 60 FPS with 100+ players
- Sub-100ms server response times
- Efficient bandwidth usage for mobile players
- Battery optimization for extended mobile sessions

---

This comprehensive codebase represents a sophisticated browser-based strategy game with advanced real-time multiplayer capabilities, strategic camera systems, and complex game mechanics. The current "jankfest" issues are primarily related to event handling conflicts and UI state management, which can be resolved through careful refactoring of the input system and notification display logic.