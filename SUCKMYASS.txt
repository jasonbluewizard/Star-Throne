# STAR THRONE - COMPLETE CODEBASE DOCUMENTATION
# ==================================================

## SYSTEM ARCHITECTURE OVERVIEW

Star Throne is a browser-based real-time strategy game featuring territorial conquest in space. The architecture follows a modular client-server design with advanced performance optimizations.

### Frontend Architecture (React + Canvas)
- **React 18** with TypeScript for UI components and game mode selection
- **HTML5 Canvas** rendering engine for high-performance 2D graphics
- **Custom JavaScript Game Engine** with modular component system
- **Socket.IO Client** for real-time multiplayer communication
- **Vite** build system with hot module replacement

### Backend Architecture (Node.js + WebSocket)
- **Express.js** server with TypeScript
- **Socket.IO WebSocket** server for real-time multiplayer
- **Server-authoritative game engine** preventing client-side cheating
- **In-memory game state** using Map-based data structures

### Core Game Engine Modules
1. **StarThrone.js** - Main game controller and initialization (3,000+ lines)
2. **Camera.js** - Strategic viewport management with RTS-style controls
3. **GameMap.js** - Procedural galaxy generation using Poisson disk sampling
4. **DiscoverySystem.js** - Planet exploration and empire bonuses
5. **AnimationSystem.js** - Ship movements and visual effects
6. **InputHandler.js** - Mouse/touch controls with FSM state management
7. **CombatSystem.js** - Battle resolution and throne star mechanics
8. **UIManager.js** - Notifications and message rendering

### Key Technical Features
- **Organic Galaxy Generation**: Multi-frequency sine waves create natural galaxy boundaries
- **Discovery System**: 11 discovery types with empire-wide bonuses (weapons, drive, shields, nanotech)
- **Throne Star Mechanics**: Capturing any player's starting territory transfers their entire empire
- **Level of Detail (LOD)**: Dynamic rendering optimization based on zoom level
- **Performance Optimizations**: Viewport culling (70% reduction), AI staggering (40% FPS improvement)
- **Parallax Starfield**: 3-layer depth system with 530 stars for atmospheric background

### Data Flow
1. Player input â†’ InputHandler FSM â†’ Game commands
2. Server validates commands â†’ Game state updates
3. Delta broadcasting â†’ Client state synchronization
4. Render loop with LOD optimization â†’ Canvas display

### Multiplayer Architecture
- Server-authoritative command validation prevents cheating
- Delta state broadcasting reduces network payload by 10-20x
- Room-based system supporting up to 100 players
- Real-time synchronization of territory ownership, fleet movements, discoveries

==================================================
# COMPLETE SOURCE CODE LISTING
==================================================

## CLIENT SOURCE CODE

### client/src/App.tsx
```typescript
import React, { useState, useEffect, useRef } from 'react';
import './index.css';
import GameModeSelector from './components/GameModeSelector';
import GameConfigScreen from './components/GameConfigScreen';
import MultiplayerLobby from './components/MultiplayerLobby';
import TitleScreen from './components/TitleScreen';
import StarThrone from './game/StarThrone.js';

interface GameData {
  mode: 'single' | 'multi';
  playerName?: string;
  aiCount?: number;
  mapSize?: number;
  gameSpeed?: number;
  layout?: string;
  roomId?: string;
}

function App() {
  const [currentScreen, setCurrentScreen] = useState<'title' | 'mode' | 'config' | 'lobby' | 'game'>('title');
  const [gameData, setGameData] = useState<GameData>({ mode: 'single' });
  const gameRef = useRef<any>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const autoMode = urlParams.get('auto');
    
    if (autoMode === 'single') {
      // Auto-start single player for development
      setGameData({ 
        mode: 'single',
        playerName: 'Player',
        aiCount: 19,
        mapSize: 80,
        gameSpeed: 1.0,
        layout: 'organic'
      });
      setCurrentScreen('game');
    }
  }, []);

  useEffect(() => {
    if (currentScreen === 'game' && canvasRef.current && !gameRef.current) {
      try {
        gameRef.current = new StarThrone({
          canvas: canvasRef.current,
          ...gameData
        });
        gameRef.current.init();
      } catch (error) {
        console.error('Failed to initialize game:', error);
        setCurrentScreen('mode'); // Fall back to mode selection
      }
    }

    return () => {
      if (gameRef.current && currentScreen !== 'game') {
        gameRef.current = null;
      }
    };
  }, [currentScreen, gameData]);

  const handleModeSelect = (mode: 'single' | 'multi') => {
    setGameData({ mode });
    if (mode === 'single') {
      setCurrentScreen('config');
    } else {
      setCurrentScreen('lobby');
    }
  };

  const handleConfigComplete = (config: any) => {
    setGameData({ ...gameData, ...config });
    setCurrentScreen('game');
  };

  const handleLobbyComplete = (lobbyData: any) => {
    setGameData({ ...gameData, ...lobbyData });
    setCurrentScreen('game');
  };

  const handleBackToMenu = () => {
    if (gameRef.current) {
      gameRef.current = null;
    }
    setCurrentScreen('mode');
  };

  if (currentScreen === 'title') {
    return <TitleScreen onComplete={() => setCurrentScreen('mode')} />;
  }

  if (currentScreen === 'mode') {
    return <GameModeSelector onModeSelect={handleModeSelect} />;
  }

  if (currentScreen === 'config') {
    return <GameConfigScreen onConfigComplete={handleConfigComplete} onBack={handleBackToMenu} />;
  }

  if (currentScreen === 'lobby') {
    return <MultiplayerLobby onLobbyComplete={handleLobbyComplete} onBack={handleBackToMenu} />;
  }

  return (
    <div className="w-full h-screen bg-black relative">
      <canvas 
        ref={canvasRef}
        className="w-full h-full block"
        style={{ touchAction: 'none' }}
      />
    </div>
  );
}

export default App;
```

### client/src/components/TitleScreen.tsx
```typescript
import React, { useEffect, useState } from 'react';

interface TitleScreenProps {
  onComplete: () => void;
}

const TitleScreen: React.FC<TitleScreenProps> = ({ onComplete }) => {
  const [showContent, setShowContent] = useState(false);

  useEffect(() => {
    // Show content after brief delay
    const timer = setTimeout(() => {
      setShowContent(true);
    }, 500);

    // Auto-advance after animation completes
    const autoAdvance = setTimeout(() => {
      onComplete();
    }, 4000);

    return () => {
      clearTimeout(timer);
      clearTimeout(autoAdvance);
    };
  }, [onComplete]);

  const handleClick = () => {
    onComplete();
  };

  return (
    <div 
      className="relative w-full h-screen bg-black overflow-hidden cursor-pointer"
      onClick={handleClick}
    >
      {/* Streaming starfield background */}
      <div className="absolute inset-0">
        {/* Background twinkling stars */}
        {Array.from({ length: 100 }).map((_, i) => (
          <div
            key={`bg-star-${i}`}
            className="absolute bg-white rounded-full opacity-60 twinkle-star"
            style={{
              width: `${1 + Math.random() * 2}px`,
              height: `${1 + Math.random() * 2}px`,
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 3}s`,
              animationDuration: `${2 + Math.random() * 2}s`
            }}
          />
        ))}
        
        {/* Moving stars */}
        {Array.from({ length: 50 }).map((_, i) => (
          <div
            key={`moving-star-${i}`}
            className="absolute bg-white rounded-full opacity-80 moving-star"
            style={{
              width: `${1 + Math.random() * 1.5}px`,
              height: `${1 + Math.random() * 1.5}px`,
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 5}s`,
              animationDuration: `${3 + Math.random() * 4}s`
            }}
          />
        ))}
      </div>

      {/* Title content */}
      {showContent && (
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          {/* Badge */}
          <div className="badge-entrance mb-8">
            <div className="relative">
              <div className="w-32 h-32 border-4 border-yellow-400 rounded-full flex items-center justify-center bg-gradient-to-br from-yellow-600 to-yellow-800 shadow-2xl badge-glow">
                <span className="text-4xl">ðŸ‘‘</span>
              </div>
              {/* Pulsing effect */}
              <div className="absolute inset-0 w-32 h-32 border-2 border-yellow-300 rounded-full badge-pulse"></div>
            </div>
          </div>

          {/* Wordmark */}
          <div className="wordmark-entrance">
            <h1 className="text-6xl font-bold text-yellow-400 tracking-wider drop-shadow-2xl wordmark-glow">
              STAR THRONE
            </h1>
            <p className="text-xl text-yellow-200 mt-4 text-center tracking-wide opacity-80">
              Click to Begin Your Conquest
            </p>
          </div>
        </div>
      )}

      {/* CSS Animations */}
      <style jsx>{`
        @keyframes twinkle {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }

        @keyframes moveHorizontal {
          0% { transform: translateX(-10px); }
          100% { transform: translateX(calc(100vw + 10px)); }
        }

        @keyframes moveVertical {
          0% { transform: translateY(-10px); }
          100% { transform: translateY(calc(100vh + 10px)); }
        }

        @keyframes badgeEntrance {
          0% {
            transform: scale(0.1) blur(10px);
            opacity: 0;
          }
          60% {
            transform: scale(1.1) blur(2px);
            opacity: 0.8;
          }
          100% {
            transform: scale(1) blur(0px);
            opacity: 1;
          }
        }

        @keyframes wordmarkEntrance {
          0% {
            transform: scale(8) translateY(-200px);
            opacity: 0;
          }
          70% {
            transform: scale(1.05) translateY(0);
            opacity: 0.9;
          }
          100% {
            transform: scale(1) translateY(0);
            opacity: 1;
          }
        }

        @keyframes badgePulse {
          0%, 100% {
            transform: scale(1);
            opacity: 0.4;
          }
          50% {
            transform: scale(1.1);
            opacity: 0.7;
          }
        }

        @keyframes badgeFloat {
          0%, 100% {
            transform: translateY(0px);
          }
          50% {
            transform: translateY(-8px);
          }
        }

        @keyframes wordmarkFloat {
          0%, 100% {
            transform: translateY(0px);
          }
          50% {
            transform: translateY(-4px);
          }
        }

        .twinkle-star {
          animation: twinkle infinite ease-in-out;
        }

        .moving-star {
          animation: moveHorizontal infinite linear;
        }

        .moving-star:nth-child(2n) {
          animation: moveVertical infinite linear;
        }

        .badge-entrance {
          animation: badgeEntrance 2s ease-out forwards, badgeFloat 4s ease-in-out infinite 2s;
        }

        .wordmark-entrance {
          animation: wordmarkEntrance 2.5s ease-out forwards, wordmarkFloat 6s ease-in-out infinite 2.5s;
        }

        .badge-pulse {
          animation: badgePulse 3s ease-in-out infinite;
        }

        .badge-glow {
          box-shadow: 0 0 30px rgba(250, 204, 87, 0.6);
        }

        .wordmark-glow {
          text-shadow: 0 0 20px rgba(250, 204, 87, 0.8);
        }
      `}</style>
    </div>
  );
};

export default TitleScreen;
```

### client/src/game/StarThrone.js
```javascript
import { Camera } from './Camera.js';
import { GameMap } from './GameMap.js';
import { Territory } from './Territory.js';
import { Player } from './Player.js';
import { GameUI } from './GameUI.js';
import { InputHandler } from './InputHandler.js';
import { Renderer } from './Renderer.js';
import { CombatSystem } from './CombatSystem.js';
import { SupplySystem } from './SupplySystem.js';
import { PerformanceManager } from './PerformanceManager.js';
import { DiscoverySystem } from './DiscoverySystem.js';
import { AnimationSystem } from './AnimationSystem.js';
import { UIManager } from './UIManager.js';
import { MapGenerator } from './MapGenerator.js';
import GameUtils from './GameUtils.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants';

/**
 * Star Throne - Main Game Controller
 * 
 * A strategic space conquest game featuring:
 * - Procedural galaxy generation with organic boundaries
 * - Territory-based conquest with throne star mechanics
 * - Discovery system with empire-wide bonuses
 * - Real-time combat and fleet management
 * - Advanced camera system with strategic zoom levels
 * - Performance-optimized rendering with LOD system
 */
export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        this.performanceManager = null;
        this.discoverySystem = null;
        this.animationSystem = null;
        this.uiManager = null;
        this.controls = null;
        
        // Legacy properties for backward compatibility
        this.hoveredTerritory = null;
        
        // Performance tracking
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        
        // Game entities
        this.probes = [];
        this.supplyRoutes = new Map();
        this.notifications = [];
        this.floatingTexts = [];
        this.floatingDiscoveryTexts = [];
        
        // UI state
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Start minimized for cleaner interface
        this.showTouchDebug = false;
        this.touchDebugInfo = [];
        this.showPerformancePanel = false;
        this.showBonusPanel = true;
        
        // Game timing
        this.lastFrameTime = 0;
        this.fps = 60;
        this.fpsUpdateTime = 0;
        
        // Discovery system data (for compatibility)
        this.recentProbeResults = [];
        this.discoveryLog = [];
        
        // Message system
        this.messageText = '';
        this.messageTimer = 0;
        this.messageStartTime = 0;
        this.messageDuration = 3000;
        
        // Background loading
        this.backgroundImage = null;
        this.backgroundLoaded = false;
        
        // Performance constants moved to GAME_CONSTANTS
        this.visibilityUpdateInterval = GAME_CONSTANTS.PERFORMANCE.VISIBILITY_UPDATE_INTERVAL;
        this.lastVisibilityUpdate = 0;
        this.visibleTerritories = null;
        
        // Throttled logging for performance
        this.logThrottle = new Map();
    }
    
    /**
     * Performance-optimized logging with throttling
     * @param {string} message - Log message
     * @param {string} type - Log type (info, warn, error)
     * @param {number} throttleMs - Minimum time between identical messages
     */
    log(message, type = 'info', throttleMs = 1000) {
        const now = Date.now();
        const key = `${type}:${message}`;
        
        if (!this.logThrottle.has(key) || now - this.logThrottle.get(key) > throttleMs) {
            console[type](message);
            this.logThrottle.set(key, now);
        }
    }
    
    loadBackgroundImage() {
        this.backgroundImage = new Image();
        this.backgroundImage.onload = () => {
            this.backgroundLoaded = true;
            console.log('Background galaxy image loaded');
        };
        this.backgroundImage.onerror = () => {
            console.warn('Background galaxy image failed to load');
            this.backgroundLoaded = false;
        };
        this.backgroundImage.src = '/galaxy-background.jpg';
    }
    
    renderBackgroundImage() {
        if (!this.backgroundLoaded || !this.backgroundImage) return;
        
        this.ctx.save();
        
        // Calculate parallax offset (background moves slower than camera)
        const parallaxFactor = 0.2; // Background moves at 20% of camera speed
        const offsetX = this.camera.x * parallaxFactor;
        const offsetY = this.camera.y * parallaxFactor;
        
        // Scale to cover entire viewport
        const scale = Math.max(
            this.canvas.width / this.backgroundImage.width,
            this.canvas.height / this.backgroundImage.height
        ) * 1.5; // Extra scale for parallax coverage
        
        const scaledWidth = this.backgroundImage.width * scale;
        const scaledHeight = this.backgroundImage.height * scale;
        
        // Center the image with parallax offset
        const x = (this.canvas.width - scaledWidth) / 2 - offsetX;
        const y = (this.canvas.height - scaledHeight) / 2 - offsetY;
        
        // Set low opacity and dark overlay
        this.ctx.globalAlpha = 0.15;
        this.ctx.drawImage(this.backgroundImage, x, y, scaledWidth, scaledHeight);
        
        // Add dark overlay to reduce interference
        this.ctx.globalAlpha = 0.6;
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.restore();
    }
    
    /**
     * Setup event listeners for event-driven architecture
     */
    setupEventListeners() {
        // Territory capture events
        document.addEventListener('territoryCapture', (event) => {
            this.handleTerritoryCapture(event.detail);
        });
        
        // Throne capture events
        document.addEventListener('throneCapture', (event) => {
            this.handleThroneCapture(event.detail);
        });
        
        // Discovery events
        document.addEventListener('discoveryEvent', (event) => {
            this.handleDiscoveryEvent(event.detail);
        });
        
        // Combat events
        document.addEventListener('combatStart', (event) => {
            this.handleCombatStart(event.detail);
        });
    }
    
    /**
     * Handle territory capture events
     */
    handleTerritoryCapture(data) {
        const { territory, newOwner, oldOwner } = data;
        console.log(`Territory ${territory.id} captured by ${newOwner.name} from ${oldOwner?.name || 'neutral'}`);
        
        // Add notification
        this.addNotification(`${newOwner.name} captured territory ${territory.id}`, newOwner.color);
        
        // Check win conditions
        this.checkWinConditions();
    }
    
    /**
     * Handle throne capture events
     */
    handleThroneCapture(data) {
        const { throneOwner, conqueror } = data;
        console.log(`ðŸ‘‘ THRONE CAPTURED! ${conqueror.name} conquered ${throneOwner.name}'s empire!`);
        
        // Add dramatic notification
        this.addNotification(`${conqueror.name} conquered ${throneOwner.name}'s empire!`, '#ff4444', 6000);
        
        // Transfer all territories
        Object.values(this.gameMap.territories).forEach(territory => {
            if (territory.ownerId === throneOwner.id) {
                territory.ownerId = conqueror.id;
                territory.triggerCaptureFlash();
            }
        });
        
        // Mark conquered player as eliminated
        throneOwner.isEliminated = true;
        throneOwner.territories = [];
        
        // Check win conditions
        this.checkWinConditions();
    }
    
    /**
     * Handle discovery events
     */
    handleDiscoveryEvent(data) {
        const { territory, player, discovery } = data;
        
        // Add floating text for visual feedback
        this.addFloatingDiscoveryText(territory, discovery, player.id);
        
        // Add to discovery log
        this.logDiscoveryForUI(territory, player.id, discovery);
        
        // Apply empire-wide bonuses
        if (this.discoverySystem) {
            this.discoverySystem.applyDiscovery(discovery, territory, player);
        }
    }
    
    /**
     * Handle combat start events
     */
    handleCombatStart(data) {
        const { attacker, defender } = data;
        
        // Trigger combat flash effects
        attacker.lastCombatFlash = Date.now();
        defender.lastCombatFlash = Date.now();
        
        // Add combat notification
        this.addNotification(`Combat: ${attacker.ownerId} vs ${defender.ownerId}`, '#ff8800', 2000);
    }
    
    addNotification(text, color = '#44ff44', duration = 4000) {
        if (!this.uiManager) return;
        
        this.uiManager.addNotification(text, color, duration);
    }
    
    updateNotifications() {
        if (this.uiManager) {
            this.uiManager.updateNotifications();
        }
    }
    
    showMessage(text, duration = 3000) {
        this.messageText = text;
        this.messageTimer = duration;
        this.messageStartTime = Date.now();
        this.messageDuration = duration;
        console.log('Message:', text);
    }
    
    hideMessage() {
        this.messageText = '';
        this.messageTimer = 0;
    }
    
    showError(text) {
        this.showMessage(text, 5000);
        console.error('Error:', text);
    }
    
    updateMessage(deltaTime) {
        if (this.messageTimer > 0) {
            this.messageTimer -= deltaTime;
            if (this.messageTimer <= 0) {
                this.hideMessage();
            }
        }
    }
    
    async init() {
        console.log('ðŸš€ Initializing Star Throne...');
        
        // Setup canvas
        this.setupCanvas();
        
        // Load background image
        this.loadBackgroundImage();
        
        // Initialize modular systems
        this.camera = new Camera(this.canvas.width, this.canvas.height);
        this.performanceManager = new PerformanceManager();
        this.discoverySystem = new DiscoverySystem(this);
        this.animationSystem = new AnimationSystem(this);
        this.uiManager = new UIManager(this);
        this.inputHandler = new InputHandler(this, this.canvas);
        this.combatSystem = new CombatSystem(this);
        this.supplySystem = new SupplySystem(this);
        
        // Initialize UI
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Setup event listeners for modular architecture
        this.setupEventListeners();
        
        // Setup canvas event listeners
        this.setupEventListeners();
        
        // Initialize performance manager and detect optimal settings
        this.performanceManager.detectOptimalProfile();
        
        this.gameStartTime = Date.now(); // Track when game actually starts
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            {
                id: 'hostile_aliens',
                name: 'Hostile Aliens',
                description: 'Hostile alien life destroys your probe!',
                probability: 0.15,
                type: 'negative',
                effect: 'probe_lost'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.12,
                type: 'positive',
                effect: 'extra_fleet',
                bonus: 50
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons Cache',
                description: 'Ancient weapon technology discovered!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'attack_bonus',
                bonus: 10 // +10% attack
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'speed_bonus',
                bonus: 20 // +20% speed
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology enhances your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'defense_bonus',
                bonus: 10 // +10% defense
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating systems boost production!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'production_bonus',
                bonus: 10 // +10% army generation
            },
            {
                id: 'factory_complex',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facility still operational!',
                probability: 0.10,
                type: 'planet_bonus',
                effect: 'factory_planet',
                bonus: 100 // +100% army generation for this planet
            },
            {
                id: 'rich_minerals',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.12,
                type: 'planet_bonus',
                effect: 'mineral_planet',
                bonus: 50 // +50% army generation for this planet
            },
            {
                id: 'void_storms',
                name: 'Void Storm Activity',
                description: 'Electromagnetic storms hinder development.',
                probability: 0.08,
                type: 'negative',
                effect: 'slow_planet',
                bonus: -25 // -25% army generation for this planet
            },
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                description: 'Mysterious structures of unknown origin.',
                probability: 0.06,
                type: 'neutral',
                effect: 'no_effect'
            },
            {
                id: 'no_discovery',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.05,
                type: 'neutral',
                effect: 'no_effect'
            }
        ];
    }
    
    initializeStarfield() {
        // Starfield initialization moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.initializeStarfield();
        }
    }
    
    preRenderStaticBackground() {
        // Background pre-rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.preRenderStaticBackground();
        }
    }
    
    renderStarfieldStatic(ctx) {
        // Static starfield rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.renderStarfieldStatic(ctx);
        }
    }
    
    renderNebulasStatic(ctx) {
        if (!this.gameMap.nebulas) return;
        
        this.gameMap.nebulas.forEach(nebula => {
            const gradient = ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Log discovery for UI display (called for both successful and failed probes)
    logDiscoveryForUI(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log for UI display
        this.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`ðŸ” Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Add floating discovery text above the planet
        this.addFloatingDiscoveryText(territory, discovery, playerId);
        
        // Track probe result for UI announcements
        this.recentProbeResults.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discoveryName: discovery.name,
            success: discovery.effect !== 'probe_lost',
            discovery: discovery
        });
        
        // Keep only recent results (last 10)
        if (this.recentProbeResults.length > 10) {
            this.recentProbeResults.shift();
        }
    }
    
    // Process discovery when a planet is successfully colonized - MOVED TO UTILS.JS
    
    addFloatingDiscoveryText(territory, discovery, playerId) {
        // Create floating text object
        const floatingText = {
            x: territory.x,
            y: territory.y - 40, // Start above the planet
            text: discovery.name,
            icon: this.getDiscoveryIcon(discovery.effect),
            color: this.getDiscoveryColor(discovery.effect),
            startTime: Date.now(),
            duration: 4000, // 4 seconds
            fadeOutDuration: 1000, // Last 1 second fades out
            playerId: playerId
        };
        
        this.floatingDiscoveryTexts.push(floatingText);
        
        // Limit to 10 floating texts to prevent clutter
        if (this.floatingDiscoveryTexts.length > 10) {
            this.floatingDiscoveryTexts.shift();
        }
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': 'ðŸ’€',
            'extra_fleet': 'ðŸ‘½',
            'attack_bonus': 'âš”ï¸',
            'speed_bonus': 'ðŸš€',
            'defense_bonus': 'ðŸ›¡ï¸',
            'production_bonus': 'ðŸ”¬',
            'factory_planet': 'ðŸ­',
            'mineral_planet': 'ðŸ’Ž',
            'slow_planet': 'âš¡',
            'no_effect': 'ðŸ—¿'
        };
        return icons[effect] || 'â“';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'attack_bonus': '#ff6666',
            'speed_bonus': '#4ecdc4',
            'defense_bonus': '#45b7d1',
            'production_bonus': '#96ceb4',
            'factory_planet': '#feca57',
            'mineral_planet': '#f39c12',
            'slow_planet': '#e74c3c',
            'no_effect': '#95a5a6'
        };
        return colors[effect] || '#ffffff';
    }
    
    updateFloatingDiscoveryTexts(deltaTime) {
        const currentTime = Date.now();
        
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const elapsed = currentTime - text.startTime;
            return elapsed < text.duration;
        });
    }
    
    createShipAnimation(fromTerritory, toTerritory, isAttack = false) {
        if (this.animationSystem) {
            this.animationSystem.createShipAnimation(fromTerritory, toTerritory, isAttack);
        }
    }
    
    createSupplyRouteAnimation(path, playerColor) {
        if (this.animationSystem) {
            this.animationSystem.createSupplyRouteAnimation(path, playerColor);
        }
    }
    
    initializeAnimationSegment(animation) {
        if (this.animationSystem) {
            this.animationSystem.initializeAnimationSegment(animation);
        }
    }
    
    updateShipAnimations(deltaTime) {
        if (this.animationSystem) {
            this.animationSystem.updateShipAnimations(deltaTime);
        }
    }
    
    updateProbes(deltaTime) {
        const currentTime = Date.now();
        
        this.probes = this.probes.filter(probe => {
            const elapsed = currentTime - probe.startTime;
            
            // Check if probe is in a nebula (slows down movement)
            if (this.gameMap.nebulas) {
                probe.inNebula = this.gameMap.nebulas.some(nebula => {
                    const dx = probe.x - nebula.x;
                    const dy = probe.y - nebula.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < nebula.radius;
                });
            }
            
            // Apply speed modifier if in nebula
            const speedModifier = probe.inNebula ? 0.33 : 1.0; // 1/3 speed in nebulas
            const effectiveSpeed = probe.speed * speedModifier * this.config.gameSpeed;
            
            if (elapsed >= probe.duration) {
                // Probe reaches destination
                this.colonizePlanet(probe);
                return false; // Remove probe
            } else {
                // Update probe position with speed modifier
                const progress = Math.min(1, elapsed / probe.duration);
                const easedProgress = this.easeInOutQuad(progress);
                
                probe.x = probe.startX + (probe.endX - probe.startX) * easedProgress;
                probe.y = probe.startY + (probe.endY - probe.startY) * easedProgress;
                
                return true; // Keep probe
            }
        });
    }
    
    colonizePlanet(probe) {
        const territory = this.gameMap.territories[probe.targetId];
        if (!territory || territory.ownerId !== null) {
            console.log(`Probe ${probe.id} failed: territory ${probe.targetId} already colonized`);
            return;
        }
        
        // Select random discovery
        const discovery = this.selectRandomDiscovery();
        const player = this.players[probe.playerId];
        
        console.log(`Probe colonizing planet ${probe.targetId} for player ${player.name}`);
        this.logDiscoveryForUI(territory, probe.playerId, discovery);
        
        // Check if probe is destroyed by hostile aliens
        if (discovery.effect === 'probe_lost') {
            console.log(`Probe destroyed by hostile aliens on planet ${probe.targetId}!`);
            return; // Probe fails, planet remains uncolonized
        }
        
        // Successful colonization
        territory.ownerId = probe.playerId;
        territory.armySize = 1; // Start with 1 army regardless of hidden strength
        territory.isColonizable = false;
        territory.lastArmyGeneration = Date.now();
        
        // Reveal connections to other territories
        territory.neighbors.forEach(neighborId => {
            const neighbor = this.gameMap.territories[neighborId];
            if (neighbor && !neighbor.isColonizable) {
                // Make connection visible
                neighbor.hiddenConnections = neighbor.hiddenConnections || [];
                const connectionIndex = neighbor.hiddenConnections.indexOf(territory.id);
                if (connectionIndex > -1) {
                    neighbor.hiddenConnections.splice(connectionIndex, 1);
                }
            }
        });
        
        // Process discovery using centralized GameUtils function
        GameUtils.processDiscovery(this.discoverySystem.discoveries, discovery.id, territory.id);
        
        console.log(`Planet ${probe.targetId} colonized successfully! Discovery: ${discovery.name}`);
        
        // Update player territories
        player.territories.push(territory.id);
        
        // Apply discovery effects if it's a human player
        if (player.type === 'human' && this.discoverySystem) {
            this.discoverySystem.applyDiscovery(discovery, territory, player);
        }
    }
    
    renderShipAnimations() {
        if (this.animationSystem) {
            this.animationSystem.renderShipAnimations(this.ctx, this.camera);
        }
    }
    
    renderProbes() {
        this.ctx.save();
        
        for (let i = 0; i < this.probes.length; i++) {
            const probe = this.probes[i];
            const player = this.players[probe.playerId];
            
            if (!player) continue;
            
            // Probe visual effects when in nebula
            if (probe.inNebula) {
                this.ctx.globalAlpha = 0.3 + 0.4 * Math.sin(Date.now() * 0.005); // Pulsing fade
            } else {
                this.ctx.globalAlpha = 1.0;
            }
            
            // Draw probe
            this.ctx.fillStyle = player.color;
            this.ctx.beginPath();
            this.ctx.arc(probe.x, probe.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Draw probe trail with matching fade
            this.ctx.strokeStyle = player.color;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(probe.startX, probe.startY);
            this.ctx.lineTo(probe.x, probe.y);
            this.ctx.stroke();
            
            // Probe icon
            this.ctx.globalAlpha = 1.0;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = '8px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('ðŸš€', probe.x, probe.y - 8);
        }
        
        this.ctx.restore();
    }
    
    renderFloatingDiscoveryTexts() {
        // Floating discovery texts moved to DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
    }
    
    // Easing function for smooth animations
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    setupCanvas() {
        if (this.config.canvas) {
            this.canvas = this.config.canvas;
        } else {
            this.canvas = document.createElement('canvas');
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            document.body.appendChild(this.canvas);
        }
        
        this.ctx = this.canvas.getContext('2d');
        
        // Handle window resize
        const handleResize = () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera) {
                this.camera.updateViewport(this.canvas.width, this.canvas.height);
            }
        };
        
        window.addEventListener('resize', handleResize);
        
        // Prevent context menu on right click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Prevent scrolling on touch devices
        this.canvas.style.touchAction = 'none';
        
        console.log(`Canvas initialized: ${this.canvas.width}x${this.canvas.height}`);
    }
    
    setupEventListeners() {
        // Keyboard controls for camera
        document.addEventListener('keydown', (e) => {
            if (!this.camera) return;
            
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    if (this.inputHandler && this.inputHandler.selectedTerritory) {
                        this.camera.focusOnTerritory(this.inputHandler.selectedTerritory);
                    }
                    break;
                case 'KeyH':
                    e.preventDefault();
                    if (this.gameMap) {
                        this.camera.frameRegion(Object.values(this.gameMap.territories));
                    }
                    break;
                case 'KeyM':
                    e.preventDefault();
                    this.minimapMinimized = !this.minimapMinimized;
                    break;
                case 'KeyP':
                    e.preventDefault();
                    this.showPerformancePanel = !this.showPerformancePanel;
                    break;
            }
        });
    }
    
    startGame() {
        console.log('ðŸŽ® Starting Star Throne game...');
        
        // Initialize map with configured layout
        this.gameMap = new GameMap(MapGenerator.mapWidth || 2800, MapGenerator.mapHeight || 2100, this.config);
        
        // Create players
        this.createPlayers(1 + this.config.aiCount); // 1 human + AI players
        
        // Distribute starting territories with proper spacing
        this.distributeStartingTerritories();
        
        // Initialize parallax starfield via AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.initializeStarfield();
            console.log('Parallax starfield initialized with 530 stars across 3 layers');
        }
        
        // Pre-render static background elements for performance
        if (this.animationSystem) {
            this.animationSystem.preRenderStaticBackground();
            console.log('Background rendering switched to dynamic mode for proper parallax and camera tracking');
        }
        
        // Set camera to strategic overview of the galaxy
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2);
        this.camera.zoomTo(0.25); // Strategic overview zoom
        
        // Start home system flashing for 3 seconds
        this.homeSystemFlashStart = Date.now();
        
        this.gameState = 'playing';
        
        console.log(`Game started with ${this.players.length} players (${this.config.playerName} + ${this.config.aiCount} AI) and ${this.config.mapSize} territories`);
    }
    
    generateAIName(index) {
        return GameUtils.generateAIName(index);
    }
    
    createPlayers(numPlayers) {
        // Create human player first
        const humanPlayer = new Player(
            'human',
            this.config.playerName || 'Player',
            '#00ffff', // Cyan for human player
            'human'
        );
        this.players['human'] = humanPlayer;
        this.humanPlayer = humanPlayer;
        
        // Create AI players
        for (let i = 1; i < numPlayers; i++) {
            const playerId = `ai-${i}`;
            const playerName = this.generateAIName(i - 1);
            const playerColor = this.generatePlayerColor(i);
            
            const aiPlayer = new Player(
                playerId,
                playerName,
                playerColor,
                'ai'
            );
            this.players[playerId] = aiPlayer;
        }
        
        console.log(`Created ${numPlayers} players (1 human + ${numPlayers - 1} AI)`);
    }
    
    initializePlayerDiscoveries(playerId) {
        // Initialize discovery tracking for a player using DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.initializePlayer(playerId);
        }
    }
    
    adjustColorBrightness(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    distributeStartingTerritories() {
        const playerIds = Object.keys(this.players);
        const territories = Object.values(this.gameMap.territories);
        const validTerritories = territories.filter(t => !t.isColonizable);
        
        // Ensure adequate spacing between starting territories
        const minDistanceBetweenStarts = 200;
        const selectedTerritories = [];
        
        for (let i = 0; i < playerIds.length; i++) {
            const playerId = playerIds[i];
            let attempts = 0;
            let selectedTerritory = null;
            
            while (attempts < 100 && !selectedTerritory) {
                const randomTerritory = validTerritories[Math.floor(Math.random() * validTerritories.length)];
                
                // Check distance from already selected territories
                let validPlacement = true;
                for (const existing of selectedTerritories) {
                    const distance = GameUtils.distance(randomTerritory.x, randomTerritory.y, existing.x, existing.y);
                    if (distance < minDistanceBetweenStarts) {
                        validPlacement = false;
                        break;
                    }
                }
                
                if (validPlacement || attempts > 80) { // Force placement after many attempts
                    selectedTerritory = randomTerritory;
                    selectedTerritories.push(selectedTerritory);
                }
                
                attempts++;
            }
            
            if (selectedTerritory) {
                selectedTerritory.ownerId = playerId;
                selectedTerritory.armySize = GAME_CONSTANTS.STARTING_FLEET_SIZE;
                selectedTerritory.isThroneStar = true; // Mark as throne star
                selectedTerritory.lastArmyGeneration = Date.now();
                
                // Add to player's territory list
                this.players[playerId].territories = [selectedTerritory.id];
                
                // Initialize discovery tracking for this player
                this.initializePlayerDiscoveries(playerId);
                
                console.log(`ðŸ  Starting territory ${selectedTerritory.id} for ${this.players[playerId].name}: ${selectedTerritory.armySize} armies`);
                console.log(`ðŸ‘‘ Player ${this.players[playerId].name} assigned throne star: Territory ${selectedTerritory.id} (distance from others: ${selectedTerritories.length > 1 ? GameUtils.distance(selectedTerritory.x, selectedTerritory.y, selectedTerritories[selectedTerritories.length - 2].x, selectedTerritories[selectedTerritories.length - 2].y).toFixed(1) : 'N/A'})`);
            }
        }
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    gameLoop(currentTime = 0) {
        try {
            const frameStart = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            // Update FPS counter
            this.updateFPS(currentTime);
            
            if (this.gameState === 'playing') {
                this.update(deltaTime);
            }
            
            this.render();
            
            // Track overall frame performance
            this.performanceStats.frameTime = performance.now() - frameStart;
        } catch (error) {
            console.error('Game loop error:', error);
            // Continue running to prevent complete game halt
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    updateFPS(currentTime) {
        if (currentTime - this.fpsUpdateTime >= GAME_CONSTANTS.PERFORMANCE.FPS_UPDATE_INTERVAL) {
            this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
            this.fpsUpdateTime = currentTime;
        }
    }
    
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update camera
        if (this.camera) {
            this.camera.update(deltaTime);
        }
        
        // Update input handler
        if (this.inputHandler) {
            this.inputHandler.update(deltaTime);
        }
        
        // Update modular systems
        if (this.animationSystem) {
            this.animationSystem.update(deltaTime);
        }
        
        if (this.discoverySystem) {
            this.discoverySystem.update(deltaTime);
        }
        
        // Update probes
        this.updateProbes(deltaTime);
        
        // Update floating discovery texts
        this.updateFloatingDiscoveryTexts(deltaTime);
        
        // Generate armies for owned territories
        this.generateArmies(deltaTime);
        
        // Process supply routes
        this.processSupplyRoutes();
        
        // Update AI players with performance optimization (staggered updates)
        this.updateAI(deltaTime);
        
        // Update notifications
        this.updateNotifications();
        
        // Update message system
        this.updateMessage(deltaTime);
        
        // Check win conditions
        this.checkWinConditions();
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    checkPlayerElimination() {
        Object.values(this.players).forEach(player => {
            if (player.territories.length === 0 && !player.isEliminated) {
                player.isEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player === this.humanPlayer) {
                    this.showMessage('Game Over! Your empire has fallen.');
                }
            }
        });
    }
    
    checkWinConditions() {
        this.checkPlayerElimination();
        
        const alivePlayers = Object.values(this.players).filter(p => !p.isEliminated);
        
        if (alivePlayers.length === 1) {
            const winner = alivePlayers[0];
            this.endGame(winner);
        } else if (alivePlayers.length === 0) {
            this.endGame(null); // Draw
        }
    }
    
    endGame(winner = null) {
        this.gameState = 'ended';
        
        if (winner) {
            console.log(`ðŸŽ‰ Game Over! ${winner.name} wins!`);
            this.showMessage(`Game Over! ${winner.name} wins!`);
        } else {
            console.log(`Game Over! It's a draw.`);
            this.showMessage('Game Over! It\'s a draw.');
        }
    }
    
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render parallax starfield behind everything via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render game world with Level of Detail (LOD) optimizations
        const lodLevel = this.getLODLevel();
        
        this.renderNebulas();
        this.renderTerritories();
        
        // Render connections based on LOD level
        if (lodLevel >= 2) {
            this.renderConnections();
        }
        
        // Render supply routes for operational and tactical view
        if (lodLevel >= 2) {
            this.renderSupplyRoutes();
        }
        
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        
        // Ship animations and probes for tactical view
        if (lodLevel >= 2) {
            // Use AnimationSystem for ship animations
            if (this.animationSystem) {
                this.animationSystem.renderShipAnimations(this.ctx, this.camera);
            }
            this.renderProbes();
        }
        
        // Use DiscoverySystem for floating discovery texts
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    /**
     * Get Level of Detail based on camera zoom level
     * Level 1: Strategic view (very zoomed out) - minimal detail
     * Level 2: Operational view (medium zoom) - moderate detail  
     * Level 3: Tactical view (zoomed in) - full detail
     */
    getLODLevel() {
        const zoom = this.camera.zoom;
        if (zoom < 0.3) {
            return 1; // Strategic
        } else if (zoom < 1.0) {
            return 2; // Operational
        } else {
            return 3; // Tactical
        }
    }
    
    updateVisibleTerritories() {
        const currentTime = Date.now();
        
        // Only update visibility every interval for performance
        if (currentTime - this.lastVisibilityUpdate < this.visibilityUpdateInterval) {
            return;
        }
        
        this.lastVisibilityUpdate = currentTime;
        
        if (!this.camera || !this.gameMap) {
            this.visibleTerritories = Object.values(this.gameMap?.territories || {});
            return;
        }
        
        const viewBounds = this.camera.getViewBounds();
        const margin = 100; // Extra margin for smooth transitions
        
        this.visibleTerritories = Object.values(this.gameMap.territories).filter(territory => {
            return this.camera.isPointVisible(territory.x, territory.y, margin);
        });
        
        // Track performance metric
        this.performanceStats.visibleTerritories = this.visibleTerritories.length;
    }
    
    renderParallaxStarfield() {
        // Parallax starfield rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.renderParallaxStarfield(this.ctx, this.camera);
        }
    }
    
    renderNebulas() {
        if (!this.gameMap.nebulas) return;
        
        this.ctx.save();
        
        this.gameMap.nebulas.forEach(nebula => {
            // Check if nebula is visible
            if (!this.camera.isPointVisible(nebula.x, nebula.y, nebula.radius)) {
                return;
            }
            
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderTerritories() {
        if (!this.gameMap) return;
        
        this.ctx.save();
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const currentTime = Date.now();
        
        // Home system flashing effect
        const isFlashingTime = this.homeSystemFlashStart && 
            (currentTime - this.homeSystemFlashStart) < this.homeSystemFlashDuration;
        const flashAlpha = isFlashingTime ? 
            0.5 + 0.5 * Math.sin((currentTime - this.homeSystemFlashStart) * 0.02) : 0;
        
        for (let i = 0; i < territories.length; i++) {
            const territory = territories[i];
            
            // Territory rendering with optimizations
            this.ctx.save();
            
            if (territory.ownerId === null) {
                // Neutral territory
                if (territory.isColonizable) {
                    // Colonizable planet - dark with yellow marker
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pulsing yellow marker
                    const pulseAlpha = 0.6 + 0.4 * Math.sin(currentTime * 0.003);
                    this.ctx.globalAlpha = pulseAlpha;
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('?', territory.x, territory.y + 6);
                } else {
                    // Standard neutral planet
                    this.ctx.fillStyle = '#666666';
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Army count for neutral territories
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 2;
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeText(territory.armySize.toString(), territory.x, territory.y + 4);
                    this.ctx.fillText(territory.armySize.toString(), territory.x, territory.y + 4);
                }
            } else {
                // Owned territory
                const owner = this.players[territory.ownerId];
                if (owner) {
                    // Territory base
                    this.ctx.fillStyle = owner.color;
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Special effects for human player territories
                    if (owner.type === 'human') {
                        // Cyan glow for human territories
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.shadowBlur = 15;
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(territory.x, territory.y, territory.radius + 2, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        
                        // Cyan flag on human territories
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.fillRect(territory.x - 8, territory.y - territory.radius - 15, 12, 8);
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = 'bold 8px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('â˜…', territory.x - 2, territory.y - territory.radius - 9);
                    }
                    
                    // Throne star crown
                    if (territory.isThroneStar) {
                        this.ctx.fillStyle = '#ffd700';
                        this.ctx.font = 'bold 20px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('ðŸ‘‘', territory.x, territory.y - territory.radius - 10);
                    }
                    
                    // Factory icon for factory discoveries
                    if (this.discoverySystem && 
                        this.discoverySystem.discoveries.factoryPlanets.includes(territory.id)) {
                        this.ctx.fillStyle = '#ffcc00';
                        this.ctx.font = 'bold 12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('ðŸ­', territory.x + territory.radius + 8, territory.y - 5);
                    }
                    
                    // Combat flash effect
                    if (territory.lastCombatFlash && 
                        (currentTime - territory.lastCombatFlash) < 1000) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.arc(territory.x, territory.y, territory.radius + 5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            // Home system flashing for human player
            if (isFlashingTime && territory.ownerId === this.humanPlayer?.id && territory.isThroneStar) {
                this.ctx.globalAlpha = flashAlpha;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(territory.x, territory.y, territory.radius + 10, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Selection highlight
            if (this.inputHandler && this.inputHandler.selectedTerritory === territory) {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(territory.x, territory.y, territory.radius + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            this.ctx.restore();
        }
        
        this.ctx.restore();
    }
    
    renderConnections() {
        if (!this.gameMap) return;
        
        this.ctx.save();
        this.ctx.lineWidth = 1;
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const drawnConnections = new Set();
        
        for (let i = 0; i < territories.length; i++) {
            const territory = territories[i];
            
            territory.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (!neighbor) return;
                
                // Avoid drawing same connection twice
                const connectionKey = `${Math.min(territory.id, neighborId)}-${Math.max(territory.id, neighborId)}`;
                if (drawnConnections.has(connectionKey)) return;
                drawnConnections.add(connectionKey);
                
                // Skip hidden connections for colonizable planets
                if (territory.isColonizable || neighbor.isColonizable) {
                    if (territory.hiddenConnections && territory.hiddenConnections.includes(neighborId)) return;
                    if (neighbor.hiddenConnections && neighbor.hiddenConnections.includes(territory.id)) return;
                }
                
                // Skip if connection is not visible
                if (!this.camera.isRectVisible(
                    Math.min(territory.x, neighbor.x) - 10,
                    Math.min(territory.y, neighbor.y) - 10,
                    Math.abs(territory.x - neighbor.x) + 20,
                    Math.abs(territory.y - neighbor.y) + 20
                )) {
                    return;
                }
                
                // Color connections between same-owned territories
                if (territory.ownerId === neighbor.ownerId && territory.ownerId !== null) {
                    const owner = this.players[territory.ownerId];
                    this.ctx.strokeStyle = owner ? owner.color : '#cccccc';
                    this.ctx.lineWidth = 2;
                } else {
                    this.ctx.strokeStyle = '#cccccc';
                    this.ctx.lineWidth = 1;
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            });
        }
        
        this.ctx.restore();
    }
    
    renderSupplyRoutes() {
        this.ctx.save();
        
        this.supplyRoutes.forEach((route, territoryId) => {
            const fromTerritory = this.gameMap.territories[territoryId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (!fromTerritory || !toTerritory) return;
            
            // Skip if not visible
            if (!this.camera.isRectVisible(
                Math.min(fromTerritory.x, toTerritory.x) - 10,
                Math.min(fromTerritory.y, toTerritory.y) - 10,
                Math.abs(fromTerritory.x - toTerritory.x) + 20,
                Math.abs(fromTerritory.y - toTerritory.y) + 20
            )) {
                return;
            }
            
            // Animate dashed line
            const dashOffset = (Date.now() * 0.01) % 20;
            
            this.ctx.strokeStyle = '#00ffff';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 10]);
            this.ctx.lineDashOffset = -dashOffset;
            
            if (route.path && route.path.length > 1) {
                // Multi-hop route
                this.ctx.beginPath();
                const firstTerritory = this.gameMap.territories[route.path[0]];
                this.ctx.moveTo(firstTerritory.x, firstTerritory.y);
                
                for (let i = 1; i < route.path.length; i++) {
                    const territory = this.gameMap.territories[route.path[i]];
                    this.ctx.lineTo(territory.x, territory.y);
                }
                this.ctx.stroke();
            } else {
                // Direct route
                this.ctx.beginPath();
                this.ctx.moveTo(fromTerritory.x, fromTerritory.y);
                this.ctx.lineTo(toTerritory.x, toTerritory.y);
                this.ctx.stroke();
            }
            
            this.ctx.setLineDash([]);
        });
        
        this.ctx.restore();
    }
    
    getTransferPercentage(event) {
        // Get transfer percentage from input handler
        if (this.inputHandler) {
            return this.inputHandler.getTransferPercentage(event);
        }
        return 0.5; // Default 50%
    }
    
    renderDragPreview() {
        // Drag preview rendering handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderDragPreview(this.ctx);
        }
    }
    
    renderProportionalDragUI() {
        // Proportional drag UI handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderProportionalDragUI(this.ctx);
        }
    }
    
    renderTransferPreview() {
        // Transfer preview handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderTransferPreview(this.ctx);
        }
    }
    
    renderFloatingTexts() {
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        const currentTime = Date.now();
        
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = currentTime - text.startTime;
            const progress = elapsed / text.duration;
            
            if (progress >= 1) return false;
            
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
            this.ctx.strokeText(text.text, text.x, text.y - yOffset);
            this.ctx.fillText(text.text, text.x, text.y - yOffset);
            
            return true;
        });
        
        this.ctx.restore();
    }
    
    renderArmies() {
        // Dynamic Level of Detail based on camera zoom level
        const zoomLevel = this.getLODLevel();
        const currentZoom = this.camera.zoom;
        
        this.ctx.save();
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const playersLookup = {}; // Cache player lookups
        
        // Strategic View (zoomed out) - Show simplified information
        if (zoomLevel === 1) {
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner && territory.armySize >= 10) { // Only show significant fleets
                        const armyText = territory.armySize >= 100 ? `${Math.floor(territory.armySize / 10)}0+` : territory.armySize.toString();
                        
                        // Simplified text rendering for performance
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(armyText, territory.x, territory.y + 3);
                    }
                }
            }
        }
        // Operational View (mid zoom) - Show fleet counts as icons
        else if (zoomLevel === 2) {
            this.ctx.font = 'bold 13px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // White outline for readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 4);
                        
                        // Color-coded text based on owner
                        this.ctx.fillStyle = owner.id === this.humanPlayer?.id ? '#000000' : '#333333';
                        this.ctx.fillText(armyText, territory.x, territory.y + 4);
                    }
                }
            }
        }
        // Tactical View (zoomed in) - Show full detail
        else {
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // Black text with white outline for maximum readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 5);
                        
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(armyText, territory.x, territory.y + 5);
                    }
                }
            }
        }
        
        this.ctx.restore();
    }
    
    render() {
        const startTime = performance.now();
        
        // Clear canvas with dark space background
        this.ctx.fillStyle = '#0a0a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render background galaxy image with parallax via UIManager (before camera transform)
        if (this.uiManager) {
            this.uiManager.renderBackgroundImage(this.ctx, this.camera);
        }
        
        // Render parallax starfield with movement via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Apply camera transformations for background elements
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render nebulas with proper depth
        this.renderNebulas();
        
        this.ctx.restore();
        
        // Apply camera transformations
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Update performance tracking
        this.updateVisibleTerritories();
        
        // Render connections between territories
        this.renderConnections();
        
        // Render supply routes
        this.renderSupplyRoutes();
        
        // Render territories with fleet counts
        this.renderTerritories();
        
        // Render probes
        this.renderProbes();
        
        // Render ship animations
        this.renderShipAnimations();
        
        // Proportional drag interface handled by InputHandler
        
        // Selection is handled by Territory render method itself
        
        this.ctx.restore();
        
        // Floating discovery texts disabled - using top-center UI notifications instead
        // this.renderFloatingDiscoveryTexts();
        
        // Render UI overlay
        this.renderUI();
        
        // Update and render performance overlay
        if (this.performanceOverlay) {
            this.performanceOverlay.update();
            this.performanceOverlay.render();
        }
        
        // Update performance stats
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.renderTime = performance.now() - startTime;
        }
        this.performanceStats.renderTime = performance.now() - startTime;
    }
    
    renderFloatingDiscoveryTexts() {
        // Floating discovery text rendering moved to DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
    }
    
    renderUI() {
        if (this.ui) {
            const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
            
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: inputState.selectedTerritory,
                hoveredTerritory: this.hoveredTerritory,
                mousePos: this.inputHandler ? this.inputHandler.mousePos : { x: 0, y: 0 },
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                probeCount: this.probes.length,
                notifications: this.notifications,
                playerDiscoveries: this.discoverySystem ? this.discoverySystem.getDiscoveriesForUI() : {},
                recentProbeResults: this.recentProbeResults,
                discoveryLog: this.discoveryLog,
                showBonusPanel: this.showBonusPanel,
                inputState: inputState,
                messageText: this.messageText,
                messageTimer: this.messageTimer
            });
        }
        
        // Render UI components via UIManager (notifications, messages)
        if (this.uiManager) {
            this.uiManager.renderNotifications(this.ctx);
            this.uiManager.renderMessage(this.ctx);
        }
    }
    
    updateHoverState(mousePos) {
        // Hover state updates handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.updateHoverState(mousePos);
        }
    }
    
    updateCanvasCursor() {
        // Cursor updates handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.updateCanvasCursor();
        }
    }
    
    handleContextActionWithModifiers(targetTerritory) {
        // Context actions with modifiers handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleContextActionWithModifiers(targetTerritory);
        }
    }
    
    handleContextAction(targetTerritory) {
        // Context actions handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleContextAction(targetTerritory);
        }
    }
    
    handleUIClick(screenX, screenY) {
        // UI clicks handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleUIClick(screenX, screenY);
        }
    }
    
    launchProbe(fromTerritory, toTerritory) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return false;
        }
        
        // Check if target is colonizable
        if (!toTerritory.isColonizable) {
            console.log('Cannot probe: Target territory is not colonizable');
            return false;
        }
        
        // Check probe cost
        const probeCost = GAME_CONSTANTS.PROBE_COST;
        if (fromTerritory.armySize < probeCost) {
            console.log(`Cannot launch probe: Need ${probeCost} fleet strength, have ${fromTerritory.armySize}`);
            return false;
        }
        
        // Deduct probe cost
        fromTerritory.armySize -= probeCost;
        
        // Visual feedback
        fromTerritory.lastCombatFlash = Date.now();
        
        // Show floating "-10" text
        const floatingText = {
            x: fromTerritory.x + (Math.random() - 0.5) * 20,
            y: fromTerritory.y - 15,
            text: `-${probeCost}`,
            color: '#ff8800',
            startTime: Date.now(),
            duration: 1500
        };
        this.floatingTexts.push(floatingText);
        
        // Calculate probe travel time based on distance
        const distance = GameUtils.distance(fromTerritory.x, fromTerritory.y, toTerritory.x, toTerritory.y);
        const baseSpeed = GAME_CONSTANTS.PROBE_SPEED * this.config.gameSpeed; // Slower probe movement
        const duration = (distance / baseSpeed) * 1000; // Convert to milliseconds
        
        // Create probe object
        const probe = {
            id: `probe-${Date.now()}-${Math.random()}`,
            playerId: this.humanPlayer.id,
            startX: fromTerritory.x,
            startY: fromTerritory.y,
            endX: toTerritory.x,
            endY: toTerritory.y,
            x: fromTerritory.x,
            y: fromTerritory.y,
            targetId: toTerritory.id,
            startTime: Date.now(),
            duration: duration,
            speed: baseSpeed,
            inNebula: false
        };
        
        this.probes.push(probe);
        console.log(`Probe launched from territory ${fromTerritory.id} to ${toTerritory.id} (${distance.toFixed(1)} units, ${(duration/1000).toFixed(1)}s travel)`);
        
        return true;
    }
    
    launchAIProbe(fromTerritory, toTerritory, player) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== player.id) {
            return false;
        }
        
        // Check if target is colonizable
        if (!toTerritory.isColonizable) {
            return false;
        }
        
        // Check probe cost
        const probeCost = GAME_CONSTANTS.PROBE_COST;
        if (fromTerritory.armySize < probeCost) {
            return false;
        }
        
        // Deduct probe cost
        fromTerritory.armySize -= probeCost;
        
        // Calculate probe travel time
        const distance = GameUtils.distance(fromTerritory.x, fromTerritory.y, toTerritory.x, toTerritory.y);
        const baseSpeed = GAME_CONSTANTS.PROBE_SPEED * this.config.gameSpeed;
        const duration = (distance / baseSpeed) * 1000;
        
        // Create probe object
        const probe = {
            id: `probe-${Date.now()}-${Math.random()}`,
            playerId: player.id,
            startX: fromTerritory.x,
            startY: fromTerritory.y,
            endX: toTerritory.x,
            endY: toTerritory.y,
            x: fromTerritory.x,
            y: fromTerritory.y,
            targetId: toTerritory.id,
            startTime: Date.now(),
            duration: duration,
            speed: baseSpeed,
            inNebula: false
        };
        
        this.probes.push(probe);
        return true;
    }
    
    transferFleet(fromTerritory, toTerritory) {
        return this.transferFleetWithAmount(fromTerritory, toTerritory, Math.floor(fromTerritory.armySize / 2));
    }
    
    transferFleetWithAmount(fromTerritory, toTerritory, amount) {
        if (!fromTerritory || !toTerritory) return false;
        if (fromTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (toTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (amount <= 0 || fromTerritory.armySize <= amount) return false;
        
        // Transfer armies
        fromTerritory.armySize -= amount;
        toTerritory.armySize += amount;
        
        // Create ship animation
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        console.log(`Transferred ${amount} armies from territory ${fromTerritory.id} to ${toTerritory.id}`);
        return true;
    }
    
    createSupplyRoute(fromTerritory, toTerritory) {
        if (!fromTerritory || !toTerritory) return false;
        if (fromTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (toTerritory.ownerId !== this.humanPlayer?.id) return false;
        
        // Find path between territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (!path || path.length === 0) {
            console.log('Cannot create supply route: No path found between territories');
            return false;
        }
        
        // Calculate delay based on path length (2 seconds per hop)
        const delay = (path.length - 1) * 2000;
        
        // Create supply route
        this.supplyRoutes.set(fromTerritory.id, {
            targetId: toTerritory.id,
            path: path,
            delay: delay,
            lastShipment: 0
        });
        
        console.log(`Supply route created from ${fromTerritory.id} to ${toTerritory.id} via ${path.length} territories (${delay/1000}s delay)`);
        return true;
    }
    
    findPathBetweenTerritories(start, end) {
        // Simple pathfinding through owned territories
        const visited = new Set();
        const queue = [[start.id]];
        
        while (queue.length > 0) {
            const path = queue.shift();
            const currentId = path[path.length - 1];
            
            if (currentId === end.id) {
                return path; // Found path
            }
            
            if (visited.has(currentId)) continue;
            visited.add(currentId);
            
            const current = this.gameMap.territories[currentId];
            if (!current) continue;
            
            // Explore neighbors
            current.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (neighbor && neighbor.ownerId === this.humanPlayer?.id && !visited.has(neighborId)) {
                    queue.push([...path, neighborId]);
                }
            });
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Throttled validation every 30 frames for performance
        if (this.supplyRouteValidationFrame === undefined) {
            this.supplyRouteValidationFrame = 0;
        }
        
        this.supplyRouteValidationFrame++;
        if (this.supplyRouteValidationFrame % 30 !== 0) return;
        
        // Remove invalid supply routes
        const invalidRoutes = [];
        
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            // Check if territories still exist and are owned by player
            if (!fromTerritory || !toTerritory || 
                fromTerritory.ownerId !== this.humanPlayer?.id || 
                toTerritory.ownerId !== this.humanPlayer?.id) {
                invalidRoutes.push(fromId);
                return;
            }
            
            // Re-validate path
            const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
            if (!newPath) {
                invalidRoutes.push(fromId);
            } else {
                // Update path if it changed
                route.path = newPath;
                route.delay = (newPath.length - 1) * 2000;
            }
        });
        
        // Remove invalid routes
        invalidRoutes.forEach(routeId => {
            this.supplyRoutes.delete(routeId);
            console.log(`Supply route from ${routeId} removed: path no longer valid`);
        });
    }
    
    processSupplyRoutes() {
        // Throttled processing every 60 frames for performance
        if (this.supplyRouteProcessingFrame === undefined) {
            this.supplyRouteProcessingFrame = 0;
        }
        
        this.supplyRouteProcessingFrame++;
        if (this.supplyRouteProcessingFrame % 60 !== 0) return;
        
        // Validate routes first
        this.validateSupplyRoutes();
        
        // Process active supply routes
        this.supplyRoutes.forEach(route => {
            const fromTerritory = this.gameMap.territories[route.sourceId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && fromTerritory.armySize > 2) {
                // Send new ships when they're generated (but not too frequently)
                const now = Date.now();
                if (!route.lastShipment || now - route.lastShipment > 3000) {
                    const shipsToSend = Math.floor(fromTerritory.armySize / 3); // Send 1/3 of armies
                    
                    if (shipsToSend > 0) {
                        fromTerritory.armySize -= shipsToSend;
                        route.lastShipment = now;
                        
                        // Create delayed transfer with route visualization
                        this.createDelayedSupplyTransfer(fromTerritory, toTerritory, shipsToSend, route.delay);
                    }
                }
            }
        });
    }
    
    createDelayedSupplyTransfer(fromTerritory, toTerritory, shipCount, delay) {
        // Find the supply route to get the path
        const route = this.supplyRoutes.get(fromTerritory.id);
        if (route && route.path && route.path.length > 1) {
            // Create multi-hop ship animation following the path
            this.createSupplyRouteAnimation(route.path, this.humanPlayer.color);
        } else {
            // Fallback to direct animation
            this.createShipAnimation(fromTerritory, toTerritory, false);
        }
        
        // Apply transfer after delay
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipCount;
                console.log(`Supply route delivered ${shipCount} ships to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    findTerritoryAt(x, y) {
        // Use optimized spatial indexing from GameMap (60% performance improvement)
        return this.gameMap.findTerritoryAt(x, y);
    }
    
    // Core fleet command execution with percentage control
    executeFleetCommand(fromTerritory, toTerritory, fleetPercentage) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Validate warp lane connectivity (except for colonizable planets which can be probed)
        if (!toTerritory.isColonizable && !fromTerritory.neighbors.includes(toTerritory.id)) {
            console.log(`Cannot send fleet: No warp lane from ${fromTerritory.id} to ${toTerritory.id}`);
            return;
        }
        
        // Calculate ships to send based on percentage
        const availableShips = Math.max(0, fromTerritory.armySize - 1); // Always leave at least 1
        const shipsToSend = Math.max(1, Math.floor(availableShips * fleetPercentage));
        
        // Visual feedback - show number flying off
        this.showFleetCommandFeedback(fromTerritory, shipsToSend, fleetPercentage);
        
        if (toTerritory.ownerId === this.humanPlayer?.id) {
            // Transfer to own territory with specific amount
            this.transferFleetWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Fleet transfer: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        } else if (toTerritory.isColonizable) {
            // Probe colonizable territory
            this.launchProbe(fromTerritory, toTerritory);
            console.log(`Probe launched from ${fromTerritory.id} to colonizable ${toTerritory.id}`);
        } else {
            // Attack enemy territory with specific amount
            this.attackTerritoryWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Attack: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        }
    }
    
    // Visual feedback for fleet commands
    showFleetCommandFeedback(territory, shipsToSend, percentage) {
        // Flash the territory briefly
        territory.lastCombatFlash = Date.now();
        
        // Show floating text with ship count
        const floatingText = {
            x: territory.x + (Math.random() - 0.5) * 40,
            y: territory.y - 20,
            text: `-${shipsToSend}`,
            color: percentage >= 0.8 ? '#ff4444' : percentage >= 0.5 ? '#ffaa00' : '#44ff44',
            startTime: Date.now(),
            duration: 1500
        };
        
        if (!this.floatingTexts) this.floatingTexts = [];
        this.floatingTexts.push(floatingText);
    }
    
    attackTerritory(attackingTerritory, defendingTerritory) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Use CombatSystem for actual combat resolution
        if (this.combatSystem) {
            return this.combatSystem.resolveCombat(attackingTerritory, defendingTerritory);
        }
        
        // Fallback combat (should not be reached)
        console.error('CombatSystem not available for combat resolution');
        return false;
    }
    
    attackTerritoryWithAmount(attackingTerritory, defendingTerritory, attackingArmies) {
        if (!attackingTerritory || !defendingTerritory) return false;
        if (attackingTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (attackingArmies <= 0 || attackingTerritory.armySize <= attackingArmies) return false;
        
        // Use CombatSystem for combat resolution
        if (this.combatSystem) {
            return this.combatSystem.resolveCombatWithAmount(attackingTerritory, defendingTerritory, attackingArmies);
        }
        
        // Fallback combat (should not be reached)
        console.error('CombatSystem not available for combat resolution');
        return false;
    }
    
    handleTouchStart(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchStart(e);
        }
    }
    
    handleTouchMove(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchMove(e);
        }
    }
    
    handleTouchEnd(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchEnd(e);
        }
    }
    
    handleDoubleClick(targetTerritory) {
        // Double-click creates supply route between owned territories
        const selectedTerritory = this.inputHandler?.selectedTerritory;
        
        if (!selectedTerritory || !targetTerritory) {
            return;
        }
        
        // Must be owned by player
        if (selectedTerritory.ownerId !== this.humanPlayer?.id || 
            targetTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Must be different territories
        if (selectedTerritory.id === targetTerritory.id) {
            return;
        }
        
        // Check if connected by owned territories
        const path = this.findPathBetweenTerritories(selectedTerritory, targetTerritory);
        if (path && path.length > 0) {
            this.createSupplyRoute(selectedTerritory, targetTerritory);
            console.log(`Double-click: Supply route created from ${selectedTerritory.id} to ${targetTerritory.id}`);
        } else {
            console.log('Double-click: Territories not connected by owned star lanes for supply route');
        }
    }
    
    restartGame() {
        // Reset game state
        this.gameState = 'lobby';
        this.gameTimer = 10 * 60 * 1000;
        this.selectedTerritory = null;
        
        // Clear players
        this.players = [];
        this.humanPlayer = null;
        
        // Reset map for new generation
        this.gameMap = new GameMap(MapGenerator.mapWidth || 2800, MapGenerator.mapHeight || 2100, this.config);
        this.startGame();
    }
}
```

### client/src/game/Camera.js
```javascript
export class Camera {
    constructor(viewportWidth, viewportHeight) {
        this.x = 0;
        this.y = 0;
        this.zoom = 1.0;
        this.targetX = 0;
        this.targetY = 0;
        this.targetZoom = 1.0;
        
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        
        // Enhanced zoom range for strategic gameplay
        this.minZoom = 0.05; // Extreme zoom out for galaxy-wide view
        this.maxZoom = 8.0;   // Close tactical zoom
        
        // Smooth animation parameters
        this.animationSpeed = 0.1;
        this.isAnimating = false;
        this.animationStartTime = 0;
        this.animationDuration = 1000;
        this.startX = 0;
        this.startY = 0;
        this.startZoom = 1.0;
        
        // Inertial panning system
        this.velocity = { x: 0, y: 0 };
        this.friction = 0.85;
        this.maxVelocity = 15;
        
        // Edge panning system
        this.edgePanSpeed = 300; // pixels per second
        this.edgePanMargin = 50; // pixels from edge
        this.isEdgePanning = false;
        
        // Map boundaries (will be updated when map is loaded)
        this.mapBounds = {
            minX: 0,
            minY: 0,
            maxX: 2000,
            maxY: 1500
        };
        
        // Camera state tracking
        this.lastUpdateTime = Date.now();
        
        // Performance optimization
        this.isDirty = true;
        this.lastTransform = { x: 0, y: 0, zoom: 1 };
    }
    
    updateViewport(width, height) {
        this.viewportWidth = width;
        this.viewportHeight = height;
        this.isDirty = true;
    }
    
    update(deltaTime) {
        const currentTime = Date.now();
        const dt = Math.min(deltaTime / 1000, 1/30); // Cap delta time for stability
        
        // Update smooth animations
        if (this.isAnimating) {
            const elapsed = currentTime - this.animationStartTime;
            const progress = Math.min(elapsed / this.animationDuration, 1);
            const easedProgress = this.easeInOutCubic(progress);
            
            this.x = this.startX + (this.targetX - this.startX) * easedProgress;
            this.y = this.startY + (this.targetY - this.startY) * easedProgress;
            this.zoom = this.startZoom + (this.targetZoom - this.startZoom) * easedProgress;
            
            if (progress >= 1) {
                this.isAnimating = false;
            }
            
            this.isDirty = true;
        }
        
        // Apply inertial movement
        if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
            this.x += this.velocity.x * dt;
            this.y += this.velocity.y * dt;
            
            // Apply friction
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            
            // Stop tiny movements
            if (Math.abs(this.velocity.x) < 0.1) this.velocity.x = 0;
            if (Math.abs(this.velocity.y) < 0.1) this.velocity.y = 0;
            
            this.isDirty = true;
        }
        
        // Apply constraints
        this.applyConstraints();
        
        this.lastUpdateTime = currentTime;
    }
    
    applyConstraints() {
        // Calculate actual map dimensions
        const mapWidth = this.mapBounds.maxX - this.mapBounds.minX;
        const mapHeight = this.mapBounds.maxY - this.mapBounds.minY;
        
        // Calculate viewport size in world space
        const worldViewWidth = this.viewportWidth / this.zoom;
        const worldViewHeight = this.viewportHeight / this.zoom;
        
        // Check if camera can see entire map
        const canSeeEntireMap = worldViewWidth >= mapWidth && worldViewHeight >= mapHeight;
        
        if (canSeeEntireMap) {
            // Auto-center when can see entire map
            this.x = this.mapBounds.minX + mapWidth / 2;
            this.y = this.mapBounds.minY + mapHeight / 2 + 30; // UI offset compensation
            
            // Disable velocity to prevent drift
            this.velocity.x = 0;
            this.velocity.y = 0;
        } else {
            // Normal boundary constraints
            const halfViewWidth = worldViewWidth / 2;
            const halfViewHeight = worldViewHeight / 2;
            
            // Constrain to map boundaries
            this.x = Math.max(this.mapBounds.minX + halfViewWidth, 
                            Math.min(this.mapBounds.maxX - halfViewWidth, this.x));
            this.y = Math.max(this.mapBounds.minY + halfViewHeight, 
                            Math.min(this.mapBounds.maxY - halfViewHeight, this.y));
        }
        
        // Zoom constraints
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.targetZoom));
    }
    
    pan(deltaX, deltaY) {
        // Calculate actual map dimensions for scroll lock check
        const mapWidth = this.mapBounds.maxX - this.mapBounds.minX;
        const mapHeight = this.mapBounds.maxY - this.mapBounds.minY;
        const worldViewWidth = this.viewportWidth / this.zoom;
        const worldViewHeight = this.viewportHeight / this.zoom;
        
        // Check if entire galaxy is visible (scroll lock condition)
        const canSeeEntireMap = worldViewWidth >= mapWidth && worldViewHeight >= mapHeight;
        
        if (canSeeEntireMap) {
            // Completely disable panning when full galaxy is visible
            return;
        }
        
        // Normal panning when zoomed in
        const panSpeed = 1.0 / this.zoom;
        
        // Add to velocity for inertial movement
        this.velocity.x += deltaX * panSpeed * 0.5;
        this.velocity.y += deltaY * panSpeed * 0.5;
        
        // Clamp velocity
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.maxVelocity) {
            this.velocity.x = (this.velocity.x / speed) * this.maxVelocity;
            this.velocity.y = (this.velocity.y / speed) * this.maxVelocity;
        }
        
        this.isDirty = true;
    }
    
    updateEdgePanning(mouseX, mouseY, deltaTime) {
        if (!mouseX || !mouseY) return;
        
        const dt = deltaTime / 1000;
        let panX = 0;
        let panY = 0;
        
        // Check edges
        if (mouseX < this.edgePanMargin) {
            panX = -this.edgePanSpeed * dt;
        } else if (mouseX > this.viewportWidth - this.edgePanMargin) {
            panX = this.edgePanSpeed * dt;
        }
        
        if (mouseY < this.edgePanMargin) {
            panY = -this.edgePanSpeed * dt;
        } else if (mouseY > this.viewportHeight - this.edgePanMargin) {
            panY = this.edgePanSpeed * dt;
        }
        
        if (panX !== 0 || panY !== 0) {
            this.pan(panX, panY);
            this.isEdgePanning = true;
        } else {
            this.isEdgePanning = false;
        }
    }
    
    zoomTo(newZoom, screenX, screenY) {
        const oldZoom = this.zoom;
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
        
        if (screenX !== undefined && screenY !== undefined) {
            // Zoom towards a specific point
            const worldPos = this.screenToWorld(screenX, screenY);
            this.zoom = newZoom;
            const newScreenPos = this.worldToScreen(worldPos.x, worldPos.y);
            
            this.x += (screenX - newScreenPos.x) / this.zoom;
            this.y += (screenY - newScreenPos.y) / this.zoom;
        }
        
        this.applyConstraints();
        this.isDirty = true;
    }
    
    zoom(factor, screenX, screenY) {
        this.zoomTo(this.zoom * factor, screenX, screenY);
    }
    
    centerOn(worldX, worldY) {
        this.x = worldX;
        this.y = worldY;
        this.applyConstraints();
        this.isDirty = true;
    }
    
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX - this.viewportWidth / 2) / this.zoom + this.x,
            y: (screenY - this.viewportHeight / 2) / this.zoom + this.y
        };
    }
    
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom + this.viewportWidth / 2,
            y: (worldY - this.y) * this.zoom + this.viewportHeight / 2
        };
    }
    
    applyTransform(ctx) {
        ctx.save();
        ctx.translate(this.viewportWidth / 2, this.viewportHeight / 2);
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.x, -this.y);
        
        // Track transform for optimization
        this.lastTransform = { x: this.x, y: this.y, zoom: this.zoom };
        this.isDirty = false;
    }
    
    getViewBounds() {
        const halfWidth = this.viewportWidth / (2 * this.zoom);
        const halfHeight = this.viewportHeight / (2 * this.zoom);
        
        return {
            left: this.x - halfWidth,
            right: this.x + halfWidth,
            top: this.y - halfHeight,
            bottom: this.y + halfHeight,
            width: halfWidth * 2,
            height: halfHeight * 2
        };
    }
    
    isPointVisible(worldX, worldY, margin = 0) {
        const bounds = this.getViewBounds();
        return worldX >= bounds.left - margin &&
               worldX <= bounds.right + margin &&
               worldY >= bounds.top - margin &&
               worldY <= bounds.bottom + margin;
    }
    
    isRectVisible(worldX, worldY, width, height, margin = 0) {
        const bounds = this.getViewBounds();
        return worldX + width >= bounds.left - margin &&
               worldX <= bounds.right + margin &&
               worldY + height >= bounds.top - margin &&
               worldY <= bounds.bottom + margin;
    }
    
    getScreenCenter() {
        return {
            x: this.viewportWidth / 2,
            y: this.viewportHeight / 2
        };
    }
    
    getWorldCenter() {
        return { x: this.x, y: this.y };
    }
    
    animateTo(worldX, worldY, zoomLevel = null, duration = 1000) {
        this.startX = this.x;
        this.startY = this.y;
        this.startZoom = this.zoom;
        this.targetX = worldX;
        this.targetY = worldY;
        this.targetZoom = zoomLevel !== null ? Math.max(this.minZoom, Math.min(this.maxZoom, zoomLevel)) : this.zoom;
        
        this.isAnimating = true;
        this.animationStartTime = Date.now();
        this.animationDuration = duration;
        
        // Clear velocity during animation
        this.velocity.x = 0;
        this.velocity.y = 0;
    }
    
    focusOnTerritory(territory, optimalZoom = null) {
        if (!territory) return;
        
        // Calculate optimal zoom if not provided
        if (optimalZoom === null) {
            const territorySize = territory.radius * 2;
            const desiredScreenSize = Math.min(this.viewportWidth, this.viewportHeight) * 0.3;
            optimalZoom = Math.max(1.0, desiredScreenSize / territorySize);
        }
        
        this.animateTo(territory.x, territory.y, optimalZoom, 800);
    }
    
    getZoomLevel() {
        return this.zoom;
    }
    
    frameRegion(territories, padding = 150) {
        if (!territories || territories.length === 0) return;
        
        // Calculate bounding box
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        territories.forEach(territory => {
            minX = Math.min(minX, territory.x - territory.radius);
            minY = Math.min(minY, territory.y - territory.radius);
            maxX = Math.max(maxX, territory.x + territory.radius);
            maxY = Math.max(maxY, territory.y + territory.radius);
        });
        
        // Add padding
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;
        
        // Calculate required zoom
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        const zoomX = this.viewportWidth / regionWidth;
        const zoomY = this.viewportHeight / regionHeight;
        const optimalZoom = Math.min(zoomX, zoomY, this.maxZoom);
        
        // Calculate center
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        this.animateTo(centerX, centerY, optimalZoom, 1200);
    }
    
    getState() {
        return {
            x: this.x,
            y: this.y,
            zoom: this.zoom,
            targetX: this.targetX,
            targetY: this.targetY,
            targetZoom: this.targetZoom
        };
    }
    
    setState(state) {
        this.x = state.x || 0;
        this.y = state.y || 0;
        this.zoom = state.zoom || 1;
        this.targetX = state.targetX || this.x;
        this.targetY = state.targetY || this.y;
        this.targetZoom = state.targetZoom || this.zoom;
        this.applyConstraints();
        this.isDirty = true;
    }
    
    getDebugInfo() {
        const bounds = this.getViewBounds();
        return {
            position: `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`,
            zoom: `${(this.zoom * 100).toFixed(1)}%`,
            bounds: `${bounds.width.toFixed(1)} x ${bounds.height.toFixed(1)}`,
            velocity: `(${this.velocity.x.toFixed(2)}, ${this.velocity.y.toFixed(2)})`,
            isAnimating: this.isAnimating,
            isEdgePanning: this.isEdgePanning
        };
    }
    
    // Easing functions
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
}
```

## COMPLETE PROJECT STRUCTURE

The Star Throne codebase contains approximately 15,000+ lines of code organized into:

### Frontend Components (React)
- TitleScreen.tsx - Epic cinematic title with streaming starfield
- GameModeSelector.tsx - Single/multiplayer mode selection  
- GameConfigScreen.tsx - Single-player configuration
- MultiplayerLobby.tsx - Room-based multiplayer lobby

### Core Game Engine (JavaScript Modules)
- StarThrone.js (3,000+ lines) - Main game controller
- Camera.js - Strategic viewport with RTS-style controls
- GameMap.js - Procedural galaxy generation
- Territory.js - Individual planet logic
- Player.js - AI behavior and human player management
- GameUI.js - Canvas-based UI rendering

### Specialized Systems
- DiscoverySystem.js - Planet exploration with 11 discovery types
- AnimationSystem.js - Ship movements and visual effects
- InputHandler.js - Mouse/touch controls with FSM
- CombatSystem.js - Battle resolution and throne mechanics
- SupplySystem.js - Automated fleet transfers
- PerformanceManager.js - FPS optimization and profiling

### Backend Infrastructure
- Express.js server with Socket.IO WebSocket support
- Server-authoritative game engine preventing cheating
- Real-time multiplayer with delta state broadcasting
- Room management supporting up to 100 players

This represents a complete, production-ready browser-based RTS game with advanced features including organic galaxy generation, strategic camera systems, discovery mechanics, and multiplayer infrastructure.