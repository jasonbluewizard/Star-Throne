# STAR THRONE - COMPLETE CODEBASE DOCUMENTATION
# ==================================================

## SYSTEM ARCHITECTURE OVERVIEW

Star Throne is a browser-based real-time strategy game featuring territorial conquest in space. The architecture follows a modular client-server design with advanced performance optimizations.

### Frontend Architecture (React + Canvas)
- **React 18** with TypeScript for UI components and game mode selection
- **HTML5 Canvas** rendering engine for high-performance 2D graphics
- **Custom JavaScript Game Engine** with modular component system
- **Socket.IO Client** for real-time multiplayer communication
- **Vite** build system with hot module replacement

### Backend Architecture (Node.js + WebSocket)
- **Express.js** server with TypeScript
- **Socket.IO WebSocket** server for real-time multiplayer
- **Server-authoritative game engine** preventing client-side cheating
- **In-memory game state** using Map-based data structures

### Core Game Engine Modules
1. **StarThrone.js** - Main game controller and initialization (3,000+ lines)
2. **Camera.js** - Strategic viewport management with RTS-style controls
3. **GameMap.js** - Procedural galaxy generation using Poisson disk sampling
4. **DiscoverySystem.js** - Planet exploration and empire bonuses
5. **AnimationSystem.js** - Ship movements and visual effects
6. **InputHandler.js** - Mouse/touch controls with FSM state management
7. **CombatSystem.js** - Battle resolution and throne star mechanics
8. **UIManager.js** - Notifications and message rendering

### Key Technical Features
- **Organic Galaxy Generation**: Multi-frequency sine waves create natural galaxy boundaries
- **Discovery System**: 11 discovery types with empire-wide bonuses (weapons, drive, shields, nanotech)
- **Throne Star Mechanics**: Capturing any player's starting territory transfers their entire empire
- **Level of Detail (LOD)**: Dynamic rendering optimization based on zoom level
- **Performance Optimizations**: Viewport culling (70% reduction), AI staggering (40% FPS improvement)
- **Parallax Starfield**: 3-layer depth system with 530 stars for atmospheric background

### Data Flow
1. Player input → InputHandler FSM → Game commands
2. Server validates commands → Game state updates
3. Delta broadcasting → Client state synchronization
4. Render loop with LOD optimization → Canvas display

### Multiplayer Architecture
- Server-authoritative command validation prevents cheating
- Delta state broadcasting reduces network payload by 10-20x
- Room-based system supporting up to 100 players
- Real-time synchronization of territory ownership, fleet movements, discoveries

==================================================
# COMPLETE SOURCE CODE LISTING
==================================================

## CLIENT SOURCE CODE

### client/src/App.tsx
```typescript
import React, { useState, useEffect, useRef } from 'react';
import './index.css';
import GameModeSelector from './components/GameModeSelector';
import GameConfigScreen from './components/GameConfigScreen';
import MultiplayerLobby from './components/MultiplayerLobby';
import TitleScreen from './components/TitleScreen';
import StarThrone from './game/StarThrone.js';

interface GameData {
  mode: 'single' | 'multi';
  playerName?: string;
  aiCount?: number;
  mapSize?: number;
  gameSpeed?: number;
  layout?: string;
  roomId?: string;
}

function App() {
  const [currentScreen, setCurrentScreen] = useState<'title' | 'mode' | 'config' | 'lobby' | 'game'>('title');
  const [gameData, setGameData] = useState<GameData>({ mode: 'single' });
  const gameRef = useRef<any>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const autoMode = urlParams.get('auto');
    
    if (autoMode === 'single') {
      // Auto-start single player for development
      setGameData({ 
        mode: 'single',
        playerName: 'Player',
        aiCount: 19,
        mapSize: 80,
        gameSpeed: 1.0,
        layout: 'organic'
      });
      setCurrentScreen('game');
    }
  }, []);

  useEffect(() => {
    if (currentScreen === 'game' && canvasRef.current && !gameRef.current) {
      try {
        gameRef.current = new StarThrone({
          canvas: canvasRef.current,
          ...gameData
        });
        gameRef.current.init();
      } catch (error) {
        console.error('Failed to initialize game:', error);
        setCurrentScreen('mode'); // Fall back to mode selection
      }
    }

    return () => {
      if (gameRef.current && currentScreen !== 'game') {
        gameRef.current = null;
      }
    };
  }, [currentScreen, gameData]);

  const handleModeSelect = (mode: 'single' | 'multi') => {
    setGameData({ mode });
    if (mode === 'single') {
      setCurrentScreen('config');
    } else {
      setCurrentScreen('lobby');
    }
  };

  const handleConfigComplete = (config: any) => {
    setGameData({ ...gameData, ...config });
    setCurrentScreen('game');
  };

  const handleLobbyComplete = (lobbyData: any) => {
    setGameData({ ...gameData, ...lobbyData });
    setCurrentScreen('game');
  };

  const handleBackToMenu = () => {
    if (gameRef.current) {
      gameRef.current = null;
    }
    setCurrentScreen('mode');
  };

  if (currentScreen === 'title') {
    return <TitleScreen onComplete={() => setCurrentScreen('mode')} />;
  }

  if (currentScreen === 'mode') {
    return <GameModeSelector onModeSelect={handleModeSelect} />;
  }

  if (currentScreen === 'config') {
    return <GameConfigScreen onConfigComplete={handleConfigComplete} onBack={handleBackToMenu} />;
  }

  if (currentScreen === 'lobby') {
    return <MultiplayerLobby onLobbyComplete={handleLobbyComplete} onBack={handleBackToMenu} />;
  }

  return (
    <div className="w-full h-screen bg-black relative">
      <canvas 
        ref={canvasRef}
        className="w-full h-full block"
        style={{ touchAction: 'none' }}
      />
    </div>
  );
}

export default App;
```

### client/src/components/TitleScreen.tsx
```typescript
import React, { useEffect, useState } from 'react';

interface TitleScreenProps {
  onComplete: () => void;
}

const TitleScreen: React.FC<TitleScreenProps> = ({ onComplete }) => {
  const [showContent, setShowContent] = useState(false);

  useEffect(() => {
    // Show content after brief delay
    const timer = setTimeout(() => {
      setShowContent(true);
    }, 500);

    // Auto-advance after animation completes
    const autoAdvance = setTimeout(() => {
      onComplete();
    }, 4000);

    return () => {
      clearTimeout(timer);
      clearTimeout(autoAdvance);
    };
  }, [onComplete]);

  const handleClick = () => {
    onComplete();
  };

  return (
    <div 
      className="relative w-full h-screen bg-black overflow-hidden cursor-pointer"
      onClick={handleClick}
    >
      {/* Streaming starfield background */}
      <div className="absolute inset-0">
        {/* Background twinkling stars */}
        {Array.from({ length: 100 }).map((_, i) => (
          <div
            key={`bg-star-${i}`}
            className="absolute bg-white rounded-full opacity-60 twinkle-star"
            style={{
              width: `${1 + Math.random() * 2}px`,
              height: `${1 + Math.random() * 2}px`,
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 3}s`,
              animationDuration: `${2 + Math.random() * 2}s`
            }}
          />
        ))}
        
        {/* Moving stars */}
        {Array.from({ length: 50 }).map((_, i) => (
          <div
            key={`moving-star-${i}`}
            className="absolute bg-white rounded-full opacity-80 moving-star"
            style={{
              width: `${1 + Math.random() * 1.5}px`,
              height: `${1 + Math.random() * 1.5}px`,
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 5}s`,
              animationDuration: `${3 + Math.random() * 4}s`
            }}
          />
        ))}
      </div>

      {/* Title content */}
      {showContent && (
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          {/* Badge */}
          <div className="badge-entrance mb-8">
            <div className="relative">
              <div className="w-32 h-32 border-4 border-yellow-400 rounded-full flex items-center justify-center bg-gradient-to-br from-yellow-600 to-yellow-800 shadow-2xl badge-glow">
                <span className="text-4xl">👑</span>
              </div>
              {/* Pulsing effect */}
              <div className="absolute inset-0 w-32 h-32 border-2 border-yellow-300 rounded-full badge-pulse"></div>
            </div>
          </div>

          {/* Wordmark */}
          <div className="wordmark-entrance">
            <h1 className="text-6xl font-bold text-yellow-400 tracking-wider drop-shadow-2xl wordmark-glow">
              STAR THRONE
            </h1>
            <p className="text-xl text-yellow-200 mt-4 text-center tracking-wide opacity-80">
              Click to Begin Your Conquest
            </p>
          </div>
        </div>
      )}

      {/* CSS Animations */}
      <style jsx>{`
        @keyframes twinkle {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }

        @keyframes moveHorizontal {
          0% { transform: translateX(-10px); }
          100% { transform: translateX(calc(100vw + 10px)); }
        }

        @keyframes moveVertical {
          0% { transform: translateY(-10px); }
          100% { transform: translateY(calc(100vh + 10px)); }
        }

        @keyframes badgeEntrance {
          0% {
            transform: scale(0.1) blur(10px);
            opacity: 0;
          }
          60% {
            transform: scale(1.1) blur(2px);
            opacity: 0.8;
          }
          100% {
            transform: scale(1) blur(0px);
            opacity: 1;
          }
        }

        @keyframes wordmarkEntrance {
          0% {
            transform: scale(8) translateY(-200px);
            opacity: 0;
          }
          70% {
            transform: scale(1.05) translateY(0);
            opacity: 0.9;
          }
          100% {
            transform: scale(1) translateY(0);
            opacity: 1;
          }
        }

        @keyframes badgePulse {
          0%, 100% {
            transform: scale(1);
            opacity: 0.4;
          }
          50% {
            transform: scale(1.1);
            opacity: 0.7;
          }
        }

        @keyframes badgeFloat {
          0%, 100% {
            transform: translateY(0px);
          }
          50% {
            transform: translateY(-8px);
          }
        }

        @keyframes wordmarkFloat {
          0%, 100% {
            transform: translateY(0px);
          }
          50% {
            transform: translateY(-4px);
          }
        }

        .twinkle-star {
          animation: twinkle infinite ease-in-out;
        }

        .moving-star {
          animation: moveHorizontal infinite linear;
        }

        .moving-star:nth-child(2n) {
          animation: moveVertical infinite linear;
        }

        .badge-entrance {
          animation: badgeEntrance 2s ease-out forwards, badgeFloat 4s ease-in-out infinite 2s;
        }

        .wordmark-entrance {
          animation: wordmarkEntrance 2.5s ease-out forwards, wordmarkFloat 6s ease-in-out infinite 2.5s;
        }

        .badge-pulse {
          animation: badgePulse 3s ease-in-out infinite;
        }

        .badge-glow {
          box-shadow: 0 0 30px rgba(250, 204, 87, 0.6);
        }

        .wordmark-glow {
          text-shadow: 0 0 20px rgba(250, 204, 87, 0.8);
        }
      `}</style>
    </div>
  );
};

export default TitleScreen;
```

### client/src/game/StarThrone.js
```javascript
import { Camera } from './Camera.js';
import { GameMap } from './GameMap.js';
import { Territory } from './Territory.js';
import { Player } from './Player.js';
import { GameUI } from './GameUI.js';
import { InputHandler } from './InputHandler.js';
import { Renderer } from './Renderer.js';
import { CombatSystem } from './CombatSystem.js';
import { SupplySystem } from './SupplySystem.js';
import { PerformanceManager } from './PerformanceManager.js';
import { DiscoverySystem } from './DiscoverySystem.js';
import { AnimationSystem } from './AnimationSystem.js';
import { UIManager } from './UIManager.js';
import { MapGenerator } from './MapGenerator.js';
import GameUtils from './GameUtils.js';
import { GAME_CONSTANTS } from '../../../common/gameConstants';

/**
 * Star Throne - Main Game Controller
 * 
 * A strategic space conquest game featuring:
 * - Procedural galaxy generation with organic boundaries
 * - Territory-based conquest with throne star mechanics
 * - Discovery system with empire-wide bonuses
 * - Real-time combat and fleet management
 * - Advanced camera system with strategic zoom levels
 * - Performance-optimized rendering with LOD system
 */
export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        this.performanceManager = null;
        this.discoverySystem = null;
        this.animationSystem = null;
        this.uiManager = null;
        this.controls = null;
        
        // Legacy properties for backward compatibility
        this.hoveredTerritory = null;
        
        // Performance tracking
        this.performanceStats = {
            frameTime: 0,
            renderTime: 0,
            updateTime: 0,
            visibleTerritories: 0
        };
        
        // Game entities
        this.probes = [];
        this.supplyRoutes = new Map();
        this.notifications = [];
        this.floatingTexts = [];
        this.floatingDiscoveryTexts = [];
        
        // UI state
        this.leaderboardMinimized = false;
        this.minimapMinimized = true; // Start minimized for cleaner interface
        this.showTouchDebug = false;
        this.touchDebugInfo = [];
        this.showPerformancePanel = false;
        this.showBonusPanel = true;
        
        // Game timing
        this.lastFrameTime = 0;
        this.fps = 60;
        this.fpsUpdateTime = 0;
        
        // Discovery system data (for compatibility)
        this.recentProbeResults = [];
        this.discoveryLog = [];
        
        // Message system
        this.messageText = '';
        this.messageTimer = 0;
        this.messageStartTime = 0;
        this.messageDuration = 3000;
        
        // Background loading
        this.backgroundImage = null;
        this.backgroundLoaded = false;
        
        // Performance constants moved to GAME_CONSTANTS
        this.visibilityUpdateInterval = GAME_CONSTANTS.PERFORMANCE.VISIBILITY_UPDATE_INTERVAL;
        this.lastVisibilityUpdate = 0;
        this.visibleTerritories = null;
        
        // Throttled logging for performance
        this.logThrottle = new Map();
    }
    
    /**
     * Performance-optimized logging with throttling
     * @param {string} message - Log message
     * @param {string} type - Log type (info, warn, error)
     * @param {number} throttleMs - Minimum time between identical messages
     */
    log(message, type = 'info', throttleMs = 1000) {
        const now = Date.now();
        const key = `${type}:${message}`;
        
        if (!this.logThrottle.has(key) || now - this.logThrottle.get(key) > throttleMs) {
            console[type](message);
            this.logThrottle.set(key, now);
        }
    }
    
    loadBackgroundImage() {
        this.backgroundImage = new Image();
        this.backgroundImage.onload = () => {
            this.backgroundLoaded = true;
            console.log('Background galaxy image loaded');
        };
        this.backgroundImage.onerror = () => {
            console.warn('Background galaxy image failed to load');
            this.backgroundLoaded = false;
        };
        this.backgroundImage.src = '/galaxy-background.jpg';
    }
    
    renderBackgroundImage() {
        if (!this.backgroundLoaded || !this.backgroundImage) return;
        
        this.ctx.save();
        
        // Calculate parallax offset (background moves slower than camera)
        const parallaxFactor = 0.2; // Background moves at 20% of camera speed
        const offsetX = this.camera.x * parallaxFactor;
        const offsetY = this.camera.y * parallaxFactor;
        
        // Scale to cover entire viewport
        const scale = Math.max(
            this.canvas.width / this.backgroundImage.width,
            this.canvas.height / this.backgroundImage.height
        ) * 1.5; // Extra scale for parallax coverage
        
        const scaledWidth = this.backgroundImage.width * scale;
        const scaledHeight = this.backgroundImage.height * scale;
        
        // Center the image with parallax offset
        const x = (this.canvas.width - scaledWidth) / 2 - offsetX;
        const y = (this.canvas.height - scaledHeight) / 2 - offsetY;
        
        // Set low opacity and dark overlay
        this.ctx.globalAlpha = 0.15;
        this.ctx.drawImage(this.backgroundImage, x, y, scaledWidth, scaledHeight);
        
        // Add dark overlay to reduce interference
        this.ctx.globalAlpha = 0.6;
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.restore();
    }
    
    /**
     * Setup event listeners for event-driven architecture
     */
    setupEventListeners() {
        // Territory capture events
        document.addEventListener('territoryCapture', (event) => {
            this.handleTerritoryCapture(event.detail);
        });
        
        // Throne capture events
        document.addEventListener('throneCapture', (event) => {
            this.handleThroneCapture(event.detail);
        });
        
        // Discovery events
        document.addEventListener('discoveryEvent', (event) => {
            this.handleDiscoveryEvent(event.detail);
        });
        
        // Combat events
        document.addEventListener('combatStart', (event) => {
            this.handleCombatStart(event.detail);
        });
    }
    
    /**
     * Handle territory capture events
     */
    handleTerritoryCapture(data) {
        const { territory, newOwner, oldOwner } = data;
        console.log(`Territory ${territory.id} captured by ${newOwner.name} from ${oldOwner?.name || 'neutral'}`);
        
        // Add notification
        this.addNotification(`${newOwner.name} captured territory ${territory.id}`, newOwner.color);
        
        // Check win conditions
        this.checkWinConditions();
    }
    
    /**
     * Handle throne capture events
     */
    handleThroneCapture(data) {
        const { throneOwner, conqueror } = data;
        console.log(`👑 THRONE CAPTURED! ${conqueror.name} conquered ${throneOwner.name}'s empire!`);
        
        // Add dramatic notification
        this.addNotification(`${conqueror.name} conquered ${throneOwner.name}'s empire!`, '#ff4444', 6000);
        
        // Transfer all territories
        Object.values(this.gameMap.territories).forEach(territory => {
            if (territory.ownerId === throneOwner.id) {
                territory.ownerId = conqueror.id;
                territory.triggerCaptureFlash();
            }
        });
        
        // Mark conquered player as eliminated
        throneOwner.isEliminated = true;
        throneOwner.territories = [];
        
        // Check win conditions
        this.checkWinConditions();
    }
    
    /**
     * Handle discovery events
     */
    handleDiscoveryEvent(data) {
        const { territory, player, discovery } = data;
        
        // Add floating text for visual feedback
        this.addFloatingDiscoveryText(territory, discovery, player.id);
        
        // Add to discovery log
        this.logDiscoveryForUI(territory, player.id, discovery);
        
        // Apply empire-wide bonuses
        if (this.discoverySystem) {
            this.discoverySystem.applyDiscovery(discovery, territory, player);
        }
    }
    
    /**
     * Handle combat start events
     */
    handleCombatStart(data) {
        const { attacker, defender } = data;
        
        // Trigger combat flash effects
        attacker.lastCombatFlash = Date.now();
        defender.lastCombatFlash = Date.now();
        
        // Add combat notification
        this.addNotification(`Combat: ${attacker.ownerId} vs ${defender.ownerId}`, '#ff8800', 2000);
    }
    
    addNotification(text, color = '#44ff44', duration = 4000) {
        if (!this.uiManager) return;
        
        this.uiManager.addNotification(text, color, duration);
    }
    
    updateNotifications() {
        if (this.uiManager) {
            this.uiManager.updateNotifications();
        }
    }
    
    showMessage(text, duration = 3000) {
        this.messageText = text;
        this.messageTimer = duration;
        this.messageStartTime = Date.now();
        this.messageDuration = duration;
        console.log('Message:', text);
    }
    
    hideMessage() {
        this.messageText = '';
        this.messageTimer = 0;
    }
    
    showError(text) {
        this.showMessage(text, 5000);
        console.error('Error:', text);
    }
    
    updateMessage(deltaTime) {
        if (this.messageTimer > 0) {
            this.messageTimer -= deltaTime;
            if (this.messageTimer <= 0) {
                this.hideMessage();
            }
        }
    }
    
    async init() {
        console.log('🚀 Initializing Star Throne...');
        
        // Setup canvas
        this.setupCanvas();
        
        // Load background image
        this.loadBackgroundImage();
        
        // Initialize modular systems
        this.camera = new Camera(this.canvas.width, this.canvas.height);
        this.performanceManager = new PerformanceManager();
        this.discoverySystem = new DiscoverySystem(this);
        this.animationSystem = new AnimationSystem(this);
        this.uiManager = new UIManager(this);
        this.inputHandler = new InputHandler(this, this.canvas);
        this.combatSystem = new CombatSystem(this);
        this.supplySystem = new SupplySystem(this);
        
        // Initialize UI
        this.ui = new GameUI(this.canvas, this.camera);
        
        // Setup event listeners for modular architecture
        this.setupEventListeners();
        
        // Setup canvas event listeners
        this.setupEventListeners();
        
        // Initialize performance manager and detect optimal settings
        this.performanceManager.detectOptimalProfile();
        
        this.gameStartTime = Date.now(); // Track when game actually starts
        this.startGame();
        this.gameLoop();
    }
    
    // Define discovery types and their probabilities
    getDiscoveryTypes() {
        return [
            {
                id: 'hostile_aliens',
                name: 'Hostile Aliens',
                description: 'Hostile alien life destroys your probe!',
                probability: 0.15,
                type: 'negative',
                effect: 'probe_lost'
            },
            {
                id: 'friendly_aliens',
                name: 'Friendly Aliens',
                description: 'Friendly aliens join your empire!',
                probability: 0.12,
                type: 'positive',
                effect: 'extra_fleet',
                bonus: 50
            },
            {
                id: 'precursor_weapons',
                name: 'Precursor Weapons Cache',
                description: 'Ancient weapon technology discovered!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'attack_bonus',
                bonus: 10 // +10% attack
            },
            {
                id: 'precursor_drive',
                name: 'Precursor Drive System',
                description: 'Advanced propulsion technology found!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'speed_bonus',
                bonus: 20 // +20% speed
            },
            {
                id: 'precursor_shield',
                name: 'Precursor Shield Matrix',
                description: 'Defensive technology enhances your empire!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'defense_bonus',
                bonus: 10 // +10% defense
            },
            {
                id: 'precursor_nanotech',
                name: 'Precursor Nanotechnology',
                description: 'Self-replicating systems boost production!',
                probability: 0.08,
                type: 'empire_bonus',
                effect: 'production_bonus',
                bonus: 10 // +10% army generation
            },
            {
                id: 'factory_complex',
                name: 'Precursor Factory Complex',
                description: 'Ancient manufacturing facility still operational!',
                probability: 0.10,
                type: 'planet_bonus',
                effect: 'factory_planet',
                bonus: 100 // +100% army generation for this planet
            },
            {
                id: 'rich_minerals',
                name: 'Rich Mineral Deposits',
                description: 'Valuable resources boost this planet\'s output!',
                probability: 0.12,
                type: 'planet_bonus',
                effect: 'mineral_planet',
                bonus: 50 // +50% army generation for this planet
            },
            {
                id: 'void_storms',
                name: 'Void Storm Activity',
                description: 'Electromagnetic storms hinder development.',
                probability: 0.08,
                type: 'negative',
                effect: 'slow_planet',
                bonus: -25 // -25% army generation for this planet
            },
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                description: 'Mysterious structures of unknown origin.',
                probability: 0.06,
                type: 'neutral',
                effect: 'no_effect'
            },
            {
                id: 'no_discovery',
                name: 'Standard Planet',
                description: 'A typical world with no special features.',
                probability: 0.05,
                type: 'neutral',
                effect: 'no_effect'
            }
        ];
    }
    
    initializeStarfield() {
        // Starfield initialization moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.initializeStarfield();
        }
    }
    
    preRenderStaticBackground() {
        // Background pre-rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.preRenderStaticBackground();
        }
    }
    
    renderStarfieldStatic(ctx) {
        // Static starfield rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.renderStarfieldStatic(ctx);
        }
    }
    
    renderNebulasStatic(ctx) {
        if (!this.gameMap.nebulas) return;
        
        this.gameMap.nebulas.forEach(nebula => {
            const gradient = ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Random discovery selection based on probabilities
    selectRandomDiscovery() {
        const discoveries = this.getDiscoveryTypes();
        const random = Math.random();
        let cumulative = 0;
        
        for (const discovery of discoveries) {
            cumulative += discovery.probability;
            if (random <= cumulative) {
                return discovery;
            }
        }
        
        // Fallback to no discovery
        return discoveries.find(d => d.id === 'no_discovery');
    }
    
    // Log discovery for UI display (called for both successful and failed probes)
    logDiscoveryForUI(territory, playerId, discovery) {
        const player = this.players[playerId];
        if (!player) return;
        
        // Add to discovery log for UI display
        this.discoveryLog.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discovery: discovery,
            playerName: player.name
        });
        
        console.log(`🔍 Discovery on planet ${territory.id}: ${discovery.name} - ${discovery.description}`);
        
        // Add floating discovery text above the planet
        this.addFloatingDiscoveryText(territory, discovery, playerId);
        
        // Track probe result for UI announcements
        this.recentProbeResults.push({
            timestamp: Date.now(),
            territoryId: territory.id,
            playerId: playerId,
            discoveryName: discovery.name,
            success: discovery.effect !== 'probe_lost',
            discovery: discovery
        });
        
        // Keep only recent results (last 10)
        if (this.recentProbeResults.length > 10) {
            this.recentProbeResults.shift();
        }
    }
    
    // Process discovery when a planet is successfully colonized - MOVED TO UTILS.JS
    
    addFloatingDiscoveryText(territory, discovery, playerId) {
        // Create floating text object
        const floatingText = {
            x: territory.x,
            y: territory.y - 40, // Start above the planet
            text: discovery.name,
            icon: this.getDiscoveryIcon(discovery.effect),
            color: this.getDiscoveryColor(discovery.effect),
            startTime: Date.now(),
            duration: 4000, // 4 seconds
            fadeOutDuration: 1000, // Last 1 second fades out
            playerId: playerId
        };
        
        this.floatingDiscoveryTexts.push(floatingText);
        
        // Limit to 10 floating texts to prevent clutter
        if (this.floatingDiscoveryTexts.length > 10) {
            this.floatingDiscoveryTexts.shift();
        }
    }
    
    getDiscoveryIcon(effect) {
        const icons = {
            'probe_lost': '💀',
            'extra_fleet': '👽',
            'attack_bonus': '⚔️',
            'speed_bonus': '🚀',
            'defense_bonus': '🛡️',
            'production_bonus': '🔬',
            'factory_planet': '🏭',
            'mineral_planet': '💎',
            'slow_planet': '⚡',
            'no_effect': '🗿'
        };
        return icons[effect] || '❓';
    }
    
    getDiscoveryColor(effect) {
        const colors = {
            'probe_lost': '#ff4444',
            'extra_fleet': '#44ff44',
            'attack_bonus': '#ff6666',
            'speed_bonus': '#4ecdc4',
            'defense_bonus': '#45b7d1',
            'production_bonus': '#96ceb4',
            'factory_planet': '#feca57',
            'mineral_planet': '#f39c12',
            'slow_planet': '#e74c3c',
            'no_effect': '#95a5a6'
        };
        return colors[effect] || '#ffffff';
    }
    
    updateFloatingDiscoveryTexts(deltaTime) {
        const currentTime = Date.now();
        
        this.floatingDiscoveryTexts = this.floatingDiscoveryTexts.filter(text => {
            const elapsed = currentTime - text.startTime;
            return elapsed < text.duration;
        });
    }
    
    createShipAnimation(fromTerritory, toTerritory, isAttack = false) {
        if (this.animationSystem) {
            this.animationSystem.createShipAnimation(fromTerritory, toTerritory, isAttack);
        }
    }
    
    createSupplyRouteAnimation(path, playerColor) {
        if (this.animationSystem) {
            this.animationSystem.createSupplyRouteAnimation(path, playerColor);
        }
    }
    
    initializeAnimationSegment(animation) {
        if (this.animationSystem) {
            this.animationSystem.initializeAnimationSegment(animation);
        }
    }
    
    updateShipAnimations(deltaTime) {
        if (this.animationSystem) {
            this.animationSystem.updateShipAnimations(deltaTime);
        }
    }
    
    updateProbes(deltaTime) {
        const currentTime = Date.now();
        
        this.probes = this.probes.filter(probe => {
            const elapsed = currentTime - probe.startTime;
            
            // Check if probe is in a nebula (slows down movement)
            if (this.gameMap.nebulas) {
                probe.inNebula = this.gameMap.nebulas.some(nebula => {
                    const dx = probe.x - nebula.x;
                    const dy = probe.y - nebula.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < nebula.radius;
                });
            }
            
            // Apply speed modifier if in nebula
            const speedModifier = probe.inNebula ? 0.33 : 1.0; // 1/3 speed in nebulas
            const effectiveSpeed = probe.speed * speedModifier * this.config.gameSpeed;
            
            if (elapsed >= probe.duration) {
                // Probe reaches destination
                this.colonizePlanet(probe);
                return false; // Remove probe
            } else {
                // Update probe position with speed modifier
                const progress = Math.min(1, elapsed / probe.duration);
                const easedProgress = this.easeInOutQuad(progress);
                
                probe.x = probe.startX + (probe.endX - probe.startX) * easedProgress;
                probe.y = probe.startY + (probe.endY - probe.startY) * easedProgress;
                
                return true; // Keep probe
            }
        });
    }
    
    colonizePlanet(probe) {
        const territory = this.gameMap.territories[probe.targetId];
        if (!territory || territory.ownerId !== null) {
            console.log(`Probe ${probe.id} failed: territory ${probe.targetId} already colonized`);
            return;
        }
        
        // Select random discovery
        const discovery = this.selectRandomDiscovery();
        const player = this.players[probe.playerId];
        
        console.log(`Probe colonizing planet ${probe.targetId} for player ${player.name}`);
        this.logDiscoveryForUI(territory, probe.playerId, discovery);
        
        // Check if probe is destroyed by hostile aliens
        if (discovery.effect === 'probe_lost') {
            console.log(`Probe destroyed by hostile aliens on planet ${probe.targetId}!`);
            return; // Probe fails, planet remains uncolonized
        }
        
        // Successful colonization
        territory.ownerId = probe.playerId;
        territory.armySize = 1; // Start with 1 army regardless of hidden strength
        territory.isColonizable = false;
        territory.lastArmyGeneration = Date.now();
        
        // Reveal connections to other territories
        territory.neighbors.forEach(neighborId => {
            const neighbor = this.gameMap.territories[neighborId];
            if (neighbor && !neighbor.isColonizable) {
                // Make connection visible
                neighbor.hiddenConnections = neighbor.hiddenConnections || [];
                const connectionIndex = neighbor.hiddenConnections.indexOf(territory.id);
                if (connectionIndex > -1) {
                    neighbor.hiddenConnections.splice(connectionIndex, 1);
                }
            }
        });
        
        // Process discovery using centralized GameUtils function
        GameUtils.processDiscovery(this.discoverySystem.discoveries, discovery.id, territory.id);
        
        console.log(`Planet ${probe.targetId} colonized successfully! Discovery: ${discovery.name}`);
        
        // Update player territories
        player.territories.push(territory.id);
        
        // Apply discovery effects if it's a human player
        if (player.type === 'human' && this.discoverySystem) {
            this.discoverySystem.applyDiscovery(discovery, territory, player);
        }
    }
    
    renderShipAnimations() {
        if (this.animationSystem) {
            this.animationSystem.renderShipAnimations(this.ctx, this.camera);
        }
    }
    
    renderProbes() {
        this.ctx.save();
        
        for (let i = 0; i < this.probes.length; i++) {
            const probe = this.probes[i];
            const player = this.players[probe.playerId];
            
            if (!player) continue;
            
            // Probe visual effects when in nebula
            if (probe.inNebula) {
                this.ctx.globalAlpha = 0.3 + 0.4 * Math.sin(Date.now() * 0.005); // Pulsing fade
            } else {
                this.ctx.globalAlpha = 1.0;
            }
            
            // Draw probe
            this.ctx.fillStyle = player.color;
            this.ctx.beginPath();
            this.ctx.arc(probe.x, probe.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Draw probe trail with matching fade
            this.ctx.strokeStyle = player.color;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(probe.startX, probe.startY);
            this.ctx.lineTo(probe.x, probe.y);
            this.ctx.stroke();
            
            // Probe icon
            this.ctx.globalAlpha = 1.0;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = '8px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('🚀', probe.x, probe.y - 8);
        }
        
        this.ctx.restore();
    }
    
    renderFloatingDiscoveryTexts() {
        // Floating discovery texts moved to DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
    }
    
    // Easing function for smooth animations
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    setupCanvas() {
        if (this.config.canvas) {
            this.canvas = this.config.canvas;
        } else {
            this.canvas = document.createElement('canvas');
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            document.body.appendChild(this.canvas);
        }
        
        this.ctx = this.canvas.getContext('2d');
        
        // Handle window resize
        const handleResize = () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera) {
                this.camera.updateViewport(this.canvas.width, this.canvas.height);
            }
        };
        
        window.addEventListener('resize', handleResize);
        
        // Prevent context menu on right click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Prevent scrolling on touch devices
        this.canvas.style.touchAction = 'none';
        
        console.log(`Canvas initialized: ${this.canvas.width}x${this.canvas.height}`);
    }
    
    setupEventListeners() {
        // Keyboard controls for camera
        document.addEventListener('keydown', (e) => {
            if (!this.camera) return;
            
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    if (this.inputHandler && this.inputHandler.selectedTerritory) {
                        this.camera.focusOnTerritory(this.inputHandler.selectedTerritory);
                    }
                    break;
                case 'KeyH':
                    e.preventDefault();
                    if (this.gameMap) {
                        this.camera.frameRegion(Object.values(this.gameMap.territories));
                    }
                    break;
                case 'KeyM':
                    e.preventDefault();
                    this.minimapMinimized = !this.minimapMinimized;
                    break;
                case 'KeyP':
                    e.preventDefault();
                    this.showPerformancePanel = !this.showPerformancePanel;
                    break;
            }
        });
    }
    
    startGame() {
        console.log('🎮 Starting Star Throne game...');
        
        // Initialize map with configured layout
        this.gameMap = new GameMap(MapGenerator.mapWidth || 2800, MapGenerator.mapHeight || 2100, this.config);
        
        // Create players
        this.createPlayers(1 + this.config.aiCount); // 1 human + AI players
        
        // Distribute starting territories with proper spacing
        this.distributeStartingTerritories();
        
        // Initialize parallax starfield via AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.initializeStarfield();
            console.log('Parallax starfield initialized with 530 stars across 3 layers');
        }
        
        // Pre-render static background elements for performance
        if (this.animationSystem) {
            this.animationSystem.preRenderStaticBackground();
            console.log('Background rendering switched to dynamic mode for proper parallax and camera tracking');
        }
        
        // Set camera to strategic overview of the galaxy
        this.camera.centerOn(this.gameMap.width / 2, this.gameMap.height / 2);
        this.camera.zoomTo(0.25); // Strategic overview zoom
        
        // Start home system flashing for 3 seconds
        this.homeSystemFlashStart = Date.now();
        
        this.gameState = 'playing';
        
        console.log(`Game started with ${this.players.length} players (${this.config.playerName} + ${this.config.aiCount} AI) and ${this.config.mapSize} territories`);
    }
    
    generateAIName(index) {
        return GameUtils.generateAIName(index);
    }
    
    createPlayers(numPlayers) {
        // Create human player first
        const humanPlayer = new Player(
            'human',
            this.config.playerName || 'Player',
            '#00ffff', // Cyan for human player
            'human'
        );
        this.players['human'] = humanPlayer;
        this.humanPlayer = humanPlayer;
        
        // Create AI players
        for (let i = 1; i < numPlayers; i++) {
            const playerId = `ai-${i}`;
            const playerName = this.generateAIName(i - 1);
            const playerColor = this.generatePlayerColor(i);
            
            const aiPlayer = new Player(
                playerId,
                playerName,
                playerColor,
                'ai'
            );
            this.players[playerId] = aiPlayer;
        }
        
        console.log(`Created ${numPlayers} players (1 human + ${numPlayers - 1} AI)`);
    }
    
    initializePlayerDiscoveries(playerId) {
        // Initialize discovery tracking for a player using DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.initializePlayer(playerId);
        }
    }
    
    adjustColorBrightness(hex, percent) {
        const num = parseInt(hex.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    distributeStartingTerritories() {
        const playerIds = Object.keys(this.players);
        const territories = Object.values(this.gameMap.territories);
        const validTerritories = territories.filter(t => !t.isColonizable);
        
        // Ensure adequate spacing between starting territories
        const minDistanceBetweenStarts = 200;
        const selectedTerritories = [];
        
        for (let i = 0; i < playerIds.length; i++) {
            const playerId = playerIds[i];
            let attempts = 0;
            let selectedTerritory = null;
            
            while (attempts < 100 && !selectedTerritory) {
                const randomTerritory = validTerritories[Math.floor(Math.random() * validTerritories.length)];
                
                // Check distance from already selected territories
                let validPlacement = true;
                for (const existing of selectedTerritories) {
                    const distance = GameUtils.distance(randomTerritory.x, randomTerritory.y, existing.x, existing.y);
                    if (distance < minDistanceBetweenStarts) {
                        validPlacement = false;
                        break;
                    }
                }
                
                if (validPlacement || attempts > 80) { // Force placement after many attempts
                    selectedTerritory = randomTerritory;
                    selectedTerritories.push(selectedTerritory);
                }
                
                attempts++;
            }
            
            if (selectedTerritory) {
                selectedTerritory.ownerId = playerId;
                selectedTerritory.armySize = GAME_CONSTANTS.STARTING_FLEET_SIZE;
                selectedTerritory.isThroneStar = true; // Mark as throne star
                selectedTerritory.lastArmyGeneration = Date.now();
                
                // Add to player's territory list
                this.players[playerId].territories = [selectedTerritory.id];
                
                // Initialize discovery tracking for this player
                this.initializePlayerDiscoveries(playerId);
                
                console.log(`🏠 Starting territory ${selectedTerritory.id} for ${this.players[playerId].name}: ${selectedTerritory.armySize} armies`);
                console.log(`👑 Player ${this.players[playerId].name} assigned throne star: Territory ${selectedTerritory.id} (distance from others: ${selectedTerritories.length > 1 ? GameUtils.distance(selectedTerritory.x, selectedTerritory.y, selectedTerritories[selectedTerritories.length - 2].x, selectedTerritories[selectedTerritories.length - 2].y).toFixed(1) : 'N/A'})`);
            }
        }
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    gameLoop(currentTime = 0) {
        try {
            const frameStart = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            // Update FPS counter
            this.updateFPS(currentTime);
            
            if (this.gameState === 'playing') {
                this.update(deltaTime);
            }
            
            this.render();
            
            // Track overall frame performance
            this.performanceStats.frameTime = performance.now() - frameStart;
        } catch (error) {
            console.error('Game loop error:', error);
            // Continue running to prevent complete game halt
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    updateFPS(currentTime) {
        if (currentTime - this.fpsUpdateTime >= GAME_CONSTANTS.PERFORMANCE.FPS_UPDATE_INTERVAL) {
            this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
            this.fpsUpdateTime = currentTime;
        }
    }
    
    update(deltaTime) {
        const updateStart = performance.now();
        
        // Update camera
        if (this.camera) {
            this.camera.update(deltaTime);
        }
        
        // Update input handler
        if (this.inputHandler) {
            this.inputHandler.update(deltaTime);
        }
        
        // Update modular systems
        if (this.animationSystem) {
            this.animationSystem.update(deltaTime);
        }
        
        if (this.discoverySystem) {
            this.discoverySystem.update(deltaTime);
        }
        
        // Update probes
        this.updateProbes(deltaTime);
        
        // Update floating discovery texts
        this.updateFloatingDiscoveryTexts(deltaTime);
        
        // Generate armies for owned territories
        this.generateArmies(deltaTime);
        
        // Process supply routes
        this.processSupplyRoutes();
        
        // Update AI players with performance optimization (staggered updates)
        this.updateAI(deltaTime);
        
        // Update notifications
        this.updateNotifications();
        
        // Update message system
        this.updateMessage(deltaTime);
        
        // Check win conditions
        this.checkWinConditions();
        
        // Track performance
        this.performanceStats.updateTime = performance.now() - updateStart;
    }
    
    checkPlayerElimination() {
        Object.values(this.players).forEach(player => {
            if (player.territories.length === 0 && !player.isEliminated) {
                player.isEliminated = true;
                console.log(`Player ${player.name} has been eliminated!`);
                
                if (player === this.humanPlayer) {
                    this.showMessage('Game Over! Your empire has fallen.');
                }
            }
        });
    }
    
    checkWinConditions() {
        this.checkPlayerElimination();
        
        const alivePlayers = Object.values(this.players).filter(p => !p.isEliminated);
        
        if (alivePlayers.length === 1) {
            const winner = alivePlayers[0];
            this.endGame(winner);
        } else if (alivePlayers.length === 0) {
            this.endGame(null); // Draw
        }
    }
    
    endGame(winner = null) {
        this.gameState = 'ended';
        
        if (winner) {
            console.log(`🎉 Game Over! ${winner.name} wins!`);
            this.showMessage(`Game Over! ${winner.name} wins!`);
        } else {
            console.log(`Game Over! It's a draw.`);
            this.showMessage('Game Over! It\'s a draw.');
        }
    }
    
    render() {
        if (!this.ctx || !this.canvas) {
            console.error('No canvas context available for rendering');
            return;
        }
        
        const renderStart = performance.now();
        
        // Update visible territories for culling
        this.updateVisibleTerritories();
        
        // Clear canvas with space background
        this.ctx.fillStyle = '#001122';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render parallax starfield behind everything via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render game world with Level of Detail (LOD) optimizations
        const lodLevel = this.getLODLevel();
        
        this.renderNebulas();
        this.renderTerritories();
        
        // Render connections based on LOD level
        if (lodLevel >= 2) {
            this.renderConnections();
        }
        
        // Render supply routes for operational and tactical view
        if (lodLevel >= 2) {
            this.renderSupplyRoutes();
        }
        
        this.renderDragPreview();
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        
        // Ship animations and probes for tactical view
        if (lodLevel >= 2) {
            // Use AnimationSystem for ship animations
            if (this.animationSystem) {
                this.animationSystem.renderShipAnimations(this.ctx, this.camera);
            }
            this.renderProbes();
        }
        
        // Use DiscoverySystem for floating discovery texts
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
        this.renderArmies();
        this.renderFloatingTexts();
        
        // Restore context
        this.ctx.restore();
        
        // Render UI (not affected by camera)
        this.renderUI();
        
        // Track performance
        this.performanceStats.renderTime = performance.now() - renderStart;
    }
    
    /**
     * Get Level of Detail based on camera zoom level
     * Level 1: Strategic view (very zoomed out) - minimal detail
     * Level 2: Operational view (medium zoom) - moderate detail  
     * Level 3: Tactical view (zoomed in) - full detail
     */
    getLODLevel() {
        const zoom = this.camera.zoom;
        if (zoom < 0.3) {
            return 1; // Strategic
        } else if (zoom < 1.0) {
            return 2; // Operational
        } else {
            return 3; // Tactical
        }
    }
    
    updateVisibleTerritories() {
        const currentTime = Date.now();
        
        // Only update visibility every interval for performance
        if (currentTime - this.lastVisibilityUpdate < this.visibilityUpdateInterval) {
            return;
        }
        
        this.lastVisibilityUpdate = currentTime;
        
        if (!this.camera || !this.gameMap) {
            this.visibleTerritories = Object.values(this.gameMap?.territories || {});
            return;
        }
        
        const viewBounds = this.camera.getViewBounds();
        const margin = 100; // Extra margin for smooth transitions
        
        this.visibleTerritories = Object.values(this.gameMap.territories).filter(territory => {
            return this.camera.isPointVisible(territory.x, territory.y, margin);
        });
        
        // Track performance metric
        this.performanceStats.visibleTerritories = this.visibleTerritories.length;
    }
    
    renderParallaxStarfield() {
        // Parallax starfield rendering moved to AnimationSystem
        if (this.animationSystem) {
            this.animationSystem.renderParallaxStarfield(this.ctx, this.camera);
        }
    }
    
    renderNebulas() {
        if (!this.gameMap.nebulas) return;
        
        this.ctx.save();
        
        this.gameMap.nebulas.forEach(nebula => {
            // Check if nebula is visible
            if (!this.camera.isPointVisible(nebula.x, nebula.y, nebula.radius)) {
                return;
            }
            
            const gradient = this.ctx.createRadialGradient(
                nebula.x, nebula.y, 0,
                nebula.x, nebula.y, nebula.radius
            );
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.restore();
    }
    
    renderTerritories() {
        if (!this.gameMap) return;
        
        this.ctx.save();
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const currentTime = Date.now();
        
        // Home system flashing effect
        const isFlashingTime = this.homeSystemFlashStart && 
            (currentTime - this.homeSystemFlashStart) < this.homeSystemFlashDuration;
        const flashAlpha = isFlashingTime ? 
            0.5 + 0.5 * Math.sin((currentTime - this.homeSystemFlashStart) * 0.02) : 0;
        
        for (let i = 0; i < territories.length; i++) {
            const territory = territories[i];
            
            // Territory rendering with optimizations
            this.ctx.save();
            
            if (territory.ownerId === null) {
                // Neutral territory
                if (territory.isColonizable) {
                    // Colonizable planet - dark with yellow marker
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pulsing yellow marker
                    const pulseAlpha = 0.6 + 0.4 * Math.sin(currentTime * 0.003);
                    this.ctx.globalAlpha = pulseAlpha;
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('?', territory.x, territory.y + 6);
                } else {
                    // Standard neutral planet
                    this.ctx.fillStyle = '#666666';
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Army count for neutral territories
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 2;
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeText(territory.armySize.toString(), territory.x, territory.y + 4);
                    this.ctx.fillText(territory.armySize.toString(), territory.x, territory.y + 4);
                }
            } else {
                // Owned territory
                const owner = this.players[territory.ownerId];
                if (owner) {
                    // Territory base
                    this.ctx.fillStyle = owner.color;
                    this.ctx.beginPath();
                    this.ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Special effects for human player territories
                    if (owner.type === 'human') {
                        // Cyan glow for human territories
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.shadowBlur = 15;
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(territory.x, territory.y, territory.radius + 2, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        
                        // Cyan flag on human territories
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.fillRect(territory.x - 8, territory.y - territory.radius - 15, 12, 8);
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = 'bold 8px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('★', territory.x - 2, territory.y - territory.radius - 9);
                    }
                    
                    // Throne star crown
                    if (territory.isThroneStar) {
                        this.ctx.fillStyle = '#ffd700';
                        this.ctx.font = 'bold 20px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('👑', territory.x, territory.y - territory.radius - 10);
                    }
                    
                    // Factory icon for factory discoveries
                    if (this.discoverySystem && 
                        this.discoverySystem.discoveries.factoryPlanets.includes(territory.id)) {
                        this.ctx.fillStyle = '#ffcc00';
                        this.ctx.font = 'bold 12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('🏭', territory.x + territory.radius + 8, territory.y - 5);
                    }
                    
                    // Combat flash effect
                    if (territory.lastCombatFlash && 
                        (currentTime - territory.lastCombatFlash) < 1000) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.arc(territory.x, territory.y, territory.radius + 5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            // Home system flashing for human player
            if (isFlashingTime && territory.ownerId === this.humanPlayer?.id && territory.isThroneStar) {
                this.ctx.globalAlpha = flashAlpha;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(territory.x, territory.y, territory.radius + 10, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Selection highlight
            if (this.inputHandler && this.inputHandler.selectedTerritory === territory) {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(territory.x, territory.y, territory.radius + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            this.ctx.restore();
        }
        
        this.ctx.restore();
    }
    
    renderConnections() {
        if (!this.gameMap) return;
        
        this.ctx.save();
        this.ctx.lineWidth = 1;
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const drawnConnections = new Set();
        
        for (let i = 0; i < territories.length; i++) {
            const territory = territories[i];
            
            territory.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (!neighbor) return;
                
                // Avoid drawing same connection twice
                const connectionKey = `${Math.min(territory.id, neighborId)}-${Math.max(territory.id, neighborId)}`;
                if (drawnConnections.has(connectionKey)) return;
                drawnConnections.add(connectionKey);
                
                // Skip hidden connections for colonizable planets
                if (territory.isColonizable || neighbor.isColonizable) {
                    if (territory.hiddenConnections && territory.hiddenConnections.includes(neighborId)) return;
                    if (neighbor.hiddenConnections && neighbor.hiddenConnections.includes(territory.id)) return;
                }
                
                // Skip if connection is not visible
                if (!this.camera.isRectVisible(
                    Math.min(territory.x, neighbor.x) - 10,
                    Math.min(territory.y, neighbor.y) - 10,
                    Math.abs(territory.x - neighbor.x) + 20,
                    Math.abs(territory.y - neighbor.y) + 20
                )) {
                    return;
                }
                
                // Color connections between same-owned territories
                if (territory.ownerId === neighbor.ownerId && territory.ownerId !== null) {
                    const owner = this.players[territory.ownerId];
                    this.ctx.strokeStyle = owner ? owner.color : '#cccccc';
                    this.ctx.lineWidth = 2;
                } else {
                    this.ctx.strokeStyle = '#cccccc';
                    this.ctx.lineWidth = 1;
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(territory.x, territory.y);
                this.ctx.lineTo(neighbor.x, neighbor.y);
                this.ctx.stroke();
            });
        }
        
        this.ctx.restore();
    }
    
    renderSupplyRoutes() {
        this.ctx.save();
        
        this.supplyRoutes.forEach((route, territoryId) => {
            const fromTerritory = this.gameMap.territories[territoryId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (!fromTerritory || !toTerritory) return;
            
            // Skip if not visible
            if (!this.camera.isRectVisible(
                Math.min(fromTerritory.x, toTerritory.x) - 10,
                Math.min(fromTerritory.y, toTerritory.y) - 10,
                Math.abs(fromTerritory.x - toTerritory.x) + 20,
                Math.abs(fromTerritory.y - toTerritory.y) + 20
            )) {
                return;
            }
            
            // Animate dashed line
            const dashOffset = (Date.now() * 0.01) % 20;
            
            this.ctx.strokeStyle = '#00ffff';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 10]);
            this.ctx.lineDashOffset = -dashOffset;
            
            if (route.path && route.path.length > 1) {
                // Multi-hop route
                this.ctx.beginPath();
                const firstTerritory = this.gameMap.territories[route.path[0]];
                this.ctx.moveTo(firstTerritory.x, firstTerritory.y);
                
                for (let i = 1; i < route.path.length; i++) {
                    const territory = this.gameMap.territories[route.path[i]];
                    this.ctx.lineTo(territory.x, territory.y);
                }
                this.ctx.stroke();
            } else {
                // Direct route
                this.ctx.beginPath();
                this.ctx.moveTo(fromTerritory.x, fromTerritory.y);
                this.ctx.lineTo(toTerritory.x, toTerritory.y);
                this.ctx.stroke();
            }
            
            this.ctx.setLineDash([]);
        });
        
        this.ctx.restore();
    }
    
    getTransferPercentage(event) {
        // Get transfer percentage from input handler
        if (this.inputHandler) {
            return this.inputHandler.getTransferPercentage(event);
        }
        return 0.5; // Default 50%
    }
    
    renderDragPreview() {
        // Drag preview rendering handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderDragPreview(this.ctx);
        }
    }
    
    renderProportionalDragUI() {
        // Proportional drag UI handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderProportionalDragUI(this.ctx);
        }
    }
    
    renderTransferPreview() {
        // Transfer preview handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.renderTransferPreview(this.ctx);
        }
    }
    
    renderFloatingTexts() {
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        const currentTime = Date.now();
        
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = currentTime - text.startTime;
            const progress = elapsed / text.duration;
            
            if (progress >= 1) return false;
            
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
            this.ctx.strokeText(text.text, text.x, text.y - yOffset);
            this.ctx.fillText(text.text, text.x, text.y - yOffset);
            
            return true;
        });
        
        this.ctx.restore();
    }
    
    renderArmies() {
        // Dynamic Level of Detail based on camera zoom level
        const zoomLevel = this.getLODLevel();
        const currentZoom = this.camera.zoom;
        
        this.ctx.save();
        
        const territories = this.visibleTerritories || Object.values(this.gameMap.territories);
        const playersLookup = {}; // Cache player lookups
        
        // Strategic View (zoomed out) - Show simplified information
        if (zoomLevel === 1) {
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner && territory.armySize >= 10) { // Only show significant fleets
                        const armyText = territory.armySize >= 100 ? `${Math.floor(territory.armySize / 10)}0+` : territory.armySize.toString();
                        
                        // Simplified text rendering for performance
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(armyText, territory.x, territory.y + 3);
                    }
                }
            }
        }
        // Operational View (mid zoom) - Show fleet counts as icons
        else if (zoomLevel === 2) {
            this.ctx.font = 'bold 13px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // White outline for readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 4);
                        
                        // Color-coded text based on owner
                        this.ctx.fillStyle = owner.id === this.humanPlayer?.id ? '#000000' : '#333333';
                        this.ctx.fillText(armyText, territory.x, territory.y + 4);
                    }
                }
            }
        }
        // Tactical View (zoomed in) - Show full detail
        else {
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            
            for (let i = 0; i < territories.length; i++) {
                const territory = territories[i];
                if (territory.ownerId !== null && territory.armySize > 0) {
                    // Use cached player lookup
                    let owner = playersLookup[territory.ownerId];
                    if (!owner) {
                        owner = this.players[territory.ownerId];
                        if (owner) playersLookup[territory.ownerId] = owner;
                    }
                    
                    if (owner) {
                        const armyText = territory.armySize.toString();
                        
                        // Black text with white outline for maximum readability
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeText(armyText, territory.x, territory.y + 5);
                        
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(armyText, territory.x, territory.y + 5);
                    }
                }
            }
        }
        
        this.ctx.restore();
    }
    
    render() {
        const startTime = performance.now();
        
        // Clear canvas with dark space background
        this.ctx.fillStyle = '#0a0a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render background galaxy image with parallax via UIManager (before camera transform)
        if (this.uiManager) {
            this.uiManager.renderBackgroundImage(this.ctx, this.camera);
        }
        
        // Render parallax starfield with movement via AnimationSystem (before camera transform)
        if (this.animationSystem) {
            this.animationSystem.renderStaticBackground(this.ctx);
        }
        
        // Apply camera transformations for background elements
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Render nebulas with proper depth
        this.renderNebulas();
        
        this.ctx.restore();
        
        // Apply camera transformations
        this.ctx.save();
        this.camera.applyTransform(this.ctx);
        
        // Update performance tracking
        this.updateVisibleTerritories();
        
        // Render connections between territories
        this.renderConnections();
        
        // Render supply routes
        this.renderSupplyRoutes();
        
        // Render territories with fleet counts
        this.renderTerritories();
        
        // Render probes
        this.renderProbes();
        
        // Render ship animations
        this.renderShipAnimations();
        
        // Proportional drag interface handled by InputHandler
        
        // Selection is handled by Territory render method itself
        
        this.ctx.restore();
        
        // Floating discovery texts disabled - using top-center UI notifications instead
        // this.renderFloatingDiscoveryTexts();
        
        // Render UI overlay
        this.renderUI();
        
        // Update and render performance overlay
        if (this.performanceOverlay) {
            this.performanceOverlay.update();
            this.performanceOverlay.render();
        }
        
        // Update performance stats
        if (this.performanceManager) {
            this.performanceManager.frameMetrics.renderTime = performance.now() - startTime;
        }
        this.performanceStats.renderTime = performance.now() - startTime;
    }
    
    renderFloatingDiscoveryTexts() {
        // Floating discovery text rendering moved to DiscoverySystem
        if (this.discoverySystem) {
            this.discoverySystem.renderFloatingDiscoveries(this.ctx, this.camera);
        }
    }
    
    renderUI() {
        if (this.ui) {
            const inputState = this.inputHandler ? this.inputHandler.getInputState() : {};
            
            this.ui.render(this.ctx, {
                gameState: this.gameState,
                gameTimer: this.gameTimer,
                players: this.players,
                humanPlayer: this.humanPlayer,
                selectedTerritory: inputState.selectedTerritory,
                hoveredTerritory: this.hoveredTerritory,
                mousePos: this.inputHandler ? this.inputHandler.mousePos : { x: 0, y: 0 },
                fps: this.fps,
                currentPlayers: this.currentPlayers,
                maxPlayers: this.maxPlayers,
                touchDebugInfo: this.touchDebugInfo,
                showTouchDebug: this.showTouchDebug,
                leaderboardMinimized: this.leaderboardMinimized,
                minimapMinimized: this.minimapMinimized,
                camera: this.camera,
                showPerformancePanel: this.showPerformancePanel,
                frameTime: this.performanceStats.frameTime,
                renderTime: this.performanceStats.renderTime,
                updateTime: this.performanceStats.updateTime,
                territoryCount: Object.keys(this.gameMap.territories).length,
                visibleTerritories: this.performanceStats.visibleTerritories,
                probeCount: this.probes.length,
                notifications: this.notifications,
                playerDiscoveries: this.discoverySystem ? this.discoverySystem.getDiscoveriesForUI() : {},
                recentProbeResults: this.recentProbeResults,
                discoveryLog: this.discoveryLog,
                showBonusPanel: this.showBonusPanel,
                inputState: inputState,
                messageText: this.messageText,
                messageTimer: this.messageTimer
            });
        }
        
        // Render UI components via UIManager (notifications, messages)
        if (this.uiManager) {
            this.uiManager.renderNotifications(this.ctx);
            this.uiManager.renderMessage(this.ctx);
        }
    }
    
    updateHoverState(mousePos) {
        // Hover state updates handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.updateHoverState(mousePos);
        }
    }
    
    updateCanvasCursor() {
        // Cursor updates handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.updateCanvasCursor();
        }
    }
    
    handleContextActionWithModifiers(targetTerritory) {
        // Context actions with modifiers handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleContextActionWithModifiers(targetTerritory);
        }
    }
    
    handleContextAction(targetTerritory) {
        // Context actions handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleContextAction(targetTerritory);
        }
    }
    
    handleUIClick(screenX, screenY) {
        // UI clicks handled by InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleUIClick(screenX, screenY);
        }
    }
    
    launchProbe(fromTerritory, toTerritory) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return false;
        }
        
        // Check if target is colonizable
        if (!toTerritory.isColonizable) {
            console.log('Cannot probe: Target territory is not colonizable');
            return false;
        }
        
        // Check probe cost
        const probeCost = GAME_CONSTANTS.PROBE_COST;
        if (fromTerritory.armySize < probeCost) {
            console.log(`Cannot launch probe: Need ${probeCost} fleet strength, have ${fromTerritory.armySize}`);
            return false;
        }
        
        // Deduct probe cost
        fromTerritory.armySize -= probeCost;
        
        // Visual feedback
        fromTerritory.lastCombatFlash = Date.now();
        
        // Show floating "-10" text
        const floatingText = {
            x: fromTerritory.x + (Math.random() - 0.5) * 20,
            y: fromTerritory.y - 15,
            text: `-${probeCost}`,
            color: '#ff8800',
            startTime: Date.now(),
            duration: 1500
        };
        this.floatingTexts.push(floatingText);
        
        // Calculate probe travel time based on distance
        const distance = GameUtils.distance(fromTerritory.x, fromTerritory.y, toTerritory.x, toTerritory.y);
        const baseSpeed = GAME_CONSTANTS.PROBE_SPEED * this.config.gameSpeed; // Slower probe movement
        const duration = (distance / baseSpeed) * 1000; // Convert to milliseconds
        
        // Create probe object
        const probe = {
            id: `probe-${Date.now()}-${Math.random()}`,
            playerId: this.humanPlayer.id,
            startX: fromTerritory.x,
            startY: fromTerritory.y,
            endX: toTerritory.x,
            endY: toTerritory.y,
            x: fromTerritory.x,
            y: fromTerritory.y,
            targetId: toTerritory.id,
            startTime: Date.now(),
            duration: duration,
            speed: baseSpeed,
            inNebula: false
        };
        
        this.probes.push(probe);
        console.log(`Probe launched from territory ${fromTerritory.id} to ${toTerritory.id} (${distance.toFixed(1)} units, ${(duration/1000).toFixed(1)}s travel)`);
        
        return true;
    }
    
    launchAIProbe(fromTerritory, toTerritory, player) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== player.id) {
            return false;
        }
        
        // Check if target is colonizable
        if (!toTerritory.isColonizable) {
            return false;
        }
        
        // Check probe cost
        const probeCost = GAME_CONSTANTS.PROBE_COST;
        if (fromTerritory.armySize < probeCost) {
            return false;
        }
        
        // Deduct probe cost
        fromTerritory.armySize -= probeCost;
        
        // Calculate probe travel time
        const distance = GameUtils.distance(fromTerritory.x, fromTerritory.y, toTerritory.x, toTerritory.y);
        const baseSpeed = GAME_CONSTANTS.PROBE_SPEED * this.config.gameSpeed;
        const duration = (distance / baseSpeed) * 1000;
        
        // Create probe object
        const probe = {
            id: `probe-${Date.now()}-${Math.random()}`,
            playerId: player.id,
            startX: fromTerritory.x,
            startY: fromTerritory.y,
            endX: toTerritory.x,
            endY: toTerritory.y,
            x: fromTerritory.x,
            y: fromTerritory.y,
            targetId: toTerritory.id,
            startTime: Date.now(),
            duration: duration,
            speed: baseSpeed,
            inNebula: false
        };
        
        this.probes.push(probe);
        return true;
    }
    
    transferFleet(fromTerritory, toTerritory) {
        return this.transferFleetWithAmount(fromTerritory, toTerritory, Math.floor(fromTerritory.armySize / 2));
    }
    
    transferFleetWithAmount(fromTerritory, toTerritory, amount) {
        if (!fromTerritory || !toTerritory) return false;
        if (fromTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (toTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (amount <= 0 || fromTerritory.armySize <= amount) return false;
        
        // Transfer armies
        fromTerritory.armySize -= amount;
        toTerritory.armySize += amount;
        
        // Create ship animation
        this.createShipAnimation(fromTerritory, toTerritory, false);
        
        console.log(`Transferred ${amount} armies from territory ${fromTerritory.id} to ${toTerritory.id}`);
        return true;
    }
    
    createSupplyRoute(fromTerritory, toTerritory) {
        if (!fromTerritory || !toTerritory) return false;
        if (fromTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (toTerritory.ownerId !== this.humanPlayer?.id) return false;
        
        // Find path between territories
        const path = this.findPathBetweenTerritories(fromTerritory, toTerritory);
        if (!path || path.length === 0) {
            console.log('Cannot create supply route: No path found between territories');
            return false;
        }
        
        // Calculate delay based on path length (2 seconds per hop)
        const delay = (path.length - 1) * 2000;
        
        // Create supply route
        this.supplyRoutes.set(fromTerritory.id, {
            targetId: toTerritory.id,
            path: path,
            delay: delay,
            lastShipment: 0
        });
        
        console.log(`Supply route created from ${fromTerritory.id} to ${toTerritory.id} via ${path.length} territories (${delay/1000}s delay)`);
        return true;
    }
    
    findPathBetweenTerritories(start, end) {
        // Simple pathfinding through owned territories
        const visited = new Set();
        const queue = [[start.id]];
        
        while (queue.length > 0) {
            const path = queue.shift();
            const currentId = path[path.length - 1];
            
            if (currentId === end.id) {
                return path; // Found path
            }
            
            if (visited.has(currentId)) continue;
            visited.add(currentId);
            
            const current = this.gameMap.territories[currentId];
            if (!current) continue;
            
            // Explore neighbors
            current.neighbors.forEach(neighborId => {
                const neighbor = this.gameMap.territories[neighborId];
                if (neighbor && neighbor.ownerId === this.humanPlayer?.id && !visited.has(neighborId)) {
                    queue.push([...path, neighborId]);
                }
            });
        }
        
        return null; // No path found
    }
    
    validateSupplyRoutes() {
        // Throttled validation every 30 frames for performance
        if (this.supplyRouteValidationFrame === undefined) {
            this.supplyRouteValidationFrame = 0;
        }
        
        this.supplyRouteValidationFrame++;
        if (this.supplyRouteValidationFrame % 30 !== 0) return;
        
        // Remove invalid supply routes
        const invalidRoutes = [];
        
        this.supplyRoutes.forEach((route, fromId) => {
            const fromTerritory = this.gameMap.territories[fromId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            // Check if territories still exist and are owned by player
            if (!fromTerritory || !toTerritory || 
                fromTerritory.ownerId !== this.humanPlayer?.id || 
                toTerritory.ownerId !== this.humanPlayer?.id) {
                invalidRoutes.push(fromId);
                return;
            }
            
            // Re-validate path
            const newPath = this.findPathBetweenTerritories(fromTerritory, toTerritory);
            if (!newPath) {
                invalidRoutes.push(fromId);
            } else {
                // Update path if it changed
                route.path = newPath;
                route.delay = (newPath.length - 1) * 2000;
            }
        });
        
        // Remove invalid routes
        invalidRoutes.forEach(routeId => {
            this.supplyRoutes.delete(routeId);
            console.log(`Supply route from ${routeId} removed: path no longer valid`);
        });
    }
    
    processSupplyRoutes() {
        // Throttled processing every 60 frames for performance
        if (this.supplyRouteProcessingFrame === undefined) {
            this.supplyRouteProcessingFrame = 0;
        }
        
        this.supplyRouteProcessingFrame++;
        if (this.supplyRouteProcessingFrame % 60 !== 0) return;
        
        // Validate routes first
        this.validateSupplyRoutes();
        
        // Process active supply routes
        this.supplyRoutes.forEach(route => {
            const fromTerritory = this.gameMap.territories[route.sourceId];
            const toTerritory = this.gameMap.territories[route.targetId];
            
            if (fromTerritory && toTerritory && fromTerritory.armySize > 2) {
                // Send new ships when they're generated (but not too frequently)
                const now = Date.now();
                if (!route.lastShipment || now - route.lastShipment > 3000) {
                    const shipsToSend = Math.floor(fromTerritory.armySize / 3); // Send 1/3 of armies
                    
                    if (shipsToSend > 0) {
                        fromTerritory.armySize -= shipsToSend;
                        route.lastShipment = now;
                        
                        // Create delayed transfer with route visualization
                        this.createDelayedSupplyTransfer(fromTerritory, toTerritory, shipsToSend, route.delay);
                    }
                }
            }
        });
    }
    
    createDelayedSupplyTransfer(fromTerritory, toTerritory, shipCount, delay) {
        // Find the supply route to get the path
        const route = this.supplyRoutes.get(fromTerritory.id);
        if (route && route.path && route.path.length > 1) {
            // Create multi-hop ship animation following the path
            this.createSupplyRouteAnimation(route.path, this.humanPlayer.color);
        } else {
            // Fallback to direct animation
            this.createShipAnimation(fromTerritory, toTerritory, false);
        }
        
        // Apply transfer after delay
        setTimeout(() => {
            if (toTerritory.ownerId === this.humanPlayer?.id) {
                toTerritory.armySize += shipCount;
                console.log(`Supply route delivered ${shipCount} ships to territory ${toTerritory.id}`);
            }
        }, delay);
    }
    
    findTerritoryAt(x, y) {
        // Use optimized spatial indexing from GameMap (60% performance improvement)
        return this.gameMap.findTerritoryAt(x, y);
    }
    
    // Core fleet command execution with percentage control
    executeFleetCommand(fromTerritory, toTerritory, fleetPercentage) {
        if (!fromTerritory || !toTerritory || fromTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Validate warp lane connectivity (except for colonizable planets which can be probed)
        if (!toTerritory.isColonizable && !fromTerritory.neighbors.includes(toTerritory.id)) {
            console.log(`Cannot send fleet: No warp lane from ${fromTerritory.id} to ${toTerritory.id}`);
            return;
        }
        
        // Calculate ships to send based on percentage
        const availableShips = Math.max(0, fromTerritory.armySize - 1); // Always leave at least 1
        const shipsToSend = Math.max(1, Math.floor(availableShips * fleetPercentage));
        
        // Visual feedback - show number flying off
        this.showFleetCommandFeedback(fromTerritory, shipsToSend, fleetPercentage);
        
        if (toTerritory.ownerId === this.humanPlayer?.id) {
            // Transfer to own territory with specific amount
            this.transferFleetWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Fleet transfer: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        } else if (toTerritory.isColonizable) {
            // Probe colonizable territory
            this.launchProbe(fromTerritory, toTerritory);
            console.log(`Probe launched from ${fromTerritory.id} to colonizable ${toTerritory.id}`);
        } else {
            // Attack enemy territory with specific amount
            this.attackTerritoryWithAmount(fromTerritory, toTerritory, shipsToSend);
            console.log(`Attack: ${shipsToSend} ships (${Math.round(fleetPercentage * 100)}%) from ${fromTerritory.id} to ${toTerritory.id}`);
        }
    }
    
    // Visual feedback for fleet commands
    showFleetCommandFeedback(territory, shipsToSend, percentage) {
        // Flash the territory briefly
        territory.lastCombatFlash = Date.now();
        
        // Show floating text with ship count
        const floatingText = {
            x: territory.x + (Math.random() - 0.5) * 40,
            y: territory.y - 20,
            text: `-${shipsToSend}`,
            color: percentage >= 0.8 ? '#ff4444' : percentage >= 0.5 ? '#ffaa00' : '#44ff44',
            startTime: Date.now(),
            duration: 1500
        };
        
        if (!this.floatingTexts) this.floatingTexts = [];
        this.floatingTexts.push(floatingText);
    }
    
    attackTerritory(attackingTerritory, defendingTerritory) {
        // Trigger combat flash on both territories
        attackingTerritory.triggerCombatFlash();
        defendingTerritory.triggerCombatFlash();
        
        // Use CombatSystem for actual combat resolution
        if (this.combatSystem) {
            return this.combatSystem.resolveCombat(attackingTerritory, defendingTerritory);
        }
        
        // Fallback combat (should not be reached)
        console.error('CombatSystem not available for combat resolution');
        return false;
    }
    
    attackTerritoryWithAmount(attackingTerritory, defendingTerritory, attackingArmies) {
        if (!attackingTerritory || !defendingTerritory) return false;
        if (attackingTerritory.ownerId !== this.humanPlayer?.id) return false;
        if (attackingArmies <= 0 || attackingTerritory.armySize <= attackingArmies) return false;
        
        // Use CombatSystem for combat resolution
        if (this.combatSystem) {
            return this.combatSystem.resolveCombatWithAmount(attackingTerritory, defendingTerritory, attackingArmies);
        }
        
        // Fallback combat (should not be reached)
        console.error('CombatSystem not available for combat resolution');
        return false;
    }
    
    handleTouchStart(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchStart(e);
        }
    }
    
    handleTouchMove(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchMove(e);
        }
    }
    
    handleTouchEnd(e) {
        // Touch handling moved to InputHandler
        if (this.inputHandler) {
            this.inputHandler.handleTouchEnd(e);
        }
    }
    
    handleDoubleClick(targetTerritory) {
        // Double-click creates supply route between owned territories
        const selectedTerritory = this.inputHandler?.selectedTerritory;
        
        if (!selectedTerritory || !targetTerritory) {
            return;
        }
        
        // Must be owned by player
        if (selectedTerritory.ownerId !== this.humanPlayer?.id || 
            targetTerritory.ownerId !== this.humanPlayer?.id) {
            return;
        }
        
        // Must be different territories
        if (selectedTerritory.id === targetTerritory.id) {
            return;
        }
        
        // Check if connected by owned territories
        const path = this.findPathBetweenTerritories(selectedTerritory, targetTerritory);
        if (path && path.length > 0) {
            this.createSupplyRoute(selectedTerritory, targetTerritory);
            console.log(`Double-click: Supply route created from ${selectedTerritory.id} to ${targetTerritory.id}`);
        } else {
            console.log('Double-click: Territories not connected by owned star lanes for supply route');
        }
    }
    
    restartGame() {
        // Reset game state
        this.gameState = 'lobby';
        this.gameTimer = 10 * 60 * 1000;
        this.selectedTerritory = null;
        
        // Clear players
        this.players = [];
        this.humanPlayer = null;
        
        // Reset map for new generation
        this.gameMap = new GameMap(MapGenerator.mapWidth || 2800, MapGenerator.mapHeight || 2100, this.config);
        this.startGame();
    }
}
```

### client/src/game/Camera.js
```javascript
export class Camera {
    constructor(viewportWidth, viewportHeight) {
        this.x = 0;
        this.y = 0;
        this.zoom = 1.0;
        this.targetX = 0;
        this.targetY = 0;
        this.targetZoom = 1.0;
        
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        
        // Enhanced zoom range for strategic gameplay
        this.minZoom = 0.05; // Extreme zoom out for galaxy-wide view
        this.maxZoom = 8.0;   // Close tactical zoom
        
        // Smooth animation parameters
        this.animationSpeed = 0.1;
        this.isAnimating = false;
        this.animationStartTime = 0;
        this.animationDuration = 1000;
        this.startX = 0;
        this.startY = 0;
        this.startZoom = 1.0;
        
        // Inertial panning system
        this.velocity = { x: 0, y: 0 };
        this.friction = 0.85;
        this.maxVelocity = 15;
        
        // Edge panning system
        this.edgePanSpeed = 300; // pixels per second
        this.edgePanMargin = 50; // pixels from edge
        this.isEdgePanning = false;
        
        // Map boundaries (will be updated when map is loaded)
        this.mapBounds = {
            minX: 0,
            minY: 0,
            maxX: 2000,
            maxY: 1500
        };
        
        // Camera state tracking
        this.lastUpdateTime = Date.now();
        
        // Performance optimization
        this.isDirty = true;
        this.lastTransform = { x: 0, y: 0, zoom: 1 };
    }
    
    updateViewport(width, height) {
        this.viewportWidth = width;
        this.viewportHeight = height;
        this.isDirty = true;
    }
    
    update(deltaTime) {
        const currentTime = Date.now();
        const dt = Math.min(deltaTime / 1000, 1/30); // Cap delta time for stability
        
        // Update smooth animations
        if (this.isAnimating) {
            const elapsed = currentTime - this.animationStartTime;
            const progress = Math.min(elapsed / this.animationDuration, 1);
            const easedProgress = this.easeInOutCubic(progress);
            
            this.x = this.startX + (this.targetX - this.startX) * easedProgress;
            this.y = this.startY + (this.targetY - this.startY) * easedProgress;
            this.zoom = this.startZoom + (this.targetZoom - this.startZoom) * easedProgress;
            
            if (progress >= 1) {
                this.isAnimating = false;
            }
            
            this.isDirty = true;
        }
        
        // Apply inertial movement
        if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
            this.x += this.velocity.x * dt;
            this.y += this.velocity.y * dt;
            
            // Apply friction
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            
            // Stop tiny movements
            if (Math.abs(this.velocity.x) < 0.1) this.velocity.x = 0;
            if (Math.abs(this.velocity.y) < 0.1) this.velocity.y = 0;
            
            this.isDirty = true;
        }
        
        // Apply constraints
        this.applyConstraints();
        
        this.lastUpdateTime = currentTime;
    }
    
    applyConstraints() {
        // Calculate actual map dimensions
        const mapWidth = this.mapBounds.maxX - this.mapBounds.minX;
        const mapHeight = this.mapBounds.maxY - this.mapBounds.minY;
        
        // Calculate viewport size in world space
        const worldViewWidth = this.viewportWidth / this.zoom;
        const worldViewHeight = this.viewportHeight / this.zoom;
        
        // Check if camera can see entire map
        const canSeeEntireMap = worldViewWidth >= mapWidth && worldViewHeight >= mapHeight;
        
        if (canSeeEntireMap) {
            // Auto-center when can see entire map
            this.x = this.mapBounds.minX + mapWidth / 2;
            this.y = this.mapBounds.minY + mapHeight / 2 + 30; // UI offset compensation
            
            // Disable velocity to prevent drift
            this.velocity.x = 0;
            this.velocity.y = 0;
        } else {
            // Normal boundary constraints
            const halfViewWidth = worldViewWidth / 2;
            const halfViewHeight = worldViewHeight / 2;
            
            // Constrain to map boundaries
            this.x = Math.max(this.mapBounds.minX + halfViewWidth, 
                            Math.min(this.mapBounds.maxX - halfViewWidth, this.x));
            this.y = Math.max(this.mapBounds.minY + halfViewHeight, 
                            Math.min(this.mapBounds.maxY - halfViewHeight, this.y));
        }
        
        // Zoom constraints
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.targetZoom));
    }
    
    pan(deltaX, deltaY) {
        // Calculate actual map dimensions for scroll lock check
        const mapWidth = this.mapBounds.maxX - this.mapBounds.minX;
        const mapHeight = this.mapBounds.maxY - this.mapBounds.minY;
        const worldViewWidth = this.viewportWidth / this.zoom;
        const worldViewHeight = this.viewportHeight / this.zoom;
        
        // Check if entire galaxy is visible (scroll lock condition)
        const canSeeEntireMap = worldViewWidth >= mapWidth && worldViewHeight >= mapHeight;
        
        if (canSeeEntireMap) {
            // Completely disable panning when full galaxy is visible
            return;
        }
        
        // Normal panning when zoomed in
        const panSpeed = 1.0 / this.zoom;
        
        // Add to velocity for inertial movement
        this.velocity.x += deltaX * panSpeed * 0.5;
        this.velocity.y += deltaY * panSpeed * 0.5;
        
        // Clamp velocity
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.maxVelocity) {
            this.velocity.x = (this.velocity.x / speed) * this.maxVelocity;
            this.velocity.y = (this.velocity.y / speed) * this.maxVelocity;
        }
        
        this.isDirty = true;
    }
    
    updateEdgePanning(mouseX, mouseY, deltaTime) {
        if (!mouseX || !mouseY) return;
        
        const dt = deltaTime / 1000;
        let panX = 0;
        let panY = 0;
        
        // Check edges
        if (mouseX < this.edgePanMargin) {
            panX = -this.edgePanSpeed * dt;
        } else if (mouseX > this.viewportWidth - this.edgePanMargin) {
            panX = this.edgePanSpeed * dt;
        }
        
        if (mouseY < this.edgePanMargin) {
            panY = -this.edgePanSpeed * dt;
        } else if (mouseY > this.viewportHeight - this.edgePanMargin) {
            panY = this.edgePanSpeed * dt;
        }
        
        if (panX !== 0 || panY !== 0) {
            this.pan(panX, panY);
            this.isEdgePanning = true;
        } else {
            this.isEdgePanning = false;
        }
    }
    
    zoomTo(newZoom, screenX, screenY) {
        const oldZoom = this.zoom;
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
        
        if (screenX !== undefined && screenY !== undefined) {
            // Zoom towards a specific point
            const worldPos = this.screenToWorld(screenX, screenY);
            this.zoom = newZoom;
            const newScreenPos = this.worldToScreen(worldPos.x, worldPos.y);
            
            this.x += (screenX - newScreenPos.x) / this.zoom;
            this.y += (screenY - newScreenPos.y) / this.zoom;
        }
        
        this.applyConstraints();
        this.isDirty = true;
    }
    
    zoom(factor, screenX, screenY) {
        this.zoomTo(this.zoom * factor, screenX, screenY);
    }
    
    centerOn(worldX, worldY) {
        this.x = worldX;
        this.y = worldY;
        this.applyConstraints();
        this.isDirty = true;
    }
    
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX - this.viewportWidth / 2) / this.zoom + this.x,
            y: (screenY - this.viewportHeight / 2) / this.zoom + this.y
        };
    }
    
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom + this.viewportWidth / 2,
            y: (worldY - this.y) * this.zoom + this.viewportHeight / 2
        };
    }
    
    applyTransform(ctx) {
        ctx.save();
        ctx.translate(this.viewportWidth / 2, this.viewportHeight / 2);
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.x, -this.y);
        
        // Track transform for optimization
        this.lastTransform = { x: this.x, y: this.y, zoom: this.zoom };
        this.isDirty = false;
    }
    
    getViewBounds() {
        const halfWidth = this.viewportWidth / (2 * this.zoom);
        const halfHeight = this.viewportHeight / (2 * this.zoom);
        
        return {
            left: this.x - halfWidth,
            right: this.x + halfWidth,
            top: this.y - halfHeight,
            bottom: this.y + halfHeight,
            width: halfWidth * 2,
            height: halfHeight * 2
        };
    }
    
    isPointVisible(worldX, worldY, margin = 0) {
        const bounds = this.getViewBounds();
        return worldX >= bounds.left - margin &&
               worldX <= bounds.right + margin &&
               worldY >= bounds.top - margin &&
               worldY <= bounds.bottom + margin;
    }
    
    isRectVisible(worldX, worldY, width, height, margin = 0) {
        const bounds = this.getViewBounds();
        return worldX + width >= bounds.left - margin &&
               worldX <= bounds.right + margin &&
               worldY + height >= bounds.top - margin &&
               worldY <= bounds.bottom + margin;
    }
    
    getScreenCenter() {
        return {
            x: this.viewportWidth / 2,
            y: this.viewportHeight / 2
        };
    }
    
    getWorldCenter() {
        return { x: this.x, y: this.y };
    }
    
    animateTo(worldX, worldY, zoomLevel = null, duration = 1000) {
        this.startX = this.x;
        this.startY = this.y;
        this.startZoom = this.zoom;
        this.targetX = worldX;
        this.targetY = worldY;
        this.targetZoom = zoomLevel !== null ? Math.max(this.minZoom, Math.min(this.maxZoom, zoomLevel)) : this.zoom;
        
        this.isAnimating = true;
        this.animationStartTime = Date.now();
        this.animationDuration = duration;
        
        // Clear velocity during animation
        this.velocity.x = 0;
        this.velocity.y = 0;
    }
    
    focusOnTerritory(territory, optimalZoom = null) {
        if (!territory) return;
        
        // Calculate optimal zoom if not provided
        if (optimalZoom === null) {
            const territorySize = territory.radius * 2;
            const desiredScreenSize = Math.min(this.viewportWidth, this.viewportHeight) * 0.3;
            optimalZoom = Math.max(1.0, desiredScreenSize / territorySize);
        }
        
        this.animateTo(territory.x, territory.y, optimalZoom, 800);
    }
    
    getZoomLevel() {
        return this.zoom;
    }
    
    frameRegion(territories, padding = 150) {
        if (!territories || territories.length === 0) return;
        
        // Calculate bounding box
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        territories.forEach(territory => {
            minX = Math.min(minX, territory.x - territory.radius);
            minY = Math.min(minY, territory.y - territory.radius);
            maxX = Math.max(maxX, territory.x + territory.radius);
            maxY = Math.max(maxY, territory.y + territory.radius);
        });
        
        // Add padding
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;
        
        // Calculate required zoom
        const regionWidth = maxX - minX;
        const regionHeight = maxY - minY;
        const zoomX = this.viewportWidth / regionWidth;
        const zoomY = this.viewportHeight / regionHeight;
        const optimalZoom = Math.min(zoomX, zoomY, this.maxZoom);
        
        // Calculate center
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        this.animateTo(centerX, centerY, optimalZoom, 1200);
    }
    
    getState() {
        return {
            x: this.x,
            y: this.y,
            zoom: this.zoom,
            targetX: this.targetX,
            targetY: this.targetY,
            targetZoom: this.targetZoom
        };
    }
    
    setState(state) {
        this.x = state.x || 0;
        this.y = state.y || 0;
        this.zoom = state.zoom || 1;
        this.targetX = state.targetX || this.x;
        this.targetY = state.targetY || this.y;
        this.targetZoom = state.targetZoom || this.zoom;
        this.applyConstraints();
        this.isDirty = true;
    }
    
    getDebugInfo() {
        const bounds = this.getViewBounds();
        return {
            position: `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`,
            zoom: `${(this.zoom * 100).toFixed(1)}%`,
            bounds: `${bounds.width.toFixed(1)} x ${bounds.height.toFixed(1)}`,
            velocity: `(${this.velocity.x.toFixed(2)}, ${this.velocity.y.toFixed(2)})`,
            isAnimating: this.isAnimating,
            isEdgePanning: this.isEdgePanning
        };
    }
    
    // Easing functions
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
}
```

## COMPLETE PROJECT STRUCTURE

The Star Throne codebase contains approximately 15,000+ lines of code organized into:

### Frontend Components (React)
- TitleScreen.tsx - Epic cinematic title with streaming starfield
- GameModeSelector.tsx - Single/multiplayer mode selection  
- GameConfigScreen.tsx - Single-player configuration
- MultiplayerLobby.tsx - Room-based multiplayer lobby

### Core Game Engine (JavaScript Modules)
- StarThrone.js (3,000+ lines) - Main game controller
- Camera.js - Strategic viewport with RTS-style controls
- GameMap.js - Procedural galaxy generation
- Territory.js - Individual planet logic
- Player.js - AI behavior and human player management
- GameUI.js - Canvas-based UI rendering

### Specialized Systems
- DiscoverySystem.js - Planet exploration with 11 discovery types
- AnimationSystem.js - Ship movements and visual effects
- InputHandler.js - Mouse/touch controls with FSM
- CombatSystem.js - Battle resolution and throne mechanics
- SupplySystem.js - Automated fleet transfers
- PerformanceManager.js - FPS optimization and profiling

### Backend Infrastructure
- Express.js server with Socket.IO WebSocket support
- Server-authoritative game engine preventing cheating
- Real-time multiplayer with delta state broadcasting
- Room management supporting up to 100 players

This represents a complete, production-ready browser-based RTS game with advanced features including organic galaxy generation, strategic camera systems, discovery mechanics, and multiplayer infrastructure.