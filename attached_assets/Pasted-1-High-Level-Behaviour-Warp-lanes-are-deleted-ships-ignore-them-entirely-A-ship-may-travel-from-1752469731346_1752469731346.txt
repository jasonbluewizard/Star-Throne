1. High‑Level Behaviour
Warp lanes are deleted – ships ignore them entirely.

A ship may travel from planet X to planet Y iff dist(X,Y) ≤ R where R is the owner‑player’s current range stat.

If a player issues a move order to a destination outside one hop, the engine finds the shortest hop‑count path though any planets (friendly, neutral, enemy).

Ships will physically stop at each intermediate planet, fight if needed, then continue next tick.

Range can be upgraded by tech (+15 % each tier). Changing R triggers a rebuild of that player’s adjacency graph.

When a player loses a planet, all paths are re‑validated at the next hop; stranded ships look for a new path or remain at current planet if none exists.

2. Data‑Model Changes
2.1 Player.ts
ts
Copy
interface Player {
  id: number;
  name: string;
  color: string;
  range: number;        // NEW – max jump distance
  rangeLevel: number;   // tier index for upgrades
  // ...
}
2.2 Pre‑computed Spatial Helpers
ts
Copy
// Build once at match start
const distanceMatrix: Float32Array[] = buildDistanceMatrix(planets);

// Per‑player, rebuild when player.range changes
type AdjList = Int16Array[];  // indices of neighbour planets
const playerAdjacency: Map<PlayerID, AdjList> = new Map();
3. Path‑Finding API
3.1 Signature
ts
Copy
function findPath(
  playerId: number,
  startPlanetId: number,
  targetPlanetId: number
): number[] | null;          // returns list of planet IDs (incl. start+target) or null
3.2 Algorithm
Use BFS over playerAdjacency[playerId] – hop cost is uniform → shortest hops.

Stop when current === target.

If BFS exhausts nodes, return null (unreachable).

Complexity: O(V + E) per query; with ≤ 200 planets this is trivial on a Chromebook.

3.3 Rebuild Trigger
ts
Copy
function updatePlayerRange(player: Player, newRange: number) {
  player.range = newRange;
  player.rangeLevel++;
  playerAdjacency.set(player.id, buildAdjacencyList(newRange));
}
buildAdjacencyList(R) walks the distanceMatrix once per planet and keeps neighbours where d ≤ R.

4. Ship Dispatch Flow
ts
Copy
function onMoveOrder(playerId, fromId, toId, shipCount) {
  const path = findPath(playerId, fromId, toId);
  if (!path) { ui.flashError("Target out of range!"); return; }

  const fleet = createFleet(shipCount, path, playerId);
  planets[fromId].garrison -= shipCount;
}
Fleet stores:

ts
Copy
interface Fleet {
  path: Int16Array;         // immutable list of waypoints
  nextIndex: number;        // cursor into path
  eta: number;              // time until arrival at path[nextIndex]
  speed: number;            // units per second (may stay constant for MVP)
  owner: number;
  strength: number;
}
Each tick:

Decrement eta.

When eta ≤ 0:

Land on path[nextIndex].

If nextIndex === path.length-1 → fleet merges w/ planet or battles.

Else increment nextIndex and compute new eta from current → next planet distance.

Combat uses existing planet‑capture code – no changes needed.

5. UI / UX
Feature	Implementation Notes
Range Preview	Hold SPACE → draw translucent circle radius = player.range / mapScale around every owned planet.
Invalid Path Feedback	During drag, if findPath() fails on cursor‑update, line turns red & tooltip “Out of range”.
Path Line	After order, render polyline through path planets (dashed). Fades after orderDisplayTime.
Upgrade Button	In tech UI, new row “Hyperdrive Range +15 % (cost X)”. On purchase call updatePlayerRange().
Tooltip Updates	Planet panel shows “In‑Range neighbours: n”.

6. AI Adaptation
Target Scoring unchanged.

Feasibility check now calls findPath() instead of lane lookup.

Expansion heuristic: choose nearest neutral within one hop; else nearest reachable via BFS.

Tech choice: if reachableEnemyPlanets < 3 → prioritize Range upgrade.

Minimal edits – AI still calls issueMoveOrder(); underlying path code finds hops.

7. Performance Notes (Chromebook)
distanceMatrix adds N² floats ( ≤ 200² ≈ 40 k ≅ 160 KB).

Rebuilding adjacency per range upgrade touches N² once – infrequent.

Path‑find BFS is microseconds (<0.2 ms) for 200 nodes.

No per‑frame garbage: pre‑allocate Int16Array for paths; fleets store reference, not copy.

8. Migration Steps for Codex
Delete / disable lane graph code (lanes.ts, drawLanes() etc.).

Add range to Player; seed with constant BASE_RANGE.

Generate distanceMatrix at match init.

Implement buildAdjacencyList(range) and store per player.

Refactor issueMoveOrder() to use new findPath(); route fleets.

Replace any lane‑based reachability checks in AI and UI.

Hook range upgrade tech to updatePlayerRange().

Add SPACE‑key range‑circle overlay in render loop.

Test:

Single hop.<br> Expected: fleet arrives, capture works.

Multi‑hop chain.<br> Expected: fleet steps planet→planet.

Path blocked (planet lost mid‑route).<br> Expected: fleet battles or idles, no crash.

Range upgrade during game.<br> Expected: new orders allow further targets; old fleets unaffected.

Deliver those nine edits and lanes are gone; range‑gated movement is live.

