Thanks for confirming. I’ll now dig into the likely root cause of the missing InputHandler event listeners—namely, the unhandled JavaScript rejection during game initialization. I’ll analyze the StarThrone initialization flow, canvas setup timing, and any potential async or lifecycle problems that could prevent InputHandler from completing.

I’ll follow up shortly with a diagnosis and targeted fix for restoring event handler setup, so that Fleet click events are properly received.


# Diagnosis of Initialization Failure

The symptoms point to a JavaScript error during game start that prevents the **InputHandler** from attaching its mouse event listeners. In particular, an “unhandledrejection” error in the console implies a promise was rejected without a catch, halting further initialization. Since `StarThrone.init()` is synchronous in our snippet, this likely means some async operation (e.g. asset or config loading) failed.  The result is that **`InputHandler` never finishes setup**, so we see *no* “InputHandler: Setting up event listeners” log, and the test click handler (`console.log('*** DIRECT CANVAS CLICK DETECTED ***')`) never fires.

Key points from the code:

* **Canvas creation:**  In `StarThrone.init()` (around line \~281 of *StarThrone.js*), the code calls `this.setupCanvas()`, which does `root.innerHTML = ''` and then `root.appendChild(canvas)`. This should set `this.canvas` on the game instance and attach it to the DOM. If this succeeds, `game.canvas` is non-`null` when `new InputHandler(this)` runs.
* **InputHandler constructor:** In *InputHandler.js*, the constructor immediately does `this.canvas = game.canvas` and then calls `this.setupEventListeners()`. That method attaches `'mousedown'`, `'mousemove'`, etc., to `this.canvas`. Any error here (e.g. if `this.canvas` is null) would throw a TypeError.
* **Try/catch around InputHandler:** `StarThrone.init()` already wraps `new InputHandler(this)` in a `try/catch`, logging “Failed to initialize InputHandler” on error. However, an error thrown inside `InputHandler` would be caught and logged via `console.error`, **not** as an unhandled promise. The fact we see an *unhandled* rejection suggests the culprit is likely elsewhere — for example, an async call in initialization that wasn’t caught.

From the **debug log** we know:

* *Fleet system* initialized correctly and rendered (“Fleet: Rendering 0 animations”), so `this.fleet = new Fleet(this)` succeeded.
* No **InputHandler** logs appear at all, which means either:

  * The constructor threw immediately (caught by `init()`) **before** the log in `setupEventListeners`.
  * Or an earlier error (possibly async) aborted initialization so that `new InputHandler()` never ran.

The unhandled promise error strongly suggests we had an asynchronous operation in `init()`. For example, if `setupCanvas()` or `GameMap` or `GameUI` performed a `fetch()` or image loading without `.catch()`, that could produce `unhandledrejection`. Such an error would interrupt `init()` and skip setting up the InputHandler listeners.

# Confirming Canvas and Event Listener Setup

1. **Canvas exists before InputHandler:** The code calls `this.setupCanvas()` (StarThrone.js line \~281). We should verify that this indeed sets `this.canvas`. If `this.canvas` were `null`, then `InputHandler`’s `this.canvas` would also be `null`, and calls to `addEventListener` would throw. As a diagnostic, we can log:

   ```js
   console.log('StarThrone: canvas exists?', !!this.canvas);
   ```

   right before `new InputHandler(this)`. This will tell us if the canvas was properly created (should log `true`).

2. **InputHandler.setupEventListeners is invoked:** In *InputHandler.js*, the constructor calls `this.setupEventListeners()`. To check this, we rely on the `console.log('InputHandler: Setting up event listeners...')` line. Since it never appears, the constructor likely threw **before** or **during** this call. If `this.inputFSM = new InputStateMachine(game)` threw an exception, the setup would abort. We should ensure `InputStateMachine` (not shown) is not failing.

3. **Safety of `addEventListener`:** Calling `this.canvas.addEventListener(...)` is safe only if `this.canvas` is a real element. If not, it will throw a TypeError (e.g. “Cannot read property 'addEventListener' of null”). We must guard against that.

# Fixes and Code Changes

To resolve the issue, we should **catch and log errors** in all critical areas, and ensure no asynchronous errors slip past. The following changes are recommended:

* **StarThrone.init() (file: `StarThrone.js`):** Wrap all initialization steps in error handling and verify canvas creation. For example, around line 280–290:

  ```js
  init() {
      // 1. Setup canvas and verify it
      this.setupCanvas();
      if (!this.canvas) {
          console.error('StarThrone.js: setupCanvas() did not create a canvas element');
      }

      // 2. (Optional) wrap event listener setup if asynchronous
      this.setupEventListeners(); 

      // 3. Create game systems
      this.gameMap = new GameMap(2000, 1500, this.config);
      this.camera  = new Camera(this.canvas.width, this.canvas.height);
      this.ui      = new GameUI(this.canvas, this.camera);

      // 4. Initialize InputHandler inside try/catch (already present)
      try {
          this.inputHandler = new InputHandler(this);
          console.log('InputHandler initialized successfully');
      } catch (error) {
          console.error('Failed to initialize InputHandler:', error);
      }

      // 5. Initialize Fleet
      this.fleet = new Fleet(this);
      console.log('Fleet control system initialized');

      // 6. Sanity check: InputHandler has fleet reference
      console.log('InputHandler Fleet reference check:', !!this.inputHandler?.game.fleet);

      // 7. Test canvas click listener (for debugging)
      this.canvas.addEventListener('click', (e) => {
          console.log('*** DIRECT CANVAS CLICK DETECTED ***');
          console.log('Click coordinates:', e.clientX, e.clientY);
      });
  }
  ```

  * **Line references:** The `new InputHandler(this)` is around line \~290 in `StarThrone.js`. The test click listener is around line \~301. After these changes, clicking the canvas should at least log `"*** DIRECT CANVAS CLICK DETECTED ***"` if the canvas is correctly in the DOM. If that still doesn’t appear, something is blocking events (e.g. a full-screen overlay or CSS issue).

* **Make init() async if needed:** If any of the calls (like `setupCanvas()` or `setupEventListeners()`) involve promises, mark `init` as `async` and use `await`. For example:

  ```js
  async init() {
      try {
          await this.setupCanvas();
          await this.setupEventListeners();
          // ... (other awaits if needed)
      } catch (err) {
          console.error('StarThrone.init error:', err);
      }
      // continue with InputHandler, Fleet, etc.
  }
  ```

  This ensures any promise rejection is caught and logged, preventing an unhandled rejection. (Of course, `setupCanvas` and `setupEventListeners` must return Promises for `await` to apply.)

* **InputHandler constructor (file: `InputHandler.js`):** Add try/catch around the listener setup and check `this.canvas`:

  ```js
  constructor(game) {
      this.game = game;
      this.canvas = game.canvas;

      // ... (initialize state and FSM)
      this.inputFSM = new InputStateMachine(game);
      
      // Now attempt to set up event listeners
      try {
          this.setupEventListeners();
          console.log('InputHandler: Mouse event listeners attached');
      } catch (e) {
          console.error('InputHandler: Failed to set up event listeners', e);
      }
  }
  ```

* **InputHandler.setupEventListeners() (file: `InputHandler.js`):** At the top of this method (around line \~308 in the code above), check for a valid canvas and catch any errors when adding listeners:

  ```js
  setupEventListeners() {
      console.log('InputHandler: Setting up event listeners on canvas:', !!this.canvas);
      if (!this.canvas) {
          console.error('InputHandler.js: Canvas element is null – cannot attach mouse listeners');
          return;
      }
      try {
          this.canvas.addEventListener('mousedown', e => this.handleMouseDown(e));
          this.canvas.addEventListener('mousemove', e => this.handleMouseMove(e));
          this.canvas.addEventListener('mouseup',   e => this.handleMouseUp(e));
          this.canvas.addEventListener('wheel',     e => this.handleWheel(e));
          // ... (other listeners)
      } catch (e) {
          console.error('InputHandler.js: Error attaching event listeners to canvas', e);
      }
  }
  ```

  This makes it explicit: if `this.canvas` is unexpectedly null, we log an error rather than throwing silently. If the listener calls throw (unlikely, but just in case), we catch and log that too.

* **General async error handling:** If *any* initialization step returns a promise, ensure it’s caught. For example, if `GameMap` loads a JSON map file internally, modify it to either use callbacks or return a promise that `init()` can `await` with `try/catch`. The goal is to eliminate any uncaught promise. In practice, add a global handler temporarily to see where the rejection comes from:

  ```js
  window.addEventListener('unhandledrejection', event => {
      console.error('Unhandled promise rejection:', event.reason);
  });
  ```

  This may reveal which part of the init is failing.

# Summary of Code Changes

* **StarThrone.js** (around lines \~281–294):  Confirm `this.canvas` is set after `setupCanvas()`, and wrap the existing `new InputHandler(this)` in a `try/catch` (already present). Optionally make `init()` async if using `await`.
* **InputHandler.js** (constructor):  Surround `this.setupEventListeners()` with try/catch and log success or failure.
* **InputHandler.js** (setupEventListeners):  Add a check for `this.canvas == null` with an error log, and wrap the `addEventListener` calls in try/catch.
* **(Optional)** In *StarThrone.js*, add debug logs around initialization steps to ensure each phase completes.

After applying these fixes, reload the game and watch the console logs. You should see **either** the normal initialization messages (“InputHandler initialized successfully” and “InputHandler: Setting up event listeners…”) **or** a clear error message at the point of failure. This will both eliminate the silent “unhandledrejection” and allow the InputHandler to attach its mouse event listeners so that `Fleet.handleClick` can be invoked on canvas clicks.
