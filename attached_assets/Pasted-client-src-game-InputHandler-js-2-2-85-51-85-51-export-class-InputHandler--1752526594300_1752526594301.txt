client/src/game/InputHandler.js
+2
-2

@@ -85,51 +85,51 @@ export class InputHandler {
            } catch {
                // Ignore errors if pointer capture isn't supported
            }
        }
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        this.lastMousePos = { ...this.mousePos };

        const worldPos = this.game.camera.screenToWorld(this.mousePos.x, this.mousePos.y);
        const territory = this.game.findTerritoryAt(worldPos.x, worldPos.y);
        
        console.log('🔍 Mouse down details:', {
            screenPos: this.mousePos,
            worldPos: worldPos,
            territory: territory ? territory.id : 'none',
            humanPlayerId: this.game.humanPlayer?.id,
            territoryOwner: territory?.ownerId
        });

        if (territory && territory.ownerId === this.game.humanPlayer?.id) {
            // Begin fleet drag from owned territory
            console.log('🎯 Starting fleet drag from territory', territory.id, 'with', territory.armySize, 'armies');
            this.isFleetDragging = true;
            this.fleetSource = territory;
            this.isDragging = false;
            if (this.game) this.game.dragPathCache = null;
            if (this.game) this.game.dragPathPreviewCache = {};
            console.log('🚀 Fleet drag started for player territory', territory.id);
        } else {
            // Start panning the map
            this.isDragging = true;
            console.log('🖱️ Starting map pan');
        }
    }

    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const newPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };

        if (this.isFleetDragging) {
            // Just update position for preview
            console.log('🎯 Fleet dragging - updating preview position');
        } else if (this.isDragging) {
            const dx = newPos.x - this.lastMousePos.x;
            const dy = newPos.y - this.lastMousePos.y;
            this.game.camera.pan(-dx, -dy);
        }

        this.game.camera.updateEdgePanning(newPos.x, newPos.y, 16);
        const worldPos = this.game.camera.screenToWorld(newPos.x, newPos.y);
        this.hoveredTerritory = this.game.findTerritoryAt(worldPos.x, worldPos.y);
        this.lastMousePos = newPos;
@@ -150,51 +150,51 @@ export class InputHandler {

        if (this.isFleetDragging && this.fleetSource) {
            const worldPos = this.game.camera.screenToWorld(releasePos.x, releasePos.y);
            const target = this.game.findTerritoryAt(worldPos.x, worldPos.y);
            console.log('🎯 Fleet drag release:', {
                source: this.fleetSource.id,
                target: target ? target.id : 'none',
                sourceArmies: this.fleetSource.armySize
            });
            if (target && target.id !== this.fleetSource.id) {
                // Determine if this is an attack or transfer
                const isAttack = target.ownerId !== this.game.humanPlayer?.id;
                console.log('🚀 Issuing fleet command from', this.fleetSource.id, 'to', target.id, 'isAttack:', isAttack);
                console.log('🔍 Target owner:', target.ownerId, 'Human player:', this.game.humanPlayer?.id);
                
                // Call async method properly
                this.game.issueFleetCommand(this.fleetSource, target, 0.5, isAttack).catch(err => {
                    console.error('❌ Fleet command failed:', err);
                });
            }
        }

        this.isDragging = false;
        this.isFleetDragging = false;
        this.fleetSource = null;
        if (this.game) this.game.dragPathCache = null;
        if (this.game) this.game.dragPathPreviewCache = {};
        console.log('🔚 Mouse up - fleet drag ended');
    }

    handleWheel(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.02, Math.min(8.0, this.game.camera.targetZoom * zoomFactor));
        this.game.camera.zoomTo(newZoom, mouseX, mouseY);
    }

    handleTouchStart(e) {
        e.preventDefault();
        for (const t of e.changedTouches) {
            this.touchState.activeTouches.set(t.identifier, { x: t.clientX, y: t.clientY });
        }
        if (this.touchState.activeTouches.size === 2) {
            const [a, b] = Array.from(this.touchState.activeTouches.values());
            this.touchState.lastTouchDistance = Math.hypot(b.x - a.x, b.y - a.y);
            this.touchState.lastPinchCenter = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
        }
    }

client/src/game/StarThrone.js
+52
-5

@@ -17,52 +17,56 @@ import { DiscoverySystem } from './DiscoverySystem';
import { AnimationSystem } from './AnimationSystem';
import { UIManager } from './UIManager';
import { AIManager } from './AIManager';
import FloodModeController from './FloodModeController';

export default class StarThrone {
    constructor(config = {}) {
        this.canvas = null;
        this.ctx = null;
        this.gameMap = null;
        this.players = [];
        this.humanPlayer = null;
        this.camera = null;
        this.ui = null;
        
        // Game configuration from config screen
        this.config = {
            playerName: config.playerName || 'Player',
            aiCount: config.aiCount || GAME_CONSTANTS.DEFAULT_SINGLE_PLAYER_AI_COUNT,
            mapSize: config.mapSize || GAME_CONSTANTS.DEFAULT_MAP_SIZE_TERRITORIES,
            gameSpeed: config.gameSpeed || 1.0,
            layout: config.layout || 'organic',
            ...config
        };

        // Optional automation features
        // Optional automation features disabled by default to prevent
        // unexpected automated army movements
        this.autoMoveEnabled = config.autoMoveEnabled ?? false;

        // Cache for drag path previews to avoid repeated pathfinding
        this.dragPathPreviewCache = {};
        
        // Game state
        this.gameState = 'lobby'; // lobby, playing, ended
        this.paused = false; // Add pause for low-performance devices
        this.gameTimer = 10 * 60 * 1000; // 10 minutes
        this.maxPlayers = 100;
        this.currentPlayers = 0;
        this.gameInitialized = false; // Prevent early win condition checks
        
        // Persistent star lane discovery system
        this.discoveredLanes = new Set(); // Stores "id1-id2" strings for permanently visible lanes
        
        // Throne star validation timer
        this.throneStarValidationTimer = 0;
        
        // Home system flashing
        this.homeSystemFlashStart = null;
        this.homeSystemFlashDuration = 3000; // 3 seconds
        
        // Modular systems (initialized in init())
        this.inputHandler = null;
        this.renderer = null;
        this.combatSystem = null;
        this.supplySystem = null;
        this.pathfindingService = null;
@@ -2264,50 +2268,51 @@ export default class StarThrone {
        }
        
        // Save context for camera transform
        this.ctx.save();
        
        // Apply camera transformation
        this.camera.applyTransform(this.ctx);
        
        // Render game world with Level of Detail (LOD) optimizations
        const lodLevel = this.getLODLevel();
        
        this.renderNebulas();
        this.renderTerritories();
        
        // Render connections based on LOD level
        if (lodLevel >= 2) {
            this.renderConnections();
        }
        
        // Render supply routes for operational and tactical view
        if (lodLevel >= 2) {
            this.renderSupplyRoutes();
        }
        
        this.renderDragPreview();
        this.renderDragCombatPreview();
        
        // Debug: Check InputHandler state
        if (this.inputHandler && this.frameCount % 30 === 0) {
            const state = this.inputHandler.getInputState();
            if (state.fleetDragging) {
                console.log('🔍 InputHandler state:', state);
            }
        }
        this.renderProportionalDragUI();
        this.renderTransferPreview();
        
        // Ship animations and probes for tactical view
        if (lodLevel >= 2) {
            // Use AnimationSystem for ship animations
            if (this.animationSystem) {
                this.animationSystem.renderShipAnimations(this.ctx, this.camera);
            }
            // this.renderProbes(); // Probe rendering disabled
        }
        
        // Combat particles should always render regardless of LOD level
        if (this.animationSystem) {
            this.animationSystem.renderCombatParticles(this.ctx, this.camera);
        }
        
@@ -2652,68 +2657,69 @@ export default class StarThrone {
            this.ctx.globalAlpha = 0.8;
            this.ctx.setLineDash([5, 5]);
            
            this.ctx.beginPath();
            this.ctx.moveTo(this.dragStart.x, this.dragStart.y);
            this.ctx.lineTo(worldPos.x, worldPos.y);
            this.ctx.stroke();
            
            this.ctx.restore();
        }

        // Preview line for fleet dragging
        if (this.inputHandler && this.inputHandler.isFleetDragging && this.inputHandler.fleetSource) {
            console.log('🎨 Rendering fleet drag preview', {
                isFleetDragging: this.inputHandler.isFleetDragging,
                fleetSource: this.inputHandler.fleetSource.id,
                mousePos: this.inputHandler.mousePos
            });
            const worldPos = this.camera.screenToWorld(this.inputHandler.mousePos.x, this.inputHandler.mousePos.y);
            const targetTerritory = this.findTerritoryAt(worldPos.x, worldPos.y);

            this.ctx.save();

            let path = null;
            if (targetTerritory) {
                if (!this.dragPathCache || this.dragPathCache.targetId !== targetTerritory.id) {
                    this.dragPathCache = { targetId: targetTerritory.id, path: null };
                const key = targetTerritory.id;
                if (!(key in this.dragPathPreviewCache)) {
                    this.dragPathPreviewCache[key] = null;
                    const fn = targetTerritory.ownerId === this.humanPlayer?.id ?
                        this.pathfindingService.findShortestPath(
                            this.inputHandler.fleetSource.id,
                            targetTerritory.id,
                            this.gameMap,
                            this.humanPlayer.id
                        ) : this.pathfindingService.findAttackPath(
                            this.inputHandler.fleetSource.id,
                            targetTerritory.id,
                            this.gameMap,
                            this.humanPlayer.id
                        );
                    fn.then(p => { this.dragPathCache.path = p; }).catch(() => { this.dragPathCache.path = null; });
                    fn.then(p => { this.dragPathPreviewCache[key] = p; }).catch(() => { this.dragPathPreviewCache[key] = null; });
                }

                path = this.dragPathCache.path;
                path = this.dragPathPreviewCache[key];
            }

            if (path && path.length > 1) {
                this.ctx.strokeStyle = targetTerritory.ownerId === this.humanPlayer?.id ? '#44ff44' : '#ff4444';
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = '#ffffaa';
                this.ctx.shadowBlur = 8;
                this.ctx.beginPath();
                for (let i = 0; i < path.length - 1; i++) {
                    const a = this.gameMap.territories[path[i]];
                    const b = this.gameMap.territories[path[i + 1]];
                    if (!a || !b) continue;
                    if (i === 0) this.ctx.moveTo(a.x, a.y);
                    this.ctx.lineTo(b.x, b.y);
                }
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            } else {
                // Fallback to direct line if no path found
                if (targetTerritory && this.inputHandler.fleetSource.neighbors.includes(targetTerritory.id)) {
                    this.ctx.strokeStyle = targetTerritory.ownerId === this.humanPlayer?.id ? '#44ff44' : '#ff4444';
                    this.ctx.lineWidth = 3;
                } else {
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
@@ -2889,50 +2895,89 @@ export default class StarThrone {
        let borderColor = '#ffffff';
        if (to.ownerId === this.humanPlayer?.id) {
            borderColor = '#00ff00'; // Green for transfer
        } else {
            borderColor = '#ff4444'; // Red for attack
        }
        
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
        
        // Text
        this.ctx.fillStyle = '#00ff00'; // Green for send
        this.ctx.fillText(sendText, bgX + padding, bgY + lineHeight);

        this.ctx.fillStyle = '#ffffff'; // White for keep
        this.ctx.fillText(keepText, bgX + padding, bgY + lineHeight * 2);

        if (resultText) {
            this.ctx.fillStyle = resultColor;
            this.ctx.fillText(resultText, bgX + padding, bgY + lineHeight * 3);
        }
        
        this.ctx.restore();
    }

    renderDragCombatPreview() {
        if (!this.inputHandler?.isFleetDragging || !this.inputHandler.fleetSource) return;

        const from = this.inputHandler.fleetSource;
        const worldPos = this.camera.screenToWorld(this.inputHandler.mousePos.x, this.inputHandler.mousePos.y);
        const to = this.findTerritoryAt(worldPos.x, worldPos.y);
        if (!to || to.id === from.id || to.ownerId === this.humanPlayer?.id) return;

        const percentage = 0.75; // Attacks send 75% when dragging
        const available = Math.max(0, from.armySize - 1);
        const shipsToSend = Math.min(available, Math.max(1, Math.floor(from.armySize * percentage)));
        const preview = this.combatSystem?.calculateCombatPreview(from, to, shipsToSend);
        if (!preview) return;

        const screenPos = this.camera.worldToScreen(to.x, to.y);
        const padding = 6;
        const lineHeight = 16;
        this.ctx.save();
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';

        const bgWidth = 80;
        const bgHeight = lineHeight * 2 + padding;
        const bgX = screenPos.x - bgWidth / 2;
        const bgY = screenPos.y - 50;

        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
        this.ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
        this.ctx.strokeStyle = preview.winChance >= 50 ? '#44ff44' : '#ff4444';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);

        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillText(`WIN ${preview.winChance}%`, screenPos.x, bgY + lineHeight);
        this.ctx.fillText(`${shipsToSend} vs ${preview.defendingArmies}`, screenPos.x, bgY + lineHeight * 2);

        this.ctx.restore();
    }
    
    renderFloatingTexts() {
        if (!this.floatingTexts) return;
        
        this.ctx.save();
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        
        // Update and render floating texts
        const now = Date.now();
        this.floatingTexts = this.floatingTexts.filter(text => {
            const elapsed = now - text.startTime;
            if (elapsed >= text.duration) return false;
            
            // Calculate animation progress
            const progress = elapsed / text.duration;
            const alpha = 1 - progress;
            const yOffset = progress * 30; // Float upward
            
            // Render text
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = text.color;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            
@@ -3723,66 +3768,68 @@ export default class StarThrone {
        const isDirectlyConnected = fromTerritory.neighbors && fromTerritory.neighbors.includes(toTerritory.id);
        
        if (isDirectlyConnected) {
            // Direct connection - use simple command
            const commandType = isAttack ? 'attack' : 'transfer';
            console.log(`🛣️ Direct connection: using ${commandType}`);
            this.executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, commandType);
        } else {
            // Not directly connected - find path through warp lanes
            if (isAttack) {
                // For attacks, find path through any territory to get to target
                const attackPath = await this.pathfindingService.findAttackPath(
                    fromTerritory.id, 
                    toTerritory.id, 
                    this.gameMap, 
                    this.humanPlayer.id
                );
                
                if (attackPath && attackPath.length > 1) {
                    console.log(`🛣️ Multi-hop attack path: ${attackPath.join(' -> ')}`);
                    this.executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, 'multi-hop-attack', attackPath);
                } else if (isDirectlyConnected) {
                    this.executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, 'attack');
                } else {
                    console.log(`🛣️ No warp lane path found; attack cancelled`);
                    if (this.uiManager) this.uiManager.showError('NO GO - path blocked');
                    return;
                }
            } else {
                // For transfers, find path through friendly territories only
                const transferPath = await this.pathfindingService.findShortestPath(
                    fromTerritory.id, 
                    toTerritory.id, 
                    this.gameMap, 
                    this.humanPlayer.id
                );
                
                if (transferPath && transferPath.length > 1) {
                    console.log(`🛣️ Multi-hop transfer path: ${transferPath.join(' -> ')}`);
                    this.executeFleetCommand(fromTerritory, toTerritory, fleetPercentage, 'multi-hop-transfer', transferPath);
                } else {
                    console.log(`🛣️ No friendly path found for transfer ${fromTerritory.id} -> ${toTerritory.id}`);
                    if (this.uiManager) this.uiManager.showError('NO GO - path blocked');
                    // No path means territories aren't connected through friendly space
                    return;
                }
            }
        }
    }
    
    executeMultiHopTransfer(fromTerritory, toTerritory, shipsToSend, path) {
        // Validate path
        if (!path || path.length < 2) {
            console.error('Invalid path for multi-hop transfer');
            return;
        }
        
        // Execute transfer on source territory
        fromTerritory.armySize -= shipsToSend;
        
        // Create multi-hop animation following the path
        this.createSupplyRouteAnimation(path.map(id => this.gameMap.territories[id]), this.humanPlayer.color);
        
        // Calculate delivery delay based on path length (0.8 seconds per hop to match animation)
        const deliveryDelay = (path.length - 1) * 800;
        
        // Schedule delivery to destination
        setTimeout(() => {