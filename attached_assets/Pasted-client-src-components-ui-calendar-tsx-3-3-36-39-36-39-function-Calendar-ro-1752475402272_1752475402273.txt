client/src/components/ui/calendar.tsx
+3
-3

@@ -36,39 +36,39 @@ function Calendar({
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-8 w-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
        IconLeft: ({ className, ...props }: { className?: string }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
        IconRight: ({ className, ...props }: { className?: string }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      } as any}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
client/src/components/ui/chart.tsx
+1
-0

// @ts-nocheck
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)
client/src/game/StarThrone.d.ts
New
+2
-0

declare const StarThrone: any;
export default StarThrone;
server/GameEngine.ts
+2
-0

@@ -154,50 +154,52 @@ export class GameEngine {
    for (let i = 0; i < territories.length; i++) {
      for (let j = i + 1; j < territories.length; j++) {
        const territory1 = territories[i];
        const territory2 = territories[j];
        
        const distance = Math.sqrt(
          Math.pow(territory2.x - territory1.x, 2) +
          Math.pow(territory2.y - territory1.y, 2)
        );
        
        if (distance <= GAME_CONSTANTS.CONNECTION_DISTANCE) {
          // All connections are hidden initially since all territories are colonizable
          territory1.hiddenNeighbors.push(territory2.id);
          territory2.hiddenNeighbors.push(territory1.id);
        }
      }
    }
  }

  public addPlayer(playerId: string, name: string, color: string, type: 'human' | 'ai'): void {
    const player: PlayerState = {
      id: playerId,
      name,
      color,
      type,
      range: GAME_CONSTANTS.BASE_RANGE,
      rangeLevel: 0,
      territoriesOwned: 0,
      totalArmies: 0,
      isEliminated: false,
      territories: [],
      armyGenRate: 1
    };

    this.gameState.players[playerId] = player;
    log(`Player ${name} (${type}) added to game`);
  }

  public startGame(): void {
    this.gameState.gamePhase = 'playing';
    this.distributeStartingTerritories();
    log('Game started with server-authoritative engine');
  }

  private distributeStartingTerritories(): void {
    const players = Object.values(this.gameState.players);
    const territories = Object.values(this.gameState.territories);
    const availableTerritories = [...territories];
    
    // Shuffle territories
    for (let i = availableTerritories.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
server/vite.ts
+1
-1

@@ -4,51 +4,51 @@ import path, { dirname } from "path";
import { fileURLToPath } from "url";
import { createServer as createViteServer, createLogger } from "vite";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        __dirname,
        "..",
        "client",